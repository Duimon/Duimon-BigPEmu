#version 430 es
precision mediump float;
precision highp int;

layout(binding = 0, std140) uniform UBO
{
    highp mat4 MVP;
    highp vec4 SourceSize;
    highp vec4 OriginalSize;
    highp vec4 OriginalFeedbackSize;
    highp vec4 OutputSize;
    highp vec4 FinalViewportSize;
    highp vec4 DerezedPassSize;
    int FrameDirection;
    uint FrameCount;
    highp float HSM_RESOLUTION_DEBUG_ON;
    highp float HSM_SINDEN_BORDER_ON;
    highp float HSM_SINDEN_BORDER_OPACITY;
    highp float HSM_SINDEN_BORDER_BRIGHTNESS;
    highp float HSM_SINDEN_AMBIENT_LIGHTING;
    highp float HSM_SINDEN_BORDER_THICKNESS;
    highp float HSM_SINDEN_BORDER_EMPTY_TUBE_COMPENSATION;
    highp float HSM_CACHE_GRAPHICS_ON;
    highp float HSM_CACHE_UPDATE_INDICATOR_MODE;
    highp float HSM_GLOBAL_GRAPHICS_BRIGHTNESS;
    highp float HSM_STATIC_LAYERS_GAMMA;
    highp float HSM_AMBIENT_LIGHTING_OPACITY;
    highp float HSM_AMBIENT1_OPACITY;
    highp float HSM_AMBIENT2_OPACITY;
    highp float HSM_AMBIENT_LIGHTING_SWAP_IMAGE_MODE;
    highp float HSM_AMBIENT1_HUE;
    highp float HSM_AMBIENT1_SATURATION;
    highp float HSM_AMBIENT1_VALUE;
    highp float HSM_AMBIENT1_CONTRAST;
    highp float HSM_AMBIENT1_SCALE_KEEP_ASPECT;
    highp float HSM_AMBIENT1_SCALE_INHERIT_MODE;
    highp float HSM_AMBIENT1_SCALE;
    highp float HSM_AMBIENT1_SCALE_X;
    highp float HSM_AMBIENT1_ROTATE;
    highp float HSM_AMBIENT1_MIRROR_HORZ;
    highp float HSM_AMBIENT1_POS_INHERIT_MODE;
    highp float HSM_AMBIENT1_POSITION_X;
    highp float HSM_AMBIENT1_POSITION_Y;
    highp float HSM_AMBIENT1_DITHERING_SAMPLES;
    highp float HSM_AMBIENT2_HUE;
    highp float HSM_AMBIENT2_SATURATION;
    highp float HSM_AMBIENT2_VALUE;
    highp float HSM_AMBIENT2_CONTRAST;
    highp float HSM_AMBIENT2_SCALE_KEEP_ASPECT;
    highp float HSM_AMBIENT2_SCALE_INHERIT_MODE;
    highp float HSM_AMBIENT2_SCALE;
    highp float HSM_AMBIENT2_SCALE_X;
    highp float HSM_AMBIENT2_ROTATE;
    highp float HSM_AMBIENT2_MIRROR_HORZ;
    highp float HSM_AMBIENT2_POS_INHERIT_MODE;
    highp float HSM_AMBIENT2_POSITION_X;
    highp float HSM_AMBIENT2_POSITION_Y;
    highp float HSM_VIEWPORT_ZOOM;
    highp float HSM_VIEWPORT_POSITION_X;
    highp float HSM_VIEWPORT_POSITION_Y;
    highp float HSM_VIEWPORT_ZOOM_MASK;
    highp float HSM_FLIP_VIEWPORT_VERTICAL;
    highp float HSM_FLIP_VIEWPORT_HORIZONTAL;
    highp float HSM_FLIP_CORE_VERTICAL;
    highp float HSM_FLIP_CORE_HORIZONTAL;
    highp float HSM_ROTATE_CORE_IMAGE;
    highp float HSM_ASPECT_RATIO_ORIENTATION;
    highp float HSM_ASPECT_RATIO_MODE;
    highp float HSM_ASPECT_RATIO_EXPLICIT;
    highp float HSM_INT_SCALE_MODE;
    highp float HSM_INT_SCALE_MULTIPLE_OFFSET;
    highp float HSM_INT_SCALE_MULTIPLE_OFFSET_LONG;
    highp float HSM_INT_SCALE_MAX_HEIGHT;
    highp float HSM_VERTICAL_PRESET;
    highp float HSM_NON_INTEGER_SCALE;
    highp float HSM_USE_PHYSICAL_SIZE_FOR_NON_INTEGER;
    highp float HSM_PHYSICAL_MONITOR_ASPECT_RATIO;
    highp float HSM_PHYSICAL_MONITOR_DIAGONAL_SIZE;
    highp float HSM_PHYSICAL_SIM_TUBE_DIAGONAL_SIZE;
    highp float HSM_USE_IMAGE_FOR_PLACEMENT;
    highp float HSM_PLACEMENT_IMAGE_USE_HORIZONTAL;
    highp float HSM_PLACEMENT_IMAGE_MODE;
    highp float HSM_NON_INTEGER_SCALE_OFFSET;
    highp float HSM_USE_SNAP_TO_CLOSEST_INT_SCALE;
    highp float HSM_SNAP_TO_CLOSEST_INT_SCALE_TOLERANCE;
    highp float HSM_SCREEN_POSITION_X;
    highp float HSM_SCREEN_POSITION_Y;
    highp float HSM_CROP_MODE;
    highp float HSM_CROP_PERCENT_ZOOM;
    highp float HSM_CROP_PERCENT_TOP;
    highp float HSM_CROP_PERCENT_BOTTOM;
    highp float HSM_CROP_PERCENT_LEFT;
    highp float HSM_CROP_PERCENT_RIGHT;
    highp float HSM_CROP_BLACK_THRESHOLD;
    highp float HSM_SCANLINE_DIRECTION;
    highp float HSM_CORE_RES_SAMPLING_MULT_SCANLINE_DIR;
    highp float HSM_DOWNSAMPLE_BLUR_SCANLINE_DIR;
    highp float HSM_CORE_RES_SAMPLING_MULT_OPPOSITE_DIR;
    highp float HSM_DOWNSAMPLE_BLUR_OPPOSITE_DIR;
    highp float HSM_CORE_RES_SAMPLING_SHIFT_OPPOSITE_DIR;
    highp float HSM_INTERLACE_TRIGGER_RES;
    highp float HSM_INTERLACE_MODE;
    highp float HSM_INTERLACE_EFFECT_SMOOTHNESS_INTERS;
    highp float HSM_INTERLACE_SCANLINE_EFFECT;
    highp float iscans;
    highp float HSM_FAKE_SCANLINE_MODE;
    highp float HSM_FAKE_SCANLINE_OPACITY;
    highp float HSM_FAKE_SCANLINE_RES_MODE;
    highp float HSM_FAKE_SCANLINE_RES;
    highp float HSM_FAKE_SCANLINE_INT_SCALE;
    highp float HSM_FAKE_SCANLINE_ROLL;
    highp float HSM_FAKE_SCANLINE_CURVATURE;
    highp float HSM_FAKE_SCANLINE_BRIGHTNESS_CUTOFF;
    highp float HSM_DUALSCREEN_MODE;
    highp float HSM_DUALSCREEN_CORE_IMAGE_SPLIT_MODE;
    highp float HSM_DUALSCREEN_CORE_IMAGE_SWAP_SCREENS;
    highp float HSM_DUALSCREEN_CORE_IMAGE_SPLIT_OFFSET;
    highp float HSM_DUALSCREEN_VIEWPORT_SPLIT_LOCATION;
    highp float HSM_DUALSCREEN_SHIFT_POSITION_WITH_SCALE;
    highp float HSM_DUALSCREEN_POSITION_OFFSET_BETWEEN_SCREENS;
    highp float HSM_2ND_SCREEN_ASPECT_RATIO_MODE;
    highp float HSM_2ND_SCREEN_INDEPENDENT_SCALE;
    highp float HSM_2ND_SCREEN_SCALE_OFFSET;
    highp float HSM_2ND_SCREEN_POS_X;
    highp float HSM_2ND_SCREEN_POS_Y;
    highp float HSM_2ND_SCREEN_CROP_PERCENT_ZOOM;
    highp float HSM_2ND_SCREEN_CROP_PERCENT_TOP;
    highp float HSM_2ND_SCREEN_CROP_PERCENT_BOTTOM;
    highp float HSM_2ND_SCREEN_CROP_PERCENT_LEFT;
    highp float HSM_2ND_SCREEN_CROP_PERCENT_RIGHT;
    highp float HSM_CURVATURE_MODE;
    highp float HSM_CURVATURE_2D_SCALE_LONG_AXIS;
    highp float HSM_CURVATURE_2D_SCALE_SHORT_AXIS;
    highp float HSM_CURVATURE_3D_RADIUS;
    highp float HSM_CURVATURE_3D_VIEW_DIST;
    highp float HSM_CURVATURE_3D_TILT_ANGLE_X;
    highp float HSM_CURVATURE_3D_TILT_ANGLE_Y;
    highp float HSM_CRT_CURVATURE_SCALE;
    highp float HSM_SIGNAL_NOISE_ON;
    highp float HSM_SIGNAL_NOISE_AMOUNT;
    highp float HSM_SIGNAL_NOISE_BLACK_LEVEL;
    highp float HSM_SIGNAL_NOISE_SIZE_MODE;
    highp float HSM_SIGNAL_NOISE_SIZE_MULT;
    highp float HSM_SIGNAL_NOISE_TYPE;
    highp float HSM_ANTI_FLICKER_ON;
    highp float HSM_ANTI_FLICKER_THRESHOLD;
    highp float HSM_AB_COMPARE_SHOW_MODE;
    highp float HSM_AB_COMPARE_AREA;
    highp float HSM_AB_COMPARE_FREEZE_CRT_TUBE;
    highp float HSM_AB_COMPARE_FREEZE_GRAPHICS;
    highp float HSM_AB_COMPARE_SPLIT_AREA;
    highp float HSM_AB_COMPARE_SPLIT_POSITION;
    highp float HSM_SHOW_PASS_INDEX;
    highp float HSM_SHOW_PASS_ALPHA;
    highp float HSM_SHOW_PASS_APPLY_SCREEN_COORD;
    highp float HSM_SCREEN_VIGNETTE_ON;
    highp float HSM_SCREEN_VIGNETTE_DUALSCREEN_VIS_MODE;
    highp float HSM_SCREEN_VIGNETTE_STRENGTH;
    highp float HSM_SCREEN_VIGNETTE_POWER;
    highp float HSM_SCREEN_VIGNETTE_IN_REFLECTION;
    highp float HSM_MONOCHROME_MODE;
    highp float HSM_MONOCHROME_BRIGHTNESS;
    highp float HSM_MONOCHROME_GAMMA;
    highp float HSM_MONOCHROME_HUE_OFFSET;
    highp float HSM_MONOCHROME_SATURATION;
    highp float HSM_MONOCHROME_DUALSCREEN_VIS_MODE;
    highp float HSM_SCREEN_REFLECTION_SCALE;
    highp float HSM_SCREEN_REFLECTION_POS_X;
    highp float HSM_SCREEN_REFLECTION_POS_Y;
    highp float HSM_TUBE_DIFFUSE_MODE;
    highp float HSM_TUBE_DIFFUSE_IMAGE_DUALSCREEN_VIS_MODE;
    highp float HSM_TUBE_OPACITY;
    highp float HSM_TUBE_DIFFUSE_IMAGE_AMOUNT;
    highp float HSM_TUBE_DIFFUSE_IMAGE_HUE;
    highp float HSM_TUBE_DIFFUSE_IMAGE_COLORIZE_ON;
    highp float HSM_TUBE_DIFFUSE_IMAGE_SATURATION;
    highp float HSM_TUBE_DIFFUSE_IMAGE_BRIGHTNESS;
    highp float HSM_TUBE_DIFFUSE_IMAGE_GAMMA;
    highp float HSM_TUBE_DIFFUSE_IMAGE_AMBIENT_LIGHTING;
    highp float HSM_TUBE_DIFFUSE_IMAGE_AMBIENT2_LIGHTING;
    highp float HSM_TUBE_DIFFUSE_IMAGE_SCALE;
    highp float HSM_TUBE_DIFFUSE_IMAGE_SCALE_X;
    highp float HSM_TUBE_DIFFUSE_IMAGE_ROTATION;
    highp float HSM_TUBE_EMPTY_THICKNESS;
    highp float HSM_TUBE_EMPTY_THICKNESS_X_SCALE;
    highp float HSM_TUBE_DIFFUSE_FORCE_ASPECT;
    highp float HSM_TUBE_EXPLICIT_ASPECT;
    highp float HSM_SCREEN_CORNER_RADIUS_SCALE;
    highp float HSM_TUBE_COLORED_GEL_IMAGE_ON;
    highp float HSM_TUBE_COLORED_GEL_IMAGE_DUALSCREEN_VIS_MODE;
    highp float HSM_TUBE_COLORED_GEL_IMAGE_MULTIPLY_AMOUNT;
    highp float HSM_TUBE_COLORED_GEL_IMAGE_NORMAL_AMOUNT;
    highp float HSM_TUBE_COLORED_GEL_IMAGE_NORMAL_BRIGHTNESS;
    highp float HSM_TUBE_COLORED_GEL_IMAGE_NORMAL_VIGNETTE;
    highp float HSM_TUBE_COLORED_GEL_IMAGE_TRANSPARENCY_THRESHOLD;
    highp float HSM_TUBE_COLORED_GEL_IMAGE_ADDITIVE_AMOUNT;
    highp float HSM_SHOW_CRT_ON_TOP_OF_COLORED_GEL;
    highp float HSM_TUBE_SHADOW_IMAGE_ON;
    highp float HSM_TUBE_SHADOW_IMAGE_OPACITY;
    highp float HSM_TUBE_SHADOW_IMAGE_SCALE_X;
    highp float HSM_TUBE_SHADOW_IMAGE_SCALE_Y;
    highp float HSM_TUBE_SHADOW_IMAGE_POS_X;
    highp float HSM_TUBE_SHADOW_IMAGE_POS_Y;
    highp float HSM_TUBE_SHADOW_CURVATURE_SCALE;
    highp float HSM_TUBE_COLORED_GEL_IMAGE_AMBIENT_LIGHTING;
    highp float HSM_TUBE_COLORED_GEL_IMAGE_AMBIENT2_LIGHTING;
    highp float HSM_TUBE_COLORED_GEL_IMAGE_FAKE_SCANLINE_AMOUNT;
    highp float HSM_TUBE_COLORED_GEL_IMAGE_SCALE;
    highp float HSM_TUBE_COLORED_GEL_IMAGE_FLIP_HORIZONTAL;
    highp float HSM_TUBE_COLORED_GEL_IMAGE_FLIP_VERTICAL;
    highp float HSM_TUBE_STATIC_REFLECTION_IMAGE_ON;
    highp float HSM_TUBE_STATIC_REFLECTION_IMAGE_DUALSCREEN_VIS_MODE;
    highp float HSM_TUBE_STATIC_REFLECTION_IMAGE_OPACITY;
    highp float HSM_TUBE_STATIC_OPACITY_DIFFUSE_MULTIPLY;
    highp float HSM_TUBE_STATIC_BLACK_LEVEL;
    highp float HSM_TUBE_STATIC_AMBIENT_LIGHTING;
    highp float HSM_TUBE_STATIC_AMBIENT2_LIGHTING;
    highp float HSM_TUBE_STATIC_SCALE;
    highp float HSM_TUBE_STATIC_SCALE_X;
    highp float HSM_TUBE_STATIC_POS_X;
    highp float HSM_TUBE_STATIC_POS_Y;
    highp float HSM_TUBE_STATIC_SHADOW_OPACITY;
    highp float HSM_TUBE_STATIC_DITHER_SAMPLES;
    highp float HSM_TUBE_STATIC_DITHER_DISTANCE;
    highp float HSM_TUBE_STATIC_DITHER_AMOUNT;
    highp float HSM_CRT_BLEND_MODE;
    highp float HSM_CRT_BLEND_AMOUNT;
    highp float HSM_CRT_SCREEN_BLEND_MODE;
    highp float HSM_GLOBAL_CORNER_RADIUS;
    highp float HSM_TUBE_BLACK_EDGE_CORNER_RADIUS_SCALE;
    highp float HSM_TUBE_BLACK_EDGE_SHARPNESS;
    highp float HSM_TUBE_BLACK_EDGE_CURVATURE_SCALE;
    highp float HSM_TUBE_BLACK_EDGE_THICKNESS;
    highp float HSM_TUBE_BLACK_EDGE_THICKNESS_X_SCALE;
    highp float HSM_BZL_USE_INDEPENDENT_SCALE;
    highp float HSM_BZL_INDEPENDENT_SCALE;
    highp float HSM_BZL_USE_INDEPENDENT_CURVATURE;
    highp float HSM_BZL_INDEPENDENT_CURVATURE_SCALE_LONG_AXIS;
    highp float HSM_BZL_INDEPENDENT_CURVATURE_SCALE_SHORT_AXIS;
    highp float HSM_BZL_OPACITY;
    highp float HSM_BZL_BLEND_MODE;
    highp float HSM_BZL_WIDTH;
    highp float HSM_BZL_HEIGHT;
    highp float HSM_BZL_SCALE_OFFSET;
    highp float HSM_BZL_INNER_CURVATURE_SCALE;
    highp float HSM_BZL_INNER_CORNER_RADIUS_SCALE;
    highp float HSM_BZL_OUTER_CURVATURE_SCALE;
    highp float HSM_BZL_INNER_EDGE_THICKNESS;
    highp float HSM_BZL_INNER_EDGE_SHARPNESS;
    highp float HSM_BZL_OUTER_CORNER_RADIUS_SCALE;
    highp float HSM_BZL_INNER_EDGE_SHADOW;
    highp float HSM_BZL_COLOR_HUE;
    highp float HSM_BZL_COLOR_SATURATION;
    highp float HSM_BZL_COLOR_VALUE;
    highp float HSM_BZL_NOISE;
    highp float HSM_BZL_BRIGHTNESS;
    highp float HSM_BZL_BRIGHTNESS_MULT_TOP;
    highp float HSM_BZL_BRIGHTNESS_MULT_BOTTOM;
    highp float HSM_BZL_BRIGHTNESS_MULT_SIDES;
    highp float HSM_BZL_BRIGHTNESS_MULT_SIDE_LEFT;
    highp float HSM_BZL_BRIGHTNESS_MULT_SIDE_RIGHT;
    highp float HSM_BZL_HIGHLIGHT;
    highp float HSM_BZL_INNER_EDGE_HIGHLIGHT;
    highp float HSM_BZL_AMBIENT_LIGHTING_MULTIPLIER;
    highp float HSM_BZL_AMBIENT2_LIGHTING_MULTIPLIER;
    highp float HSM_FRM_USE_INDEPENDENT_COLOR;
    highp float HSM_FRM_COLOR_HUE;
    highp float HSM_FRM_COLOR_SATURATION;
    highp float HSM_FRM_COLOR_VALUE;
    highp float HSM_FRM_NOISE;
    highp float HSM_FRM_OUTER_CURVATURE_SCALE;
    highp float HSM_FRM_THICKNESS;
    highp float HSM_FRM_THICKNESS_SCALE_X;
    highp float HSM_FRM_OUTER_POS_Y;
    highp float HSM_FRM_INNER_EDGE_THICKNESS;
    highp float HSM_FRM_INNER_EDGE_HIGHLIGHT;
    highp float HSM_FRM_OUTER_EDGE_THICKNESS;
    highp float HSM_FRM_OUTER_EDGE_SHADING;
    highp float HSM_FRM_OUTER_CORNER_RADIUS;
    highp float HSM_BZL_OUTER_POSITION_Y;
    highp float HSM_FRM_SHADOW_OPACITY;
    highp float HSM_FRM_SHADOW_WIDTH;
    highp float HSM_REFLECT_CORNER_FADE;
    highp float HSM_REFLECT_CORNER_INNER_SPREAD;
    highp float HSM_REFLECT_CORNER_OUTER_SPREAD;
    highp float HSM_REFLECT_CORNER_ROTATION_OFFSET_TOP;
    highp float HSM_REFLECT_CORNER_ROTATION_OFFSET_BOTTOM;
    highp float HSM_REFLECT_CORNER_SPREAD_FALLOFF;
    highp float HSM_REFLECT_CORNER_FADE_DISTANCE;
    highp float HSM_REFLECT_GLOBAL_AMOUNT;
    highp float HSM_REFLECT_GLOBAL_GAMMA_ADJUST;
    highp float HSM_REFLECT_BEZEL_INNER_EDGE_AMOUNT;
    highp float HSM_REFLECT_BEZEL_INNER_EDGE_FULLSCREEN_GLOW;
    highp float HSM_REFLECT_FRAME_INNER_EDGE_AMOUNT;
    highp float HSM_REFLECT_FRAME_INNER_EDGE_SHARPNESS;
    highp float HSM_REFLECT_SHOW_TUBE_FX_AMOUNT;
    highp float HSM_REFLECT_DIRECT_AMOUNT;
    highp float HSM_REFLECT_DIFFUSED_AMOUNT;
    highp float HSM_REFLECT_FULLSCREEN_GLOW;
    highp float HSM_REFLECT_FULLSCREEN_GLOW_GAMMA;
    highp float HSM_REFLECT_FADE_AMOUNT;
    highp float HSM_REFLECT_RADIAL_FADE_WIDTH;
    highp float HSM_REFLECT_RADIAL_FADE_HEIGHT;
    highp float HSM_REFLECT_LATERAL_OUTER_FADE_POSITION;
    highp float HSM_REFLECT_LATERAL_OUTER_FADE_DISTANCE;
    highp float HSM_REFLECT_NOISE_AMOUNT;
    highp float HSM_REFLECT_NOISE_SAMPLES;
    highp float HSM_REFLECT_NOISE_SAMPLE_DISTANCE;
    highp float HSM_REFLECT_BLUR_NUM_SAMPLES;
    highp float HSM_REFLECT_BLUR_FALLOFF_DISTANCE;
    highp float HSM_REFLECT_BLUR_MIN;
    highp float HSM_REFLECT_BLUR_MAX;
    highp float HSM_REFLECT_MASK_IMAGE_AMOUNT;
    highp float HSM_REFLECT_MASK_FOLLOW_LAYER;
    highp float HSM_REFLECT_MASK_FOLLOW_MODE;
    highp float HSM_REFLECT_MASK_BRIGHTNESS;
    highp float HSM_REFLECT_MASK_BLACK_LEVEL;
    highp float HSM_REFLECT_MASK_MIPMAPPING_BLEND_BIAS;
    highp float HSM_GLASS_BORDER_ON;
    highp float HSM_REFLECT_VIGNETTE_AMOUNT;
    highp float HSM_REFLECT_VIGNETTE_SIZE;
    highp float HSM_POTATO_SHOW_BG_OVER_SCREEN;
    highp float HSM_POTATO_COLORIZE_CRT_WITH_BG;
    highp float HSM_POTATO_COLORIZE_BRIGHTNESS;
    highp float HSM_STANDARD_DECAL_SCALE_WITH_FRAME;
    highp float HSM_STANDARD_TOP_SCALE_WITH_FRAME;
    highp float HSM_BG_LAYER_ORDER;
    highp float HSM_VIEWPORT_VIGNETTE_LAYER_ORDER;
    highp float HSM_CRT_LAYER_ORDER;
    highp float HSM_DEVICE_LAYER_ORDER;
    highp float HSM_DEVICELED_LAYER_ORDER;
    highp float HSM_CAB_GLASS_LAYER_ORDER;
    highp float HSM_DECAL_LAYER_ORDER;
    highp float HSM_LED_LAYER_ORDER;
    highp float HSM_TOP_LAYER_ORDER;
    highp float HSM_CUTOUT_ASPECT_MODE;
    highp float HSM_CUTOUT_EXPLICIT_ASPECT;
    highp float HSM_CUTOUT_FOLLOW_LAYER;
    highp float HSM_CUTOUT_FOLLOW_FULL_USES_ZOOM;
    highp float HSM_CUTOUT_SCALE;
    highp float HSM_CUTOUT_SCALE_X;
    highp float HSM_CUTOUT_CORNER_RADIUS;
    highp float HSM_CUTOUT_POS_X;
    highp float HSM_CUTOUT_POS_Y;
    highp float HSM_BG_OPACITY;
    highp float HSM_BG_HUE;
    highp float HSM_BG_COLORIZE_ON;
    highp float HSM_BG_SATURATION;
    highp float HSM_BG_BRIGHTNESS;
    highp float HSM_BG_GAMMA;
    highp float HSM_BG_AMBIENT_LIGHTING_MULTIPLIER;
    highp float HSM_BG_AMBIENT2_LIGHTING_MULTIPLIER;
    highp float HSM_BG_APPLY_AMBIENT_IN_ADD_MODE;
    highp float HSM_BG_BLEND_MODE;
    highp float HSM_BG_SOURCE_MATTE_TYPE;
    highp float HSM_BG_MASK_MODE;
    highp float HSM_BG_CUTOUT_MODE;
    highp float HSM_BG_DUALSCREEN_VIS_MODE;
    highp float HSM_BG_FOLLOW_LAYER;
    highp float HSM_BG_FOLLOW_MODE;
    highp float HSM_BG_FOLLOW_FULL_USES_ZOOM;
    highp float HSM_BG_FILL_MODE;
    highp float HSM_BG_SPLIT_PRESERVE_CENTER;
    highp float HSM_BG_SPLIT_REPEAT_WIDTH;
    highp float HSM_BG_SCALE;
    highp float HSM_BG_SCALE_X;
    highp float HSM_BG_POS_X;
    highp float HSM_BG_POS_Y;
    highp float HSM_BG_WRAP_MODE;
    highp float HSM_BG_MIPMAPPING_BLEND_BIAS;
    highp float HSM_VIEWPORT_VIGNETTE_OPACITY;
    highp float HSM_VIEWPORT_VIGNETTE_MASK_MODE;
    highp float HSM_VIEWPORT_VIGNETTE_CUTOUT_MODE;
    highp float HSM_VIEWPORT_VIGNETTE_FOLLOW_LAYER;
    highp float HSM_VIEWPORT_VIGNETTE_SCALE;
    highp float HSM_VIEWPORT_VIGNETTE_SCALE_X;
    highp float HSM_VIEWPORT_VIGNETTE_POS_X;
    highp float HSM_VIEWPORT_VIGNETTE_POS_Y;
    highp float HSM_LED_OPACITY;
    highp float HSM_LED_HUE;
    highp float HSM_LED_COLORIZE_ON;
    highp float HSM_LED_SATURATION;
    highp float HSM_LED_BRIGHTNESS;
    highp float HSM_LED_GAMMA;
    highp float HSM_LED_AMBIENT_LIGHTING_MULTIPLIER;
    highp float HSM_LED_AMBIENT2_LIGHTING_MULTIPLIER;
    highp float HSM_LED_APPLY_AMBIENT_IN_ADD_MODE;
    highp float HSM_LED_BLEND_MODE;
    highp float HSM_LED_SOURCE_MATTE_TYPE;
    highp float HSM_LED_MASK_MODE;
    highp float HSM_LED_CUTOUT_MODE;
    highp float HSM_LED_DUALSCREEN_VIS_MODE;
    highp float HSM_LED_FOLLOW_LAYER;
    highp float HSM_LED_FOLLOW_MODE;
    highp float HSM_LED_FOLLOW_FULL_USES_ZOOM;
    highp float HSM_LED_FILL_MODE;
    highp float HSM_LED_SPLIT_PRESERVE_CENTER;
    highp float HSM_LED_SPLIT_REPEAT_WIDTH;
    highp float HSM_LED_SCALE;
    highp float HSM_LED_SCALE_X;
    highp float HSM_LED_POS_X;
    highp float HSM_LED_POS_Y;
    highp float HSM_LED_MIPMAPPING_BLEND_BIAS;
    highp float HSM_DEVICE_OPACITY;
    highp float HSM_DEVICE_HUE;
    highp float HSM_DEVICE_COLORIZE_ON;
    highp float HSM_DEVICE_SATURATION;
    highp float HSM_DEVICE_BRIGHTNESS;
    highp float HSM_DEVICE_GAMMA;
    highp float HSM_DEVICE_AMBIENT_LIGHTING_MULTIPLIER;
    highp float HSM_DEVICE_AMBIENT2_LIGHTING_MULTIPLIER;
    highp float HSM_DEVICE_APPLY_AMBIENT_IN_ADD_MODE;
    highp float HSM_DEVICE_BLEND_MODE;
    highp float HSM_DEVICE_SOURCE_MATTE_TYPE;
    highp float HSM_DEVICE_MASK_MODE;
    highp float HSM_DEVICE_CUTOUT_MODE;
    highp float HSM_DEVICE_DUALSCREEN_VIS_MODE;
    highp float HSM_DEVICE_FOLLOW_LAYER;
    highp float HSM_DEVICE_FOLLOW_MODE;
    highp float HSM_DEVICE_FOLLOW_FULL_USES_ZOOM;
    highp float HSM_DEVICE_FILL_MODE;
    highp float HSM_DEVICE_SPLIT_PRESERVE_CENTER;
    highp float HSM_DEVICE_SPLIT_REPEAT_WIDTH;
    highp float HSM_DEVICE_SCALE;
    highp float HSM_DEVICE_SCALE_X;
    highp float HSM_DEVICE_POS_X;
    highp float HSM_DEVICE_POS_Y;
    highp float HSM_DEVICE_MIPMAPPING_BLEND_BIAS;
    highp float HSM_DEVICELED_OPACITY;
    highp float HSM_DEVICELED_HUE;
    highp float HSM_DEVICELED_COLORIZE_ON;
    highp float HSM_DEVICELED_SATURATION;
    highp float HSM_DEVICELED_BRIGHTNESS;
    highp float HSM_DEVICELED_GAMMA;
    highp float HSM_DEVICELED_AMBIENT_LIGHTING_MULTIPLIER;
    highp float HSM_DEVICELED_AMBIENT2_LIGHTING_MULTIPLIER;
    highp float HSM_DEVICELED_APPLY_AMBIENT_IN_ADD_MODE;
    highp float HSM_DEVICELED_BLEND_MODE;
    highp float HSM_DEVICELED_SOURCE_MATTE_TYPE;
    highp float HSM_DEVICELED_MASK_MODE;
    highp float HSM_DEVICELED_CUTOUT_MODE;
    highp float HSM_DEVICELED_DUALSCREEN_VIS_MODE;
    highp float HSM_DEVICELED_FOLLOW_LAYER;
    highp float HSM_DEVICELED_FOLLOW_MODE;
    highp float HSM_DEVICELED_FOLLOW_FULL_USES_ZOOM;
    highp float HSM_DEVICELED_FILL_MODE;
    highp float HSM_DEVICELED_SPLIT_PRESERVE_CENTER;
    highp float HSM_DEVICELED_SPLIT_REPEAT_WIDTH;
    highp float HSM_DEVICELED_SCALE;
    highp float HSM_DEVICELED_SCALE_X;
    highp float HSM_DEVICELED_POS_X;
    highp float HSM_DEVICELED_POS_Y;
    highp float HSM_DEVICELED_MIPMAPPING_BLEND_BIAS;
    highp float HSM_FRM_OPACITY;
    highp float HSM_FRM_BLEND_MODE;
    highp float HSM_FRM_TEXTURE_OPACITY;
    highp float HSM_FRM_TEXTURE_BLEND_MODE;
    highp float HSM_DECAL_OPACITY;
    highp float HSM_DECAL_HUE;
    highp float HSM_DECAL_COLORIZE_ON;
    highp float HSM_DECAL_SATURATION;
    highp float HSM_DECAL_BRIGHTNESS;
    highp float HSM_DECAL_GAMMA;
    highp float HSM_DECAL_AMBIENT_LIGHTING_MULTIPLIER;
    highp float HSM_DECAL_AMBIENT2_LIGHTING_MULTIPLIER;
    highp float HSM_DECAL_APPLY_AMBIENT_IN_ADD_MODE;
    highp float HSM_DECAL_BLEND_MODE;
    highp float HSM_DECAL_SOURCE_MATTE_TYPE;
    highp float HSM_DECAL_MASK_MODE;
    highp float HSM_DECAL_CUTOUT_MODE;
    highp float HSM_DECAL_DUALSCREEN_VIS_MODE;
    highp float HSM_DECAL_FOLLOW_LAYER;
    highp float HSM_DECAL_FOLLOW_MODE;
    highp float HSM_DECAL_FOLLOW_FULL_USES_ZOOM;
    highp float HSM_DECAL_FILL_MODE;
    highp float HSM_DECAL_SPLIT_PRESERVE_CENTER;
    highp float HSM_DECAL_SPLIT_REPEAT_WIDTH;
    highp float HSM_DECAL_SCALE;
    highp float HSM_DECAL_SCALE_X;
    highp float HSM_DECAL_POS_X;
    highp float HSM_DECAL_POS_Y;
    highp float HSM_DECAL_MIPMAPPING_BLEND_BIAS;
    highp float HSM_CAB_GLASS_OPACITY;
    highp float HSM_CAB_GLASS_HUE;
    highp float HSM_CAB_GLASS_COLORIZE_ON;
    highp float HSM_CAB_GLASS_SATURATION;
    highp float HSM_CAB_GLASS_BRIGHTNESS;
    highp float HSM_CAB_GLASS_GAMMA;
    highp float HSM_CAB_GLASS_AMBIENT_LIGHTING_MULTIPLIER;
    highp float HSM_CAB_GLASS_AMBIENT2_LIGHTING_MULTIPLIER;
    highp float HSM_CAB_GLASS_APPLY_AMBIENT_IN_ADD_MODE;
    highp float HSM_CAB_GLASS_BLEND_MODE;
    highp float HSM_CAB_GLASS_SOURCE_MATTE_TYPE;
    highp float HSM_CAB_GLASS_MASK_MODE;
    highp float HSM_CAB_GLASS_CUTOUT_MODE;
    highp float HSM_CAB_GLASS_DUALSCREEN_VIS_MODE;
    highp float HSM_CAB_GLASS_FOLLOW_LAYER;
    highp float HSM_CAB_GLASS_FOLLOW_MODE;
    highp float HSM_CAB_GLASS_FOLLOW_FULL_USES_ZOOM;
    highp float HSM_CAB_GLASS_FILL_MODE;
    highp float HSM_CAB_GLASS_SPLIT_PRESERVE_CENTER;
    highp float HSM_CAB_GLASS_SPLIT_REPEAT_WIDTH;
    highp float HSM_CAB_GLASS_SCALE;
    highp float HSM_CAB_GLASS_SCALE_X;
    highp float HSM_CAB_GLASS_POS_X;
    highp float HSM_CAB_GLASS_POS_Y;
    highp float HSM_CAB_GLASS_MIPMAPPING_BLEND_BIAS;
    highp float HSM_TOP_OPACITY;
    highp float HSM_TOP_HUE;
    highp float HSM_TOP_COLORIZE_ON;
    highp float HSM_TOP_SATURATION;
    highp float HSM_TOP_BRIGHTNESS;
    highp float HSM_TOP_GAMMA;
    highp float HSM_TOP_AMBIENT_LIGHTING_MULTIPLIER;
    highp float HSM_TOP_AMBIENT2_LIGHTING_MULTIPLIER;
    highp float HSM_TOP_APPLY_AMBIENT_IN_ADD_MODE;
    highp float HSM_TOP_BLEND_MODE;
    highp float HSM_TOP_SOURCE_MATTE_TYPE;
    highp float HSM_TOP_MASK_MODE;
    highp float HSM_TOP_CUTOUT_MODE;
    highp float HSM_TOP_DUALSCREEN_VIS_MODE;
    highp float HSM_TOP_FOLLOW_LAYER;
    highp float HSM_TOP_FOLLOW_MODE;
    highp float HSM_TOP_FOLLOW_FULL_USES_ZOOM;
    highp float HSM_TOP_FILL_MODE;
    highp float HSM_TOP_SPLIT_PRESERVE_CENTER;
    highp float HSM_TOP_SPLIT_REPEAT_WIDTH;
    highp float HSM_TOP_SCALE;
    highp float HSM_TOP_SCALE_X;
    highp float HSM_TOP_POS_X;
    highp float HSM_TOP_POS_Y;
    highp float HSM_TOP_MIRROR_WRAP;
    highp float HSM_TOP_MIPMAPPING_BLEND_BIAS;
    highp float HSM_RENDER_SIMPLE_MODE;
    highp float HSM_RENDER_SIMPLE_MASK_TYPE;
    highp float HSM_LAYERING_DEBUG_MASK_MODE;
    highp float HSM_INTRO_LOGO_BLEND_MODE;
    highp float HSM_INTRO_LOGO_FLIP_VERTICAL;
    highp float HSM_INTRO_NOISE_BLEND_MODE;
    highp float HSM_INTRO_NOISE_HOLD;
    highp float HSM_INTRO_NOISE_FADE_OUT;
    highp float HSM_INTRO_SOLID_BLACK_HOLD;
    highp float HSM_INTRO_SOLID_BLACK_FADE_OUT;
    highp float HSM_INTRO_SOLID_COLOR_BLEND_MODE;
    highp float HSM_INTRO_LOGO_OVER_SOLID_COLOR;
    highp float HSM_INTRO_LOGO_PLACEMENT;
    highp float HSM_INTRO_LOGO_HEIGHT;
    highp float HSM_INTRO_LOGO_POS_X;
    highp float HSM_INTRO_LOGO_POS_Y;
    highp float HSM_INTRO_WHEN_TO_SHOW;
    highp float HSM_INTRO_SPEED;
    highp float HSM_INTRO_LOGO_WAIT;
    highp float HSM_INTRO_LOGO_FADE_IN;
    highp float HSM_INTRO_LOGO_HOLD;
    highp float HSM_INTRO_LOGO_FADE_OUT;
    highp float HSM_INTRO_SOLID_COLOR_HUE;
    highp float HSM_INTRO_SOLID_COLOR_SAT;
    highp float HSM_INTRO_SOLID_COLOR_VALUE;
    highp float HSM_INTRO_SOLID_COLOR_HOLD;
    highp float HSM_INTRO_SOLID_COLOR_FADE_OUT;
    highp float GAMMA_INPUT;
    highp float gamma_out;
    highp float post_br;
    highp float post_br_affect_black_level;
    highp float m_glow;
    highp float m_glow_low;
    highp float m_glow_high;
    highp float m_glow_dist;
    highp float m_glow_mask;
    highp float smask_mit;
    highp float glow;
    highp float bloom;
    highp float mask_bloom;
    highp float bloom_dist;
    highp float halation;
    highp float TATE;
    highp float IOS;
    highp float HSM_OVERSCAN_RASTER_BLOOM_ON;
    highp float HSM_OVERSCAN_RASTER_BLOOM_MODE;
    highp float HSM_OVERSCAN_RASTER_BLOOM_AMOUNT;
    highp float HSM_OVERSCAN_AMOUNT;
    highp float HSM_OVERSCAN_X;
    highp float HSM_OVERSCAN_Y;
    highp float intres;
    highp float prescalex;
    highp float c_shape;
    highp float sborder;
    highp float csize;
    highp float bsize1;
    highp float warpX;
    highp float warpY;
    highp float gamma_c;
    highp float brightboost;
    highp float brightboost1;
    highp float blendMode;
    highp float gsl;
    highp float scanline1;
    highp float scanline2;
    highp float beam_min;
    highp float beam_max;
    highp float beam_size;
    highp float vertmask;
    highp float scans;
    highp float scan_falloff;
    highp float spike;
    highp float ring;
    highp float no_scanlines;
    highp float scangamma;
    highp float rolling_scan;
    highp float h_sharp;
    highp float s_sharp;
    highp float smart_ei;
    highp float ei_limit;
    highp float sth;
    highp float barspeed;
    highp float barintensity;
    highp float bardir;
    highp float shadowMask;
    highp float maskstr;
    highp float mcut;
    highp float maskboost;
    highp float masksize;
    highp float masksizeautothreshold;
    highp float maskDark;
    highp float maskLight;
    highp float mask_gamma;
    highp float slotmask;
    highp float slotmask1;
    highp float slotwidth;
    highp float double_slot;
    highp float slotms;
    highp float mclip;
    highp float smoothmask;
    highp float mshift;
    highp float mask_layout;
    highp float GDV_DECONVERGENCE_ON;
    highp float decons;
    highp float deconrr;
    highp float deconrg;
    highp float deconrb;
    highp float deconrry;
    highp float deconrgy;
    highp float deconrby;
    highp float deconsmooth;
    highp float dctypex;
    highp float dctypey;
    highp float dcscalemode;
    highp float GDV_NOISE_ON;
    highp float addnoised;
    highp float noisetype;
    highp float noiseresd;
    highp float noiseresd4kmult;
    highp float g_grade_on;
    highp float wp_temperature;
    highp float g_satr;
    highp float g_satg;
    highp float g_satb;
    highp float AS;
    highp float asat;
    highp float hcrt_h_size;
    highp float hcrt_v_size;
    highp float hcrt_h_cent;
    highp float hcrt_v_cent;
    highp float hcrt_pin_phase;
    highp float hcrt_pin_amp;
} global;

layout(binding = 7) uniform highp sampler2D Source;
layout(binding = 5) uniform highp sampler2D BloomPass;
layout(binding = 8) uniform highp sampler2D InfoCachePass;
layout(binding = 2) uniform highp sampler2D LinearizePass;
layout(binding = 3) uniform highp sampler2D AvgLumPass;
layout(binding = 4) uniform highp sampler2D GlowPass;

layout(location = 0) in highp vec2 vTexCoord;
layout(location = 0) out highp vec4 FragColor;
highp float FOLLOW_MODE_SCALE_AND_POS;
highp float FOLLOW_MODE_EXACT;
highp float NEGATIVE_CROP_EXPAND_MULTIPLIER;
highp float MAX_NEGATIVE_CROP;
highp float DEFAULT_SCREEN_ASPECT;
highp float DEFAULT_BEZEL_ASPECT;
highp vec2 DEFAULT_SCREEN_SCALE;
highp vec2 DEFAULT_BEZEL_SCALE;
int INFOCACHE_MAX_INDEX;
bool CACHE_INFO_CHANGED;
highp float CURRENT_FRAME_FROM_CACHE_INFO;
highp float TUBE_DIFFUSE_MASK;
highp float TUBE_MASK;
highp float BEZEL_MASK;
highp float INSIDE_BEZEL_MASK;
highp float OUTSIDE_TUBE_MASK_FOR_IMAGE;
highp float FRAME_MASK;
highp float FRAME_MASK_FOR_IMAGE;
highp float OUTSIDE_BEZEL_MASK;
highp float OUTSIDE_FRAME_MASK_FOR_IMAGE;
highp float OUTSIDE_FRAME_MASK;
highp float CUTOUT_MASK;
highp float SCREEN_INDEX;
highp float SCREEN_ASPECT;
highp vec2 SCREEN_SCALE;
highp vec2 SCREEN_SCALE_WITH_ZOOM;
highp vec2 SCREEN_POS_OFFSET;
highp vec2 SCREEN_SCALE_2ND_SCREEN;
highp vec2 SCREEN_POS_OFFSET_1ST_SCREEN;
highp vec2 SCREEN_POS_OFFSET_2ND_SCREEN;
highp vec2 VIEWPORT_SCALE;
highp vec2 VIEWPORT_POS;
highp vec2 TUBE_SCALE;
highp vec2 TUBE_DIFFUSE_SCALE;
highp float TUBE_DIFFUSE_ASPECT;
highp vec2 TUBE_DIFFUSE_SCALE_1ST_SCREEN;
highp vec2 TUBE_DIFFUSE_SCALE_2ND_SCREEN;
highp vec2 FRAME_SCALE;
highp vec2 BEZEL_OUTSIDE_SCALE;
highp vec2 BACKGROUND_SCALE;
highp vec2 LED_SCALE;
highp vec2 DEVICE_SCALE;
highp vec2 DEVICELED_SCALE;
highp vec2 DECAL_SCALE;
highp vec2 CAB_GLASS_SCALE;
highp vec2 TOP_IMAGE_SCALE;
highp float AVERAGE_LUMA;
highp float USE_VERTICAL_SCANLINES;
highp float SAMPLING_SCANLINE_DIR_MULT;
highp float SAMPLING_OPPOSITE_DIR_MULT;
highp vec2 CORE_SIZE;
highp vec2 ROTATED_CORE_ORIGINAL_SIZE;
highp vec2 ROTATED_CORE_PREPPED_SIZE;
highp vec2 ROTATED_DEREZED_SIZE;
highp vec2 CROPPED_ROTATED_SIZE_WITH_RES_MULT;
highp vec2 CROPPED_ROTATED_SIZE_WITH_RES_MULT_FEEDBACK;
highp vec2 CROPPED_ROTATED_SIZE;
highp vec2 SAMPLE_AREA_START_PIXEL_COORD;
highp vec2 SCREEN_SIZE;
highp vec2 VIEWPORT_UNSCALED_COORD;
highp vec2 SCREEN_COORD;
highp vec2 TUBE_COORD;
highp vec2 TUBE_DIFFUSE_COORD;
highp vec2 TUBE_DIFFUSE_COORD_MIXED_POS;
highp vec2 BEZEL_OUTSIDE_COORD;
highp vec2 BACKGROUND_COORD;
highp vec2 DEVICE_COORD;
highp vec2 DEVICELED_COORD;
highp vec2 LED_COORD;
highp vec2 DECAL_COORD;
highp vec2 CAB_GLASS_COORD;
highp vec2 TOP_IMAGE_COORD;
highp vec2 SCREEN_CURVED_COORD;
highp vec2 TUBE_CURVED_COORD;
highp vec2 TUBE_DIFFUSE_CURVED_COORD;
highp vec2 BEZEL_OUTSIDE_CURVED_COORD;
highp vec2 FRAME_OUTSIDE_CURVED_COORD;
highp vec2 BACKGROUND_CURVED_COORD;
highp vec2 LED_CURVED_COORD;
highp vec2 DEVICE_CURVED_COORD;
highp vec2 DEVICELED_CURVED_COORD;
highp vec2 DECAL_CURVED_COORD;
highp vec2 CAB_GLASS_CURVED_COORD;
highp vec2 TOP_IMAGE_CURVED_COORD;
highp float HSM_RESOLUTION_DEBUG_ON;
highp float HSM_GLOBAL_GRAPHICS_BRIGHTNESS;
highp float HSM_STATIC_LAYERS_GAMMA;
highp float HSM_AMBIENT_LIGHTING_OPACITY;
highp float HSM_AMBIENT1_OPACITY;
highp float HSM_AMBIENT2_OPACITY;
highp float HSM_AMBIENT_LIGHTING_SWAP_IMAGE_MODE;
highp float HSM_SINDEN_BORDER_ON;
highp float HSM_SINDEN_BORDER_BRIGHTNESS;
highp float HSM_SINDEN_BORDER_THICKNESS;
highp float HSM_SINDEN_BORDER_EMPTY_TUBE_COMPENSATION;
highp float HSM_VIEWPORT_ZOOM;
highp float HSM_VIEWPORT_ZOOM_MASK;
highp float HSM_VIEWPORT_POSITION_X;
highp float HSM_VIEWPORT_POSITION_Y;
highp float HSM_FLIP_VIEWPORT_VERTICAL;
highp float HSM_FLIP_VIEWPORT_HORIZONTAL;
highp float HSM_FLIP_CORE_VERTICAL;
highp float HSM_FLIP_CORE_HORIZONTAL;
highp float HSM_ROTATE_CORE_IMAGE;
highp float HSM_ASPECT_RATIO_ORIENTATION;
highp float HSM_ASPECT_RATIO_MODE;
highp float HSM_ASPECT_RATIO_EXPLICIT;
highp float HSM_VERTICAL_PRESET;
highp float HSM_INT_SCALE_MAX_HEIGHT;
highp float HSM_NON_INTEGER_SCALE;
highp float HSM_USE_PHYSICAL_SIZE_FOR_NON_INTEGER;
highp float HSM_PHYSICAL_MONITOR_ASPECT_RATIO;
highp float HSM_PHYSICAL_MONITOR_DIAGONAL_SIZE;
highp float HSM_PHYSICAL_SIM_TUBE_DIAGONAL_SIZE;
highp float HSM_USE_IMAGE_FOR_PLACEMENT;
highp float HSM_PLACEMENT_IMAGE_USE_HORIZONTAL;
highp float HSM_PLACEMENT_IMAGE_MODE;
highp float HSM_NON_INTEGER_SCALE_OFFSET;
highp float HSM_USE_SNAP_TO_CLOSEST_INT_SCALE;
highp float HSM_SNAP_TO_CLOSEST_INT_SCALE_TOLERANCE;
highp float HSM_SCREEN_POSITION_X;
highp float HSM_SCREEN_POSITION_Y;
highp float HSM_CROP_MODE;
highp float HSM_CROP_PERCENT_ZOOM;
highp float HSM_CROP_PERCENT_TOP;
highp float HSM_CROP_PERCENT_BOTTOM;
highp float HSM_CROP_PERCENT_LEFT;
highp float HSM_CROP_PERCENT_RIGHT;
highp float HSM_CROP_BLACK_THRESHOLD;
highp float HSM_SCANLINE_DIRECTION;
highp float HSM_CORE_RES_SAMPLING_MULT_SCANLINE_DIR;
highp float HSM_DOWNSAMPLE_BLUR_SCANLINE_DIR;
highp float HSM_CORE_RES_SAMPLING_MULT_OPPOSITE_DIR;
highp float HSM_DOWNSAMPLE_BLUR_OPPOSITE_DIR;
highp float HSM_USE_GEOM;
highp float HSM_CURVATURE_MODE;
highp float HSM_CURVATURE_3D_RADIUS;
highp float HSM_CURVATURE_3D_VIEW_DIST;
highp float HSM_CURVATURE_3D_TILT_ANGLE_X;
highp float HSM_CURVATURE_3D_TILT_ANGLE_Y;
highp float HSM_CRT_CURVATURE_SCALE;
highp float HSM_CACHE_GRAPHICS_ON;
highp float HSM_CACHE_UPDATE_INDICATOR_MODE;
highp float HSM_AB_COMPARE_SHOW_MODE;
highp float HSM_AB_COMPARE_AREA;
highp float HSM_AB_COMPARE_SPLIT_POSITION;
highp float HSM_AB_COMPARE_FREEZE_CRT_TUBE;
highp float HSM_AB_COMPARE_FREEZE_GRAPHICS;
highp float HSM_SHOW_PASS_INDEX;
highp float HSM_SHOW_PASS_APPLY_SCREEN_COORD;
highp float HSM_SHOW_PASS_ALPHA;
highp float HSM_SCREEN_VIGNETTE_DUALSCREEN_VIS_MODE;
highp float HSM_MONOCHROME_DUALSCREEN_VIS_MODE;
highp float HSM_TUBE_DIFFUSE_MODE;
highp float HSM_TUBE_DIFFUSE_IMAGE_AMOUNT;
highp float HSM_TUBE_DIFFUSE_IMAGE_DUALSCREEN_VIS_MODE;
highp float HSM_TUBE_DIFFUSE_IMAGE_COLORIZE_ON;
highp float HSM_TUBE_DIFFUSE_IMAGE_HUE;
highp float HSM_TUBE_DIFFUSE_IMAGE_SATURATION;
highp float HSM_TUBE_DIFFUSE_IMAGE_BRIGHTNESS;
highp float HSM_TUBE_DIFFUSE_IMAGE_GAMMA;
highp float HSM_TUBE_DIFFUSE_IMAGE_AMBIENT_LIGHTING;
highp float HSM_TUBE_DIFFUSE_IMAGE_AMBIENT2_LIGHTING;
highp float HSM_TUBE_DIFFUSE_IMAGE_SCALE;
highp float HSM_TUBE_DIFFUSE_IMAGE_SCALE_X;
highp float HSM_TUBE_DIFFUSE_IMAGE_ROTATION;
highp float HSM_TUBE_SHADOW_IMAGE_ON;
highp float HSM_TUBE_SHADOW_IMAGE_OPACITY;
highp float HSM_TUBE_SHADOW_IMAGE_POS_X;
highp float HSM_TUBE_SHADOW_IMAGE_POS_Y;
highp float HSM_TUBE_SHADOW_IMAGE_SCALE_X;
highp float HSM_TUBE_SHADOW_IMAGE_SCALE_Y;
highp float HSM_TUBE_SHADOW_CURVATURE_SCALE;
highp float HSM_TUBE_STATIC_REFLECTION_IMAGE_ON;
highp float HSM_TUBE_STATIC_REFLECTION_IMAGE_DUALSCREEN_VIS_MODE;
highp float HSM_TUBE_STATIC_REFLECTION_IMAGE_OPACITY;
highp float HSM_TUBE_STATIC_OPACITY_DIFFUSE_MULTIPLY;
highp float HSM_TUBE_STATIC_BLACK_LEVEL;
highp float HSM_TUBE_STATIC_AMBIENT_LIGHTING;
highp float HSM_TUBE_STATIC_AMBIENT2_LIGHTING;
highp float HSM_TUBE_STATIC_SCALE;
highp float HSM_TUBE_STATIC_SCALE_X;
highp float HSM_TUBE_STATIC_POS_X;
highp float HSM_TUBE_STATIC_POS_Y;
highp float HSM_TUBE_STATIC_SHADOW_OPACITY;
highp float HSM_TUBE_STATIC_DITHER_SAMPLES;
highp float HSM_TUBE_STATIC_DITHER_DISTANCE;
highp float HSM_TUBE_STATIC_DITHER_AMOUNT;
highp float HSM_TUBE_OPACITY;
highp float HSM_TUBE_COLORED_GEL_IMAGE_ON;
highp float HSM_TUBE_COLORED_GEL_IMAGE_SCALE;
highp float HSM_TUBE_COLORED_GEL_IMAGE_FLIP_HORIZONTAL;
highp float HSM_TUBE_COLORED_GEL_IMAGE_FLIP_VERTICAL;
highp float HSM_TUBE_COLORED_GEL_IMAGE_DUALSCREEN_VIS_MODE;
highp float HSM_TUBE_COLORED_GEL_IMAGE_MULTIPLY_AMOUNT;
highp float HSM_TUBE_COLORED_GEL_IMAGE_ADDITIVE_AMOUNT;
highp float HSM_TUBE_COLORED_GEL_IMAGE_NORMAL_AMOUNT;
highp float HSM_TUBE_COLORED_GEL_IMAGE_TRANSPARENCY_THRESHOLD;
highp float HSM_TUBE_COLORED_GEL_IMAGE_NORMAL_BRIGHTNESS;
highp float HSM_TUBE_COLORED_GEL_IMAGE_NORMAL_VIGNETTE;
highp float HSM_TUBE_COLORED_GEL_IMAGE_FAKE_SCANLINE_AMOUNT;
highp float HSM_TUBE_COLORED_GEL_IMAGE_AMBIENT_LIGHTING;
highp float HSM_TUBE_COLORED_GEL_IMAGE_AMBIENT2_LIGHTING;
highp float HSM_SHOW_CRT_ON_TOP_OF_COLORED_GEL;
highp float HSM_DUALSCREEN_MODE;
highp float HSM_DUALSCREEN_CORE_IMAGE_SPLIT_MODE;
highp float HSM_DUALSCREEN_CORE_IMAGE_SWAP_SCREENS;
highp float HSM_DUALSCREEN_CORE_IMAGE_SPLIT_OFFSET;
highp float HSM_DUALSCREEN_VIEWPORT_SPLIT_LOCATION;
highp float HSM_DUALSCREEN_SHIFT_POSITION_WITH_SCALE;
highp float HSM_DUALSCREEN_POSITION_OFFSET_BETWEEN_SCREENS;
highp float HSM_2ND_SCREEN_ASPECT_RATIO_MODE;
highp float HSM_2ND_SCREEN_INDEPENDENT_SCALE;
highp float HSM_2ND_SCREEN_SCALE_OFFSET;
highp float HSM_2ND_SCREEN_POS_X;
highp float HSM_2ND_SCREEN_POS_Y;
highp float HSM_2ND_SCREEN_CROP_PERCENT_ZOOM;
highp float HSM_2ND_SCREEN_CROP_PERCENT_TOP;
highp float HSM_2ND_SCREEN_CROP_PERCENT_BOTTOM;
highp float HSM_2ND_SCREEN_CROP_PERCENT_LEFT;
highp float HSM_2ND_SCREEN_CROP_PERCENT_RIGHT;
highp float HSM_SCREEN_REFLECTION_SCALE;
highp float HSM_SCREEN_REFLECTION_POS_X;
highp float HSM_SCREEN_REFLECTION_POS_Y;
highp float HSM_AMBIENT1_HUE;
highp float HSM_AMBIENT1_SATURATION;
highp float HSM_AMBIENT1_VALUE;
highp float HSM_AMBIENT1_CONTRAST;
highp float HSM_AMBIENT1_SCALE_KEEP_ASPECT;
highp float HSM_AMBIENT1_SCALE_INHERIT_MODE;
highp float HSM_AMBIENT1_SCALE;
highp float HSM_AMBIENT1_SCALE_X;
highp float HSM_AMBIENT1_ROTATE;
highp float HSM_AMBIENT1_MIRROR_HORZ;
highp float HSM_AMBIENT1_POS_INHERIT_MODE;
highp float HSM_AMBIENT1_POSITION_X;
highp float HSM_AMBIENT1_POSITION_Y;
highp float HSM_AMBIENT1_DITHERING_SAMPLES;
highp float HSM_AMBIENT2_HUE;
highp float HSM_AMBIENT2_SATURATION;
highp float HSM_AMBIENT2_VALUE;
highp float HSM_AMBIENT2_CONTRAST;
highp float HSM_AMBIENT2_SCALE_KEEP_ASPECT;
highp float HSM_AMBIENT2_SCALE_INHERIT_MODE;
highp float HSM_AMBIENT2_SCALE;
highp float HSM_AMBIENT2_SCALE_X;
highp float HSM_AMBIENT2_ROTATE;
highp float HSM_AMBIENT2_MIRROR_HORZ;
highp float HSM_AMBIENT2_POS_INHERIT_MODE;
highp float HSM_AMBIENT2_POSITION_X;
highp float HSM_AMBIENT2_POSITION_Y;
highp float HSM_BZL_OPACITY;
highp float HSM_BZL_BLEND_MODE;
highp float HSM_BZL_WIDTH;
highp float HSM_BZL_HEIGHT;
highp float HSM_BZL_INNER_CORNER_RADIUS_SCALE;
highp float SOURCE_MATTE_PREMULTIPLIED;
highp float SOURCE_MATTE_WHITE;
highp float SOURCE_MATTE_NONE;
highp float BLEND_MODE_OFF;
highp float BLEND_MODE_NORMAL;
highp float BLEND_MODE_ADD;
highp float BLEND_MODE_MULTIPLY;
highp float CURVATURE_MODE_OFF;
highp float CURVATURE_MODE_2D;
highp float CURVATURE_MODE_2D_CYLINDER;
highp float CURVATURE_MODE_3D_1;
highp float CURVATURE_MODE_3D_2;
highp float CURVATURE_MODE_3D_CYLINDER;

highp vec2 HSM_GetViewportCoordWithFlip(highp vec2 viewport_coord)
{
    highp vec2 out_coord = viewport_coord;
    if (HSM_FLIP_VIEWPORT_VERTICAL == (-1.0))
    {
        out_coord.y = 1.0 - out_coord.y;
    }
    if (HSM_FLIP_VIEWPORT_HORIZONTAL == (-1.0))
    {
        out_coord.x = 1.0 - out_coord.x;
    }
    return out_coord;
}

highp vec2 HSM_GetViewportCoordWithZoomAndPan(highp vec2 viewport_coord)
{
    highp vec2 param = viewport_coord;
    highp vec2 out_coord = HSM_GetViewportCoordWithFlip(param);
    out_coord = ((out_coord - vec2(0.5)) / vec2(HSM_VIEWPORT_ZOOM)) + vec2(0.5);
    out_coord.x += HSM_VIEWPORT_POSITION_X;
    out_coord.y -= HSM_VIEWPORT_POSITION_Y;
    return out_coord;
}

highp float HSM_GetScreenIndex(highp vec2 viewport_coord)
{
    highp float out_index = 1.0;
    highp float output_aspect = global.FinalViewportSize.x / global.FinalViewportSize.y;
    if (HSM_DUALSCREEN_MODE == 0.0)
    {
        out_index = 1.0;
    }
    if (HSM_DUALSCREEN_MODE == 1.0)
    {
        out_index = float((viewport_coord.y < (0.5 + (HSM_DUALSCREEN_VIEWPORT_SPLIT_LOCATION / output_aspect))) ? 1 : 2);
    }
    if (HSM_DUALSCREEN_MODE == 2.0)
    {
        out_index = float((viewport_coord.x < (0.5 + (HSM_DUALSCREEN_VIEWPORT_SPLIT_LOCATION / output_aspect))) ? 1 : 2);
    }
    return out_index;
}

highp vec4 HSM_GetCacheSampleRange(highp float column_index, highp float row_index)
{
    highp float num_rows = 8.0;
    highp float num_columns = 8.0;
    highp float range_width = 1.0 / num_columns;
    highp float range_height = 1.0 / num_rows;
    highp float zero_based_row_index = row_index - 1.0;
    highp float zero_based_column_index = column_index - 1.0;
    highp vec4 out_sample_range = vec4(0.0);
    out_sample_range.x = zero_based_column_index * range_width;
    out_sample_range.y = zero_based_row_index * range_height;
    out_sample_range.z = out_sample_range.x + range_width;
    out_sample_range.w = out_sample_range.y + range_height;
    return out_sample_range;
}

highp vec2 HSM_GetCacheSampleCoord(highp float column_index, highp float row_index)
{
    highp float num_rows = 8.0;
    highp float num_columns = 8.0;
    highp float range_width = 1.0 / num_columns;
    highp float range_height = 1.0 / num_rows;
    highp float param = column_index;
    highp float param_1 = row_index;
    highp vec4 sample_range = HSM_GetCacheSampleRange(param, param_1);
    return vec2(sample_range.x + (range_width / 2.0), sample_range.y + (range_height / 2.0));
}

highp vec2 HSM_GetCoordWithPositionOffset(highp vec2 in_coord, highp vec2 position_offset)
{
    return in_coord - position_offset;
}

highp vec2 HSM_GetInverseScaledCoord(highp vec2 in_coord, highp vec2 in_scale)
{
    highp vec2 middle = vec2(0.499989986419677734375);
    highp vec2 diff = in_coord - middle;
    highp vec2 screen_inverse_scale = vec2(1.0) / in_scale;
    highp vec2 scaled_coord = middle + (diff * screen_inverse_scale);
    return scaled_coord;
}

highp vec2 HSM_GetVTexCoordWithArgs(highp vec2 in_coord, highp vec2 in_scale, highp vec2 position_offset)
{
    highp vec2 param = in_coord;
    highp vec2 param_1 = position_offset;
    highp vec2 param_2 = HSM_GetCoordWithPositionOffset(param, param_1);
    highp vec2 param_3 = in_scale;
    return HSM_GetInverseScaledCoord(param_2, param_3);
}

highp vec4 HSM_UpdateGlobalScreenValuesFromCache(highp sampler2D in_cache_pass, highp vec2 vTexCoord_1)
{
    highp float output_aspect = global.FinalViewportSize.x / global.FinalViewportSize.y;
    highp vec2 param = vTexCoord_1;
    highp vec2 flipped_viewport_coord = HSM_GetViewportCoordWithZoomAndPan(param);
    highp vec2 param_1 = flipped_viewport_coord;
    SCREEN_INDEX = HSM_GetScreenIndex(param_1);
    highp vec2 sample_coord = vec2(0.0);
    highp vec4 texture_sample = vec4(0.0);
    highp float param_2 = 1.0;
    highp float param_3 = 1.0;
    sample_coord = HSM_GetCacheSampleCoord(param_2, param_3);
    texture_sample = texture(in_cache_pass, sample_coord);
    AVERAGE_LUMA = texture_sample.w;
    SAMPLING_SCANLINE_DIR_MULT = texture_sample.x;
    SAMPLING_OPPOSITE_DIR_MULT = texture_sample.y;
    highp float res_mult_size_sum = 0.0;
    highp float res_mult_size2_sum = 0.0;
    if (SCREEN_INDEX == 1.0)
    {
        highp float param_4 = 2.0;
        highp float param_5 = 1.0;
        sample_coord = HSM_GetCacheSampleCoord(param_4, param_5);
        texture_sample = texture(in_cache_pass, sample_coord);
        SCREEN_ASPECT = texture_sample.x;
        SCREEN_SCALE = texture_sample.zw;
        highp float param_6 = 3.0;
        highp float param_7 = 1.0;
        sample_coord = HSM_GetCacheSampleCoord(param_6, param_7);
        texture_sample = texture(in_cache_pass, sample_coord);
        TUBE_SCALE = texture_sample.xy;
        SCREEN_POS_OFFSET = texture_sample.zw;
        highp float param_8 = 3.0;
        highp float param_9 = 4.0;
        sample_coord = HSM_GetCacheSampleCoord(param_8, param_9);
        texture_sample = texture(in_cache_pass, sample_coord);
        TUBE_DIFFUSE_SCALE = texture_sample.xy;
        TUBE_DIFFUSE_ASPECT = (TUBE_DIFFUSE_SCALE.x / TUBE_DIFFUSE_SCALE.y) * output_aspect;
        highp float param_10 = 4.0;
        highp float param_11 = 1.0;
        sample_coord = HSM_GetCacheSampleCoord(param_10, param_11);
        texture_sample = texture(in_cache_pass, sample_coord);
        CROPPED_ROTATED_SIZE_WITH_RES_MULT = texture_sample.xy;
        res_mult_size_sum = CROPPED_ROTATED_SIZE_WITH_RES_MULT.x + CROPPED_ROTATED_SIZE_WITH_RES_MULT.y;
        ROTATED_CORE_PREPPED_SIZE = texture_sample.zw;
        highp float param_12 = 1.0;
        highp float param_13 = 2.0;
        sample_coord = HSM_GetCacheSampleCoord(param_12, param_13);
        texture_sample = texture(in_cache_pass, sample_coord);
        CROPPED_ROTATED_SIZE = texture_sample.xy;
        SAMPLE_AREA_START_PIXEL_COORD = texture_sample.zw;
        highp float param_14 = 4.0;
        highp float param_15 = 4.0;
        sample_coord = HSM_GetCacheSampleCoord(param_14, param_15);
        texture_sample = texture(in_cache_pass, sample_coord);
        SCREEN_SIZE = texture_sample.xy;
    }
    if (SCREEN_INDEX == 2.0)
    {
        highp float param_16 = 2.0;
        highp float param_17 = 2.0;
        sample_coord = HSM_GetCacheSampleCoord(param_16, param_17);
        texture_sample = texture(in_cache_pass, sample_coord);
        SCREEN_ASPECT = texture_sample.x;
        SCREEN_SCALE = texture_sample.yz;
        highp float param_18 = 3.0;
        highp float param_19 = 2.0;
        sample_coord = HSM_GetCacheSampleCoord(param_18, param_19);
        texture_sample = texture(in_cache_pass, sample_coord);
        TUBE_SCALE = texture_sample.xy;
        SCREEN_POS_OFFSET = texture_sample.zw;
        highp float param_20 = 3.0;
        highp float param_21 = 4.0;
        sample_coord = HSM_GetCacheSampleCoord(param_20, param_21);
        texture_sample = texture(in_cache_pass, sample_coord);
        TUBE_DIFFUSE_SCALE = texture_sample.zw;
        TUBE_DIFFUSE_ASPECT = (TUBE_DIFFUSE_SCALE.x / TUBE_DIFFUSE_SCALE.y) * output_aspect;
        highp float param_22 = 4.0;
        highp float param_23 = 2.0;
        sample_coord = HSM_GetCacheSampleCoord(param_22, param_23);
        texture_sample = texture(in_cache_pass, sample_coord);
        CROPPED_ROTATED_SIZE_WITH_RES_MULT = texture_sample.xy;
        res_mult_size2_sum = CROPPED_ROTATED_SIZE_WITH_RES_MULT.x + CROPPED_ROTATED_SIZE_WITH_RES_MULT.y;
        highp float param_24 = 1.0;
        highp float param_25 = 3.0;
        sample_coord = HSM_GetCacheSampleCoord(param_24, param_25);
        texture_sample = texture(in_cache_pass, sample_coord);
        CROPPED_ROTATED_SIZE = texture_sample.xy;
        SAMPLE_AREA_START_PIXEL_COORD = texture_sample.zw;
        highp float param_26 = 4.0;
        highp float param_27 = 4.0;
        sample_coord = HSM_GetCacheSampleCoord(param_26, param_27);
        texture_sample = texture(in_cache_pass, sample_coord);
        SCREEN_SIZE = texture_sample.zw;
    }
    highp float param_28 = 3.0;
    highp float param_29 = 1.0;
    sample_coord = HSM_GetCacheSampleCoord(param_28, param_29);
    texture_sample = texture(in_cache_pass, sample_coord);
    SCREEN_POS_OFFSET_1ST_SCREEN = texture_sample.zw;
    highp float param_30 = 3.0;
    highp float param_31 = 4.0;
    sample_coord = HSM_GetCacheSampleCoord(param_30, param_31);
    texture_sample = texture(in_cache_pass, sample_coord);
    TUBE_DIFFUSE_SCALE_1ST_SCREEN = texture_sample.xy;
    highp float param_32 = 3.0;
    highp float param_33 = 2.0;
    sample_coord = HSM_GetCacheSampleCoord(param_32, param_33);
    texture_sample = texture(in_cache_pass, sample_coord);
    SCREEN_POS_OFFSET_2ND_SCREEN = texture_sample.zw;
    highp float param_34 = 3.0;
    highp float param_35 = 4.0;
    sample_coord = HSM_GetCacheSampleCoord(param_34, param_35);
    texture_sample = texture(in_cache_pass, sample_coord);
    TUBE_DIFFUSE_SCALE_2ND_SCREEN = texture_sample.zw;
    highp float param_36 = 2.0;
    highp float param_37 = 3.0;
    sample_coord = HSM_GetCacheSampleCoord(param_36, param_37);
    texture_sample = texture(in_cache_pass, sample_coord);
    CORE_SIZE = texture_sample.xy;
    ROTATED_CORE_ORIGINAL_SIZE = texture_sample.zw;
    highp float param_38 = 3.0;
    highp float param_39 = 3.0;
    sample_coord = HSM_GetCacheSampleCoord(param_38, param_39);
    texture_sample = texture(in_cache_pass, sample_coord);
    VIEWPORT_SCALE = texture_sample.xy;
    VIEWPORT_POS = texture_sample.zw;
    highp float param_40 = 4.0;
    highp float param_41 = 3.0;
    sample_coord = HSM_GetCacheSampleCoord(param_40, param_41);
    texture_sample = texture(in_cache_pass, sample_coord);
    SCREEN_SCALE_2ND_SCREEN = texture_sample.xy;
    SCREEN_POS_OFFSET_2ND_SCREEN = texture_sample.zw;
    highp float param_42 = 1.0;
    highp float param_43 = 4.0;
    sample_coord = HSM_GetCacheSampleCoord(param_42, param_43);
    texture_sample = texture(in_cache_pass, sample_coord);
    CURRENT_FRAME_FROM_CACHE_INFO = texture_sample.y;
    ROTATED_DEREZED_SIZE = texture_sample.zw;
    highp float param_44 = 2.0;
    highp float param_45 = 4.0;
    sample_coord = HSM_GetCacheSampleCoord(param_44, param_45);
    texture_sample = texture(in_cache_pass, sample_coord);
    NEGATIVE_CROP_EXPAND_MULTIPLIER = texture_sample.x;
    MAX_NEGATIVE_CROP = texture_sample.y;
    USE_VERTICAL_SCANLINES = texture_sample.z;
    highp float param_46 = 8.0;
    highp float param_47 = 8.0;
    sample_coord = HSM_GetCacheSampleCoord(param_46, param_47);
    texture_sample = texture(in_cache_pass, sample_coord);
    CACHE_INFO_CHANGED = (texture_sample.x > 0.5) ? true : false;
    SCREEN_SCALE_WITH_ZOOM = SCREEN_SCALE * HSM_VIEWPORT_ZOOM;
    highp vec2 param_48 = flipped_viewport_coord;
    highp vec2 param_49 = SCREEN_SCALE;
    highp vec2 param_50 = SCREEN_POS_OFFSET;
    SCREEN_COORD = HSM_GetVTexCoordWithArgs(param_48, param_49, param_50);
    highp vec2 param_51 = flipped_viewport_coord;
    highp vec2 param_52 = TUBE_DIFFUSE_SCALE;
    highp vec2 param_53 = SCREEN_POS_OFFSET;
    TUBE_DIFFUSE_COORD = HSM_GetVTexCoordWithArgs(param_51, param_52, param_53);
    highp vec2 param_54 = flipped_viewport_coord;
    highp vec2 param_55 = TUBE_DIFFUSE_SCALE_1ST_SCREEN;
    highp vec2 param_56 = (SCREEN_POS_OFFSET_1ST_SCREEN + SCREEN_POS_OFFSET_2ND_SCREEN) / vec2(2.0);
    TUBE_DIFFUSE_COORD_MIXED_POS = HSM_GetVTexCoordWithArgs(param_54, param_55, param_56);
    return vec4(0.0);
}

bool HHLP_IsOutsideCoordSpace(highp vec2 in_coord)
{
    bool _1174 = abs(in_coord.x - 0.5) > 0.500999987125396728515625;
    bool _1184;
    if (!_1174)
    {
        _1184 = abs(in_coord.y - 0.5) > 0.500999987125396728515625;
    }
    else
    {
        _1184 = _1174;
    }
    return _1184;
}

highp vec2 HSM_GetCurvatureValues(highp float screen_aspect)
{
    highp vec2 _1784;
    if (screen_aspect < 1.0)
    {
        _1784 = vec2((((2.0 * global.HSM_CURVATURE_2D_SCALE_SHORT_AXIS) / 100.0) * 2.0) / 100.0, ((global.HSM_CURVATURE_2D_SCALE_LONG_AXIS / 100.0) * 3.0) / 100.0);
    }
    else
    {
        _1784 = vec2(((global.HSM_CURVATURE_2D_SCALE_LONG_AXIS / 100.0) * 3.0) / 100.0, (((2.0 * global.HSM_CURVATURE_2D_SCALE_SHORT_AXIS) / 100.0) * 2.0) / 100.0);
    }
    highp vec2 curvature_values = _1784;
    return curvature_values;
}

highp vec2 HSM_GetCrtPiCurvedCoord(inout highp vec2 in_coord, inout highp vec2 in_curvature)
{
    in_curvature *= 5.0;
    highp vec2 barrelScale = vec2(1.0) - (in_curvature * 0.23000000417232513427734375);
    in_coord -= vec2(0.5);
    highp float _1836;
    if (HSM_CURVATURE_MODE == 2.0)
    {
        _1836 = 0.0;
    }
    else
    {
        _1836 = in_coord.y * in_coord.y;
    }
    highp float rsq = (in_coord.x * in_coord.x) + _1836;
    in_coord += (in_coord * (in_curvature * rsq));
    in_coord *= barrelScale;
    in_coord += vec2(0.5);
    return in_coord;
}

highp vec2 HSM_Get2DCurvedCoord(highp vec2 in_coord, highp vec2 curvature_values)
{
    highp vec2 ctr_curved_coord = vec2(0.0);
    highp vec2 param = in_coord;
    highp vec2 param_1 = curvature_values;
    highp vec2 _1867 = HSM_GetCrtPiCurvedCoord(param, param_1);
    ctr_curved_coord = _1867 - vec2(0.5);
    highp vec2 param_2 = vec2(1.0, 0.5);
    highp vec2 param_3 = curvature_values;
    highp vec2 _1875 = HSM_GetCrtPiCurvedCoord(param_2, param_3);
    highp vec2 right_edge_curved_ctr_coord = _1875 - vec2(0.5);
    ctr_curved_coord.x = (ctr_curved_coord.x * 0.5) / right_edge_curved_ctr_coord.x;
    highp vec2 param_4 = vec2(0.5, 1.0);
    highp vec2 param_5 = curvature_values;
    highp vec2 _1890 = HSM_GetCrtPiCurvedCoord(param_4, param_5);
    highp vec2 bottom_edge_curved_ctr_coord = _1890 - vec2(0.5);
    ctr_curved_coord.y = (ctr_curved_coord.y * 0.5) / bottom_edge_curved_ctr_coord.y;
    return ctr_curved_coord + vec2(0.5);
}

highp vec2 HSM_GetCurvedCoord(highp vec2 in_coord, highp float curvature_multiplier, highp float screen_aspect)
{
    if (HSM_CURVATURE_MODE == CURVATURE_MODE_OFF)
    {
        return in_coord;
    }
    highp float epsilon = 0.00200000009499490261077880859375;
    highp vec2 adjusted_coord = in_coord;
    highp float tilt_angle_y = HSM_CURVATURE_3D_TILT_ANGLE_Y;
    highp float tilt_angle_x = HSM_CURVATURE_3D_TILT_ANGLE_X;
    highp float pin_inner_edge = 0.0;
    highp vec2 curved_coord = vec2(0.0);
    highp float param = screen_aspect;
    highp vec2 curvature_values = HSM_GetCurvatureValues(param) * curvature_multiplier;
    highp vec2 param_1 = adjusted_coord;
    highp vec2 param_2 = curvature_values;
    curved_coord = HSM_Get2DCurvedCoord(param_1, param_2);
    return curved_coord;
}

highp vec2 HSM_GetCRTShaderCurvedCoord(highp vec2 in_coord)
{
    highp vec2 param = in_coord;
    highp float param_1 = 1.0;
    highp float param_2 = SCREEN_ASPECT;
    highp vec2 out_coord = HSM_GetCurvedCoord(param, param_1, param_2);
    highp vec2 param_3 = out_coord;
    if (HHLP_IsOutsideCoordSpace(param_3))
    {
        highp vec2 tube_scale_ratio = TUBE_SCALE / SCREEN_SCALE;
        out_coord = ((out_coord - vec2(0.5)) / tube_scale_ratio) + vec2(0.5);
    }
    else
    {
        if (HSM_CRT_CURVATURE_SCALE < 100.0)
        {
            highp vec2 param_4 = in_coord;
            highp float param_5 = HSM_CRT_CURVATURE_SCALE;
            highp float param_6 = SCREEN_ASPECT;
            out_coord = HSM_GetCurvedCoord(param_4, param_5, param_6);
        }
    }
    return out_coord;
}

highp vec2 HSM_GetMirrorWrappedCoord(inout highp vec2 in_coord)
{
    highp vec2 ctr_coord = in_coord - vec2(0.5);
    bool _1981 = abs(ctr_coord.x) > 0.5;
    bool _1989;
    if (!_1981)
    {
        _1989 = abs(ctr_coord.y) > 0.5;
    }
    else
    {
        _1989 = _1981;
    }
    if (_1989)
    {
        in_coord = ((ctr_coord / vec2(HSM_SCREEN_REFLECTION_SCALE)) + vec2(0.5)) + vec2(HSM_SCREEN_REFLECTION_POS_X, HSM_SCREEN_REFLECTION_POS_Y);
    }
    in_coord = mod(in_coord, vec2(2.0));
    highp vec2 ctr_mirror_coord = in_coord - vec2(0.5);
    highp float mirror_x = clamp(clamp(abs(ctr_mirror_coord.x) - 0.5, 0.0, 1.0) * 100000.0, 0.0, 1.0);
    highp float mirror_y = clamp(clamp(abs(ctr_mirror_coord.y) - 0.5, 0.0, 1.0) * 100000.0, 0.0, 1.0);
    ctr_mirror_coord.x -= (((mirror_x * 2.0) * sign(ctr_mirror_coord.x)) * (abs(ctr_mirror_coord.x) - 0.5));
    ctr_mirror_coord.y -= (((mirror_y * 2.0) * sign(ctr_mirror_coord.y)) * (abs(ctr_mirror_coord.y) - 0.5));
    return ctr_mirror_coord + vec2(0.5);
}

highp vec2 HSM_ApplyOverscan(highp vec2 in_coord, highp float overscan_x, highp float overscan_y)
{
    highp vec2 ctr_coord = (in_coord * 2.0) - vec2(1.0);
    ctr_coord /= (vec2(overscan_x, overscan_y) + vec2(1.0));
    return (ctr_coord * 0.5) + vec2(0.5);
}

highp float HSM_GetRasterBloomScale(highp float raster_bloom_overscan_mode, highp float raster_bloom_mult, highp float screen_avg_luma)
{
    return (1.0 + (((1.0 - (0.5 * raster_bloom_overscan_mode)) * raster_bloom_mult) / 100.0)) - ((screen_avg_luma * raster_bloom_mult) / 100.0);
}

highp vec2 HSM_ApplyRasterBloomOverscan(highp vec2 in_coord, highp float raster_bloom_overscan_mode, highp float raster_bloom_mult, highp float screen_avg_luma)
{
    highp vec2 ctr_coord = (in_coord * 2.0) - vec2(1.0);
    highp float param = raster_bloom_overscan_mode;
    highp float param_1 = raster_bloom_mult;
    highp float param_2 = screen_avg_luma;
    highp float raster_bloom_factor = HSM_GetRasterBloomScale(param, param_1, param_2);
    ctr_coord *= vec2(raster_bloom_factor, raster_bloom_factor);
    return (ctr_coord * 0.5) + vec2(0.5);
}

highp vec2 HSM_GetCrtShaderFinalCoord(highp vec2 screen_coord, highp vec2 screen_scale, highp float raster_bloom_avg_lum, inout highp vec2 screen_curved_coord)
{
    highp vec2 param = screen_coord;
    screen_curved_coord = HSM_GetCRTShaderCurvedCoord(param);
    highp vec2 param_1 = screen_curved_coord;
    highp vec2 _2171 = HSM_GetMirrorWrappedCoord(param_1);
    highp vec2 screen_curved_coord_with_overscan_and_mirror = _2171;
    highp vec2 param_2 = screen_curved_coord_with_overscan_and_mirror;
    highp float param_3 = (global.HSM_OVERSCAN_AMOUNT / 100.0) + (global.HSM_OVERSCAN_X / 100.0);
    highp float param_4 = (global.HSM_OVERSCAN_AMOUNT / 100.0) + (global.HSM_OVERSCAN_Y / 100.0);
    screen_curved_coord_with_overscan_and_mirror = HSM_ApplyOverscan(param_2, param_3, param_4);
    if (global.HSM_OVERSCAN_RASTER_BLOOM_ON > 0.5)
    {
        highp vec2 param_5 = screen_curved_coord_with_overscan_and_mirror;
        highp float param_6 = global.HSM_OVERSCAN_RASTER_BLOOM_MODE;
        highp float param_7 = global.HSM_OVERSCAN_RASTER_BLOOM_AMOUNT;
        highp float param_8 = raster_bloom_avg_lum;
        screen_curved_coord_with_overscan_and_mirror = HSM_ApplyRasterBloomOverscan(param_5, param_6, param_7, param_8);
    }
    return screen_curved_coord_with_overscan_and_mirror;
}

highp vec2 HSM_GetRotatedDerezedSize()
{
    return (global.DerezedPassSize.yx * abs(HSM_ROTATE_CORE_IMAGE)) + (global.DerezedPassSize.xy * (1.0 - abs(HSM_ROTATE_CORE_IMAGE)));
}

highp vec2 HSM_RotateCoordinate(highp vec2 in_coord, highp float rotation)
{
    if (rotation == 0.0)
    {
        return in_coord;
    }
    highp float abs_rotation = abs(rotation);
    highp vec2 ctr_coord = in_coord - vec2(0.5);
    ctr_coord = ((ctr_coord * (1.0 - abs_rotation)) + (vec2(-ctr_coord.y, ctr_coord.x) * (clamp(abs_rotation, 0.0, 1.0) * abs_rotation))) + (vec2(ctr_coord.y, -ctr_coord.x) * (abs(clamp(abs_rotation, -1.0, 0.0)) * abs_rotation));
    if (rotation < 0.0)
    {
        ctr_coord *= (-1.0);
    }
    return ctr_coord + vec2(0.5);
}

highp vec4 HSM_GetTexSampleFromSampleStartAndSize(highp sampler2D in_sampler, inout highp vec2 in_screen_coord, highp vec2 sample_start_pixel_coord, highp vec2 window_size)
{
    highp vec2 core_prepped_size = HSM_GetRotatedDerezedSize();
    if (HSM_DUALSCREEN_MODE > 0.0)
    {
        if (HSM_FLIP_CORE_VERTICAL == (-1.0))
        {
            in_screen_coord.y = 1.0 - in_screen_coord.y;
        }
    }
    highp vec2 px_coord = SAMPLE_AREA_START_PIXEL_COORD + (in_screen_coord * window_size);
    highp vec2 sample_coord = px_coord / core_prepped_size;
    highp vec2 param = sample_coord;
    highp float param_1 = HSM_ROTATE_CORE_IMAGE;
    sample_coord = HSM_RotateCoordinate(param, param_1);
    highp vec4 out_color = texture(in_sampler, sample_coord);
    return out_color;
}

highp vec4 HSM_GetCroppedTexSample(highp sampler2D in_sampler, highp vec2 in_screen_coord)
{
    highp vec2 param = in_screen_coord;
    highp vec2 param_1 = SAMPLE_AREA_START_PIXEL_COORD;
    highp vec2 param_2 = CROPPED_ROTATED_SIZE;
    highp vec4 _2106 = HSM_GetTexSampleFromSampleStartAndSize(in_sampler, param, param_1, param_2);
    return _2106;
}

highp float HSM_GetCornerMask(highp vec2 in_coord, highp float screen_aspect, highp float corner_radius, highp float edge_sharpness)
{
    highp vec2 new_coord = min(in_coord, vec2(1.0) - in_coord) * vec2(screen_aspect, 1.0);
    highp vec2 corner_distance = vec2(max(corner_radius / 1000.0, (1.0 - edge_sharpness) * 0.00999999977648258209228515625));
    new_coord = corner_distance - min(new_coord, corner_distance);
    highp float _distance = sqrt(dot(new_coord, new_coord));
    return clamp((corner_distance.x - _distance) * ((edge_sharpness * 500.0) + 100.0), 0.0, 1.0);
}

highp float HSM_GetAutoScaledMaskSize(highp float in_masksize)
{
    highp float final_mask_size = in_masksize;
    if (global.masksize < 0.5)
    {
        final_mask_size = float((min(global.FinalViewportSize.x, global.FinalViewportSize.y) > global.masksizeautothreshold) ? 2 : 1);
    }
    final_mask_size = max(1.0, floor((((1.0 - HSM_VIEWPORT_ZOOM_MASK) + (HSM_VIEWPORT_ZOOM_MASK * VIEWPORT_SCALE.y)) * final_mask_size) + 0.20000000298023223876953125));
    return final_mask_size;
}

void fetch_pixel(inout highp vec3 c, inout highp vec3 b, highp vec2 coord, highp vec2 bcoord)
{
    highp float stepx = 0.5;
    highp float stepy = 0.5;
    if (global.dcscalemode < 1.5)
    {
        stepx = (0.000925925909541547298431396484375 * global.OutputSize.y) / global.OutputSize.x;
        stepy = 0.000925925909541547298431396484375;
    }
    if (global.dcscalemode == 0.0)
    {
        stepx *= (SCREEN_SCALE_WITH_ZOOM.y / 0.829699993133544921875);
        stepy *= (SCREEN_SCALE_WITH_ZOOM.y / 0.829699993133544921875);
    }
    if (global.dcscalemode > 1.5)
    {
        stepx = global.OutputSize.z;
        stepy = global.OutputSize.w;
        if (global.dcscalemode == 3.0)
        {
            highp float param = global.masksize;
            highp float scaled_mask_size = HSM_GetAutoScaledMaskSize(param);
            stepx *= scaled_mask_size;
            stepy *= scaled_mask_size;
        }
    }
    highp float ds = global.decons;
    highp vec2 dx = vec2(stepx, 0.0);
    highp vec2 dy = vec2(0.0, stepy);
    highp float posx = (2.0 * coord.x) - 1.0;
    highp float posy = (2.0 * coord.y) - 1.0;
    if (global.dctypex > 0.02500000037252902984619140625)
    {
        posx = sign(posx) * pow(abs(posx), 1.0499999523162841796875 - global.dctypex);
        dx *= posx;
    }
    if (global.dctypey > 0.02500000037252902984619140625)
    {
        posy = sign(posy) * pow(abs(posy), 1.0499999523162841796875 - global.dctypey);
        dy *= posy;
    }
    highp vec2 rc = (dx * global.deconrr) + (dy * global.deconrry);
    highp vec2 gc = (dx * global.deconrg) + (dy * global.deconrgy);
    highp vec2 bc = (dx * global.deconrb) + (dy * global.deconrby);
    highp float r1 = texture(Source, coord + rc).x;
    highp float g1 = texture(Source, coord + gc).y;
    highp float b1 = texture(Source, coord + bc).z;
    highp vec3 d = vec3(r1, g1, b1);
    c = clamp(mix(c, d, vec3(ds)), vec3(0.0), vec3(1.0));
    highp vec2 param_1 = bcoord + rc;
    r1 = HSM_GetCroppedTexSample(BloomPass, param_1).x;
    highp vec2 param_2 = bcoord + gc;
    g1 = HSM_GetCroppedTexSample(BloomPass, param_2).y;
    highp vec2 param_3 = bcoord + bc;
    b1 = HSM_GetCroppedTexSample(BloomPass, param_3).z;
    d = vec3(r1, g1, b1);
    b = clamp(mix(b, d, vec3(ds)), vec3(0.0), vec3(1.0));
}

highp float igc(highp float mc)
{
    return pow(mc, global.gamma_c);
}

highp float SlotMask(inout highp vec2 pos, highp float m)
{
    if ((global.slotmask + global.slotmask1) == 0.0)
    {
        return 1.0;
    }
    else
    {
        highp float param = global.slotms;
        highp float final_mask_size = HSM_GetAutoScaledMaskSize(param);
        pos.y = floor(pos.y / final_mask_size);
        highp float mlen = global.slotwidth * 2.0;
        highp float px = floor(mod(pos.x, 0.999989986419677734375 * mlen));
        highp float py = floor((fract(pos.y / (2.0 * global.double_slot)) * 2.0) * global.double_slot);
        highp float slot_dark = mix(1.0 - global.slotmask1, 1.0 - global.slotmask, m);
        highp float slot = 1.0;
        bool _3472 = py == 0.0;
        bool _3479;
        if (_3472)
        {
            _3479 = px < global.slotwidth;
        }
        else
        {
            _3479 = _3472;
        }
        if (_3479)
        {
            slot = slot_dark;
        }
        else
        {
            bool _3487 = py == global.double_slot;
            bool _3494;
            if (_3487)
            {
                _3494 = px >= global.slotwidth;
            }
            else
            {
                _3494 = _3487;
            }
            if (_3494)
            {
                slot = slot_dark;
            }
        }
        return slot;
    }
}

highp vec3 Mask(inout highp vec2 pos, highp float mx, highp float mb, out highp float mask_average_luma)
{
    highp float param = global.masksize;
    highp float final_mask_size = HSM_GetAutoScaledMaskSize(param);
    highp vec2 pos0 = pos;
    pos.y = floor(pos.y / final_mask_size);
    highp float stagg_lvl = 1.0;
    bool _2271 = fract(abs(global.mshift)) > 0.25;
    bool _2279;
    if (_2271)
    {
        _2279 = abs(global.mshift) > 1.25;
    }
    else
    {
        _2279 = _2271;
    }
    if (_2279)
    {
        stagg_lvl = 2.0;
    }
    highp float next_line = float(fract(pos.y * 0.5) > 0.25);
    highp float _2293;
    if (global.mshift > (-0.25))
    {
        _2293 = pos0.x + (next_line * global.mshift);
    }
    else
    {
        _2293 = pos0.x + (pos.y * global.mshift);
    }
    pos0.x = _2293;
    pos = floor(pos0 / vec2(final_mask_size));
    highp vec3 mask = vec3(global.maskDark, global.maskDark, global.maskDark);
    highp vec3 mask_average = vec3(global.maskDark, global.maskDark, global.maskDark);
    highp vec3 one = vec3(1.0);
    highp float sm = 0.449999988079071044921875;
    bool _2343 = global.shadowMask == 8.0;
    bool _2351;
    if (!_2343)
    {
        _2351 = global.shadowMask == 11.0;
    }
    else
    {
        _2351 = _2343;
    }
    bool _2359;
    if (!_2351)
    {
        _2359 = global.shadowMask == 13.0;
    }
    else
    {
        _2359 = _2351;
    }
    if (_2359)
    {
        sm = 0.699999988079071044921875;
    }
    highp float dark_compensate = mix(max(clamp(mix(global.mcut, global.maskstr, mx), 0.0, 1.0) - sm, 0.0) + 1.0, 1.0, mx);
    highp float mc = 1.0 - max(global.maskstr, 0.0);
    if (global.shadowMask == (-1.0))
    {
        mask = vec3(1.0);
        mask_average = vec3(1.0);
        mask_average_luma = 1.0;
        return mask;
    }
    else
    {
        if (global.shadowMask == 0.0)
        {
            pos.x = fract(pos.x * 0.5);
            if (pos.x < 0.4900000095367431640625)
            {
                mask.x = 1.0;
                mask.y = mc;
                mask.z = 1.0;
            }
            else
            {
                mask.x = mc;
                mask.y = 1.0;
                mask.z = mc;
            }
            mask_average = ((vec3(2.0) + vec3(1.0, mc, 1.0)) + vec3(mc, 1.0, mc)) / vec3(5.0);
        }
        else
        {
            if (global.shadowMask == 1.0)
            {
                highp float line = global.maskLight;
                highp float odd = 0.0;
                if (fract(pos.x / 6.0) < 0.4900000095367431640625)
                {
                    odd = 1.0;
                }
                if (fract((pos.y + odd) / 2.0) < 0.4900000095367431640625)
                {
                    line = global.maskDark;
                }
                pos.x = floor(mod(pos.x, 3.0));
                if (pos.x < 0.5)
                {
                    mask.x = global.maskLight;
                }
                else
                {
                    if (pos.x < 1.5)
                    {
                        mask.y = global.maskLight;
                    }
                    else
                    {
                        mask.z = global.maskLight;
                    }
                }
                mask *= line;
                mask_average = ((vec3(global.maskLight, mask_average.y, mask_average.z) + vec3(mask_average.x, global.maskLight, mask_average.z)) + vec3(mask_average.x, mask_average.y, global.maskLight)) / vec3(3.0);
                mask_average *= (((global.maskDark * 2.0) + global.maskLight) / 3.0);
            }
            else
            {
                if (global.shadowMask == 2.0)
                {
                    pos.x = floor(mod(pos.x, 3.0));
                    if (pos.x < 0.5)
                    {
                        mask.x = global.maskLight;
                    }
                    else
                    {
                        if (pos.x < 1.5)
                        {
                            mask.y = global.maskLight;
                        }
                        else
                        {
                            mask.z = global.maskLight;
                        }
                    }
                    mask_average = (((vec3(0.0) + vec3(global.maskLight, mask_average.y, mask_average.z)) + vec3(mask_average.x, global.maskLight, mask_average.z)) + vec3(mask_average.x, mask_average.y, global.maskLight)) / vec3(4.0);
                }
                else
                {
                    if (global.shadowMask == 3.0)
                    {
                        pos.x += (pos.y * 3.0);
                        pos.x = fract(pos.x / 6.0);
                        if (pos.x < 0.300000011920928955078125)
                        {
                            mask.x = global.maskLight;
                        }
                        else
                        {
                            if (pos.x < 0.60000002384185791015625)
                            {
                                mask.y = global.maskLight;
                            }
                            else
                            {
                                mask.z = global.maskLight;
                            }
                        }
                        mask_average = (((vec3(1.0) + vec3(global.maskLight, mask_average.y, mask_average.z)) + vec3(mask_average.x, global.maskLight, mask_average.z)) + vec3(mask_average.x, mask_average.y, global.maskLight)) / vec3(5.0);
                    }
                    else
                    {
                        if (global.shadowMask == 4.0)
                        {
                            pos = floor(pos * vec2(1.0, 0.5));
                            pos.x += (pos.y * 3.0);
                            pos.x = fract(pos.x / 6.0);
                            if (pos.x < 0.300000011920928955078125)
                            {
                                mask.x = global.maskLight;
                            }
                            else
                            {
                                if (pos.x < 0.60000002384185791015625)
                                {
                                    mask.y = global.maskLight;
                                }
                                else
                                {
                                    mask.z = global.maskLight;
                                }
                            }
                            mask_average = (((vec3(1.0) + vec3(global.maskLight, mask_average.y, mask_average.z)) + vec3(mask_average.x, global.maskLight, mask_average.z)) + vec3(mask_average.x, mask_average.y, global.maskLight)) / vec3(5.0);
                        }
                        else
                        {
                            if (global.shadowMask == 5.0)
                            {
                                mask = vec3(0.0);
                                pos.x = fract(pos.x / 2.0);
                                if (pos.x < 0.4900000095367431640625)
                                {
                                    mask.x = 1.0;
                                    mask.z = 1.0;
                                }
                                else
                                {
                                    mask.y = 1.0;
                                }
                                mask = clamp(mix(mix(one, mask, vec3(global.mcut)), mix(one, mask, vec3(global.maskstr)), vec3(mx)), vec3(0.0), vec3(1.0)) * dark_compensate;
                                mask_average = vec3(0.5);
                                mask_average = clamp(mix(mix(one, mask_average, vec3(global.mcut)), mix(one, mask_average, vec3(global.maskstr)), vec3(mx)), vec3(0.0), vec3(1.0)) * dark_compensate;
                            }
                            else
                            {
                                if (global.shadowMask == 6.0)
                                {
                                    mask = vec3(0.0);
                                    pos.x = floor(mod(pos.x, 3.0));
                                    if (pos.x < 0.5)
                                    {
                                        mask.x = 1.0;
                                    }
                                    else
                                    {
                                        if (pos.x < 1.5)
                                        {
                                            mask.y = 1.0;
                                        }
                                        else
                                        {
                                            mask.z = 1.0;
                                        }
                                    }
                                    mask = clamp(mix(mix(one, mask, vec3(global.mcut)), mix(one, mask, vec3(global.maskstr)), vec3(mx)), vec3(0.0), vec3(1.0)) * dark_compensate;
                                    mask_average = vec3(0.3333333432674407958984375);
                                    mask_average = clamp(mix(mix(one, mask_average, vec3(global.mcut)), mix(one, mask_average, vec3(global.maskstr)), vec3(mx)), vec3(0.0), vec3(1.0)) * dark_compensate;
                                }
                                else
                                {
                                    if (global.shadowMask == 7.0)
                                    {
                                        mask = vec3(0.0);
                                        pos.x = fract(pos.x / 2.0);
                                        if (pos.x < 0.4900000095367431640625)
                                        {
                                            mask = vec3(0.0);
                                        }
                                        else
                                        {
                                            mask = vec3(1.0);
                                        }
                                        mask = clamp(mix(mix(one, mask, vec3(global.mcut)), mix(one, mask, vec3(global.maskstr)), vec3(mx)), vec3(0.0), vec3(1.0)) * dark_compensate;
                                        mask_average = vec3(0.5);
                                        mask_average = clamp(mix(mix(one, mask_average, vec3(global.mcut)), mix(one, mask_average, vec3(global.maskstr)), vec3(mx)), vec3(0.0), vec3(1.0)) * dark_compensate;
                                    }
                                    else
                                    {
                                        if (global.shadowMask == 8.0)
                                        {
                                            mask = vec3(0.0);
                                            pos.x = fract(pos.x / 3.0);
                                            if (pos.x < 0.300000011920928955078125)
                                            {
                                                mask = vec3(0.0);
                                            }
                                            else
                                            {
                                                if (pos.x < 0.60000002384185791015625)
                                                {
                                                    mask = vec3(1.0);
                                                }
                                                else
                                                {
                                                    mask = vec3(1.0);
                                                }
                                            }
                                            mask = clamp(mix(mix(one, mask, vec3(global.mcut)), mix(one, mask, vec3(global.maskstr)), vec3(mx)), vec3(0.0), vec3(1.0)) * dark_compensate;
                                            mask_average = vec3(0.666666686534881591796875);
                                            mask_average = clamp(mix(mix(one, mask_average, vec3(global.mcut)), mix(one, mask_average, vec3(global.maskstr)), vec3(mx)), vec3(0.0), vec3(1.0)) * dark_compensate;
                                        }
                                        else
                                        {
                                            if (global.shadowMask == 9.0)
                                            {
                                                mask = vec3(0.0);
                                                pos.x = fract(pos.x / 3.0);
                                                if (pos.x < 0.300000011920928955078125)
                                                {
                                                    mask = vec3(0.0);
                                                }
                                                else
                                                {
                                                    if (pos.x < 0.60000002384185791015625)
                                                    {
                                                        mask.x = 1.0;
                                                        mask.z = 1.0;
                                                    }
                                                    else
                                                    {
                                                        mask.y = 1.0;
                                                    }
                                                }
                                                mask = clamp(mix(mix(one, mask, vec3(global.mcut)), mix(one, mask, vec3(global.maskstr)), vec3(mx)), vec3(0.0), vec3(1.0)) * dark_compensate;
                                                mask_average = vec3(0.25);
                                                mask_average = clamp(mix(mix(one, mask_average, vec3(global.mcut)), mix(one, mask_average, vec3(global.maskstr)), vec3(mx)), vec3(0.0), vec3(1.0)) * dark_compensate;
                                            }
                                            else
                                            {
                                                if (global.shadowMask == 10.0)
                                                {
                                                    mask = vec3(0.0);
                                                    pos.x = fract(pos.x * 0.25);
                                                    if (pos.x < 0.20000000298023223876953125)
                                                    {
                                                        mask = vec3(0.0);
                                                    }
                                                    else
                                                    {
                                                        if (pos.x < 0.4000000059604644775390625)
                                                        {
                                                            mask.x = 1.0;
                                                        }
                                                        else
                                                        {
                                                            if (pos.x < 0.699999988079071044921875)
                                                            {
                                                                mask.y = 1.0;
                                                            }
                                                            else
                                                            {
                                                                mask.z = 1.0;
                                                            }
                                                        }
                                                    }
                                                    mask = clamp(mix(mix(one, mask, vec3(global.mcut)), mix(one, mask, vec3(global.maskstr)), vec3(mx)), vec3(0.0), vec3(1.0)) * dark_compensate;
                                                    mask_average = vec3(0.25);
                                                    mask_average = clamp(mix(mix(one, mask_average, vec3(global.mcut)), mix(one, mask_average, vec3(global.maskstr)), vec3(mx)), vec3(0.0), vec3(1.0)) * dark_compensate;
                                                }
                                                else
                                                {
                                                    if (global.shadowMask == 11.0)
                                                    {
                                                        mask = vec3(0.0);
                                                        pos.x = fract(pos.x * 0.25);
                                                        if (pos.x < 0.20000000298023223876953125)
                                                        {
                                                            mask.x = 1.0;
                                                        }
                                                        else
                                                        {
                                                            if (pos.x < 0.4000000059604644775390625)
                                                            {
                                                                mask.x = 1.0;
                                                                mask.y = 1.0;
                                                            }
                                                            else
                                                            {
                                                                if (pos.x < 0.699999988079071044921875)
                                                                {
                                                                    mask.y = 1.0;
                                                                    mask.z = 1.0;
                                                                }
                                                                else
                                                                {
                                                                    mask.z = 1.0;
                                                                }
                                                            }
                                                        }
                                                        mask = clamp(mix(mix(one, mask, vec3(global.mcut)), mix(one, mask, vec3(global.maskstr)), vec3(mx)), vec3(0.0), vec3(1.0)) * dark_compensate;
                                                        mask_average = vec3(0.5);
                                                        mask_average = clamp(mix(mix(one, mask_average, vec3(global.mcut)), mix(one, mask_average, vec3(global.maskstr)), vec3(mx)), vec3(0.0), vec3(1.0)) * dark_compensate;
                                                    }
                                                    else
                                                    {
                                                        if (global.shadowMask == 12.0)
                                                        {
                                                            mask = vec3(0.0);
                                                            pos.x = floor(mod(pos.x, 7.0));
                                                            if (pos.x < 0.5)
                                                            {
                                                                mask = vec3(0.0);
                                                            }
                                                            else
                                                            {
                                                                if (pos.x < 2.5)
                                                                {
                                                                    mask.x = 1.0;
                                                                }
                                                                else
                                                                {
                                                                    if (pos.x < 4.5)
                                                                    {
                                                                        mask.y = 1.0;
                                                                    }
                                                                    else
                                                                    {
                                                                        mask.z = 1.0;
                                                                    }
                                                                }
                                                            }
                                                            mask = clamp(mix(mix(one, mask, vec3(global.mcut)), mix(one, mask, vec3(global.maskstr)), vec3(mx)), vec3(0.0), vec3(1.0)) * dark_compensate;
                                                            mask_average = vec3(0.16666667163372039794921875, 0.16666667163372039794921875, 0.3333333432674407958984375);
                                                            mask_average = clamp(mix(mix(one, mask_average, vec3(global.mcut)), mix(one, mask_average, vec3(global.maskstr)), vec3(mx)), vec3(0.0), vec3(1.0)) * dark_compensate;
                                                        }
                                                        else
                                                        {
                                                            mask = vec3(0.0);
                                                            pos.x = floor(mod(pos.x, 6.0));
                                                            if (pos.x < 0.5)
                                                            {
                                                                mask = vec3(0.0);
                                                            }
                                                            else
                                                            {
                                                                if (pos.x < 1.5)
                                                                {
                                                                    mask.x = 1.0;
                                                                }
                                                                else
                                                                {
                                                                    if (pos.x < 2.5)
                                                                    {
                                                                        mask.x = 1.0;
                                                                        mask.y = 1.0;
                                                                    }
                                                                    else
                                                                    {
                                                                        if (pos.x < 3.5)
                                                                        {
                                                                            mask = vec3(1.0);
                                                                        }
                                                                        else
                                                                        {
                                                                            if (pos.x < 4.5)
                                                                            {
                                                                                mask.y = 1.0;
                                                                                mask.z = 1.0;
                                                                            }
                                                                            else
                                                                            {
                                                                                mask.z = 1.0;
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                            mask = clamp(mix(mix(one, mask, vec3(global.mcut)), mix(one, mask, vec3(global.maskstr)), vec3(mx)), vec3(0.0), vec3(1.0)) * dark_compensate;
                                                            mask_average = vec3(0.5);
                                                            mask_average = clamp(mix(mix(one, mask_average, vec3(global.mcut)), mix(one, mask_average, vec3(global.maskstr)), vec3(mx)), vec3(0.0), vec3(1.0)) * dark_compensate;
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    highp float maskmin_average = min(min(mask_average.x, mask_average.y), mask_average.z);
    mask_average = ((mask_average - vec3(maskmin_average)) * (1.0 + ((global.maskboost - 1.0) * mb))) + vec3(maskmin_average);
    mask_average_luma = dot(mask_average, vec3(0.2989999949932098388671875, 0.58700001239776611328125, 0.114000000059604644775390625));
    highp float maskmin = min(min(mask.x, mask.y), mask.z);
    return ((mask - vec3(maskmin)) * (1.0 + ((global.maskboost - 1.0) * mb))) + vec3(maskmin);
}

highp float HSM_SlotMaskAverage(highp vec2 start_pos, highp float m)
{
    highp float slot_dark = mix(1.0 - global.slotmask1, 1.0 - global.slotmask, m);
    highp float slot = ((((global.slotwidth * 1.0) + (2.0 * slot_dark)) + (global.double_slot * 1.0)) + (2.0 * slot_dark)) / (((global.slotwidth + 2.0) + global.double_slot) + 2.0);
    return slot;
}

highp vec3 plant(highp vec3 tar, highp float r)
{
    highp float t = max(max(tar.x, tar.y), tar.z) + 9.9999997473787516355514526367188e-06;
    return (tar * r) / vec3(t);
}

highp vec3 declip(inout highp vec3 c, highp float b)
{
    highp float m = max(max(c.x, c.y), c.z);
    if (m > b)
    {
        c = (c * b) / vec3(m);
    }
    return c;
}

highp vec3 _noise(inout highp vec3 v)
{
    if (global.addnoised < 0.0)
    {
        v.z = -global.addnoised;
    }
    else
    {
        v.z = mod(v.z, 6001.0) / 1753.0;
    }
    v = (fract(v) + fract(v * 10000.0)) + fract(v * 9.9999997473787516355514526367188e-05);
    v += vec3(0.123450003564357757568359375, 0.6789000034332275390625, 0.3141590058803558349609375);
    v = fract((v * dot(v, v)) * 123.45600128173828125);
    v = fract((v * dot(v, v)) * 123.45600128173828125);
    v = fract((v * dot(v, v)) * 123.45600128173828125);
    v = fract((v * dot(v, v)) * 123.45600128173828125);
    return v;
}

highp float humbar(inout highp float pos)
{
    if (global.barintensity == 0.0)
    {
        return 1.0;
    }
    else
    {
        highp float _3546;
        if (global.barintensity >= 0.0)
        {
            _3546 = pos;
        }
        else
        {
            _3546 = 1.0 - pos;
        }
        pos = _3546;
        pos = fract(pos + (mod(float(global.FrameCount), global.barspeed) / (global.barspeed - 1.0)));
        highp float _3573;
        if (global.barintensity < 0.0)
        {
            _3573 = pos;
        }
        else
        {
            _3573 = 1.0 - pos;
        }
        pos = _3573;
        return (1.0 - global.barintensity) + (global.barintensity * pos);
    }
}

highp vec4 HSM_ApplyGamma(highp vec4 in_color, highp float in_gamma)
{
    highp vec3 out_color = pow(in_color.xyz, vec3(1.0 / in_gamma));
    return vec4(out_color, in_color.w);
}

highp vec4 HSM_Linearize(highp vec4 in_color, highp float encoded_gamma)
{
    highp vec4 param = in_color;
    highp float param_1 = 1.0 / encoded_gamma;
    return HSM_ApplyGamma(param, param_1);
}

void main()
{
    FOLLOW_MODE_SCALE_AND_POS = 0.0;
    FOLLOW_MODE_EXACT = 1.0;
    NEGATIVE_CROP_EXPAND_MULTIPLIER = 0.5;
    MAX_NEGATIVE_CROP = 0.5;
    DEFAULT_SCREEN_ASPECT = 1.3329918384552001953125;
    DEFAULT_BEZEL_ASPECT = 1.32272231578826904296875;
    DEFAULT_SCREEN_SCALE = vec2(0.0);
    DEFAULT_BEZEL_SCALE = vec2(0.0);
    INFOCACHE_MAX_INDEX = 4;
    CACHE_INFO_CHANGED = false;
    CURRENT_FRAME_FROM_CACHE_INFO = 0.0;
    TUBE_DIFFUSE_MASK = 0.0;
    TUBE_MASK = 0.0;
    BEZEL_MASK = 0.0;
    INSIDE_BEZEL_MASK = 0.0;
    OUTSIDE_TUBE_MASK_FOR_IMAGE = 0.0;
    FRAME_MASK = 0.0;
    FRAME_MASK_FOR_IMAGE = 0.0;
    OUTSIDE_BEZEL_MASK = 0.0;
    OUTSIDE_FRAME_MASK_FOR_IMAGE = 0.0;
    OUTSIDE_FRAME_MASK = 0.0;
    CUTOUT_MASK = 0.0;
    SCREEN_INDEX = 1.0;
    SCREEN_ASPECT = 1.0;
    SCREEN_SCALE = vec2(1.0);
    SCREEN_SCALE_WITH_ZOOM = vec2(1.0);
    SCREEN_POS_OFFSET = vec2(0.1500000059604644775390625);
    SCREEN_SCALE_2ND_SCREEN = vec2(1.0);
    SCREEN_POS_OFFSET_1ST_SCREEN = vec2(0.1500000059604644775390625);
    SCREEN_POS_OFFSET_2ND_SCREEN = vec2(0.1500000059604644775390625);
    VIEWPORT_SCALE = vec2(1.0);
    VIEWPORT_POS = vec2(1.0);
    TUBE_SCALE = vec2(1.0);
    TUBE_DIFFUSE_SCALE = vec2(1.0);
    TUBE_DIFFUSE_ASPECT = 1.0;
    TUBE_DIFFUSE_SCALE_1ST_SCREEN = vec2(1.0);
    TUBE_DIFFUSE_SCALE_2ND_SCREEN = vec2(1.0);
    FRAME_SCALE = vec2(1.0);
    BEZEL_OUTSIDE_SCALE = vec2(0.5);
    BACKGROUND_SCALE = vec2(0.5);
    LED_SCALE = vec2(0.5);
    DEVICE_SCALE = vec2(0.5);
    DEVICELED_SCALE = vec2(0.5);
    DECAL_SCALE = vec2(0.5);
    CAB_GLASS_SCALE = vec2(0.5);
    TOP_IMAGE_SCALE = vec2(0.5);
    AVERAGE_LUMA = 0.0;
    USE_VERTICAL_SCANLINES = 0.0;
    SAMPLING_SCANLINE_DIR_MULT = 0.0;
    SAMPLING_OPPOSITE_DIR_MULT = 0.0;
    CORE_SIZE = vec2(1.0);
    ROTATED_CORE_ORIGINAL_SIZE = vec2(1.0);
    ROTATED_CORE_PREPPED_SIZE = vec2(1.0);
    ROTATED_DEREZED_SIZE = vec2(1.0);
    CROPPED_ROTATED_SIZE_WITH_RES_MULT = vec2(1.0);
    CROPPED_ROTATED_SIZE_WITH_RES_MULT_FEEDBACK = vec2(1.0);
    CROPPED_ROTATED_SIZE = vec2(1.0);
    SAMPLE_AREA_START_PIXEL_COORD = vec2(1.0);
    SCREEN_SIZE = vec2(1.0);
    VIEWPORT_UNSCALED_COORD = vec2(0.5);
    SCREEN_COORD = vec2(0.5);
    TUBE_COORD = vec2(0.5);
    TUBE_DIFFUSE_COORD = vec2(0.5);
    TUBE_DIFFUSE_COORD_MIXED_POS = vec2(0.5);
    BEZEL_OUTSIDE_COORD = vec2(0.5);
    BACKGROUND_COORD = vec2(0.5);
    DEVICE_COORD = vec2(0.5);
    DEVICELED_COORD = vec2(0.5);
    LED_COORD = vec2(0.5);
    DECAL_COORD = vec2(0.5);
    CAB_GLASS_COORD = vec2(0.5);
    TOP_IMAGE_COORD = vec2(0.5);
    SCREEN_CURVED_COORD = vec2(0.5);
    TUBE_CURVED_COORD = vec2(0.5);
    TUBE_DIFFUSE_CURVED_COORD = vec2(0.5);
    BEZEL_OUTSIDE_CURVED_COORD = vec2(0.5);
    FRAME_OUTSIDE_CURVED_COORD = vec2(0.5);
    BACKGROUND_CURVED_COORD = vec2(0.5);
    LED_CURVED_COORD = vec2(0.5);
    DEVICE_CURVED_COORD = vec2(0.5);
    DEVICELED_CURVED_COORD = vec2(0.5);
    DECAL_CURVED_COORD = vec2(0.5);
    CAB_GLASS_CURVED_COORD = vec2(0.5);
    TOP_IMAGE_CURVED_COORD = vec2(0.5);
    HSM_RESOLUTION_DEBUG_ON = global.HSM_RESOLUTION_DEBUG_ON;
    HSM_GLOBAL_GRAPHICS_BRIGHTNESS = global.HSM_GLOBAL_GRAPHICS_BRIGHTNESS / 100.0;
    HSM_STATIC_LAYERS_GAMMA = global.HSM_STATIC_LAYERS_GAMMA;
    HSM_AMBIENT_LIGHTING_OPACITY = global.HSM_AMBIENT_LIGHTING_OPACITY / 100.0;
    HSM_AMBIENT1_OPACITY = ((global.HSM_AMBIENT1_OPACITY / 100.0) * global.HSM_AMBIENT_LIGHTING_OPACITY) / 100.0;
    HSM_AMBIENT2_OPACITY = ((global.HSM_AMBIENT2_OPACITY / 100.0) * global.HSM_AMBIENT_LIGHTING_OPACITY) / 100.0;
    HSM_AMBIENT_LIGHTING_SWAP_IMAGE_MODE = global.HSM_AMBIENT_LIGHTING_SWAP_IMAGE_MODE;
    HSM_SINDEN_BORDER_ON = global.HSM_SINDEN_BORDER_ON;
    HSM_SINDEN_BORDER_BRIGHTNESS = global.HSM_SINDEN_BORDER_BRIGHTNESS / 100.0;
    HSM_SINDEN_BORDER_THICKNESS = global.HSM_SINDEN_BORDER_THICKNESS / 100.0;
    HSM_SINDEN_BORDER_EMPTY_TUBE_COMPENSATION = global.HSM_SINDEN_BORDER_EMPTY_TUBE_COMPENSATION;
    HSM_VIEWPORT_ZOOM = global.HSM_VIEWPORT_ZOOM / 100.0;
    HSM_VIEWPORT_ZOOM_MASK = global.HSM_VIEWPORT_ZOOM_MASK;
    HSM_VIEWPORT_POSITION_X = ((-1.0) * global.HSM_VIEWPORT_POSITION_X) / 1000.0;
    HSM_VIEWPORT_POSITION_Y = ((-1.0) * global.HSM_VIEWPORT_POSITION_Y) / 1000.0;
    HSM_FLIP_VIEWPORT_VERTICAL = -((global.HSM_FLIP_VIEWPORT_VERTICAL * 2.0) - 1.0);
    HSM_FLIP_VIEWPORT_HORIZONTAL = -((global.HSM_FLIP_VIEWPORT_HORIZONTAL * 2.0) - 1.0);
    HSM_FLIP_CORE_VERTICAL = -((global.HSM_FLIP_CORE_VERTICAL * 2.0) - 1.0);
    HSM_FLIP_CORE_HORIZONTAL = -((global.HSM_FLIP_CORE_HORIZONTAL * 2.0) - 1.0);
    HSM_ROTATE_CORE_IMAGE = global.HSM_ROTATE_CORE_IMAGE;
    HSM_ASPECT_RATIO_ORIENTATION = global.HSM_ASPECT_RATIO_ORIENTATION;
    HSM_ASPECT_RATIO_MODE = global.HSM_ASPECT_RATIO_MODE;
    HSM_ASPECT_RATIO_EXPLICIT = global.HSM_ASPECT_RATIO_EXPLICIT;
    HSM_VERTICAL_PRESET = global.HSM_VERTICAL_PRESET;
    HSM_INT_SCALE_MAX_HEIGHT = global.HSM_INT_SCALE_MAX_HEIGHT / 100.0;
    HSM_NON_INTEGER_SCALE = global.HSM_NON_INTEGER_SCALE / 100.0;
    HSM_USE_PHYSICAL_SIZE_FOR_NON_INTEGER = global.HSM_USE_PHYSICAL_SIZE_FOR_NON_INTEGER;
    HSM_PHYSICAL_MONITOR_ASPECT_RATIO = global.HSM_PHYSICAL_MONITOR_ASPECT_RATIO;
    HSM_PHYSICAL_MONITOR_DIAGONAL_SIZE = global.HSM_PHYSICAL_MONITOR_DIAGONAL_SIZE;
    HSM_PHYSICAL_SIM_TUBE_DIAGONAL_SIZE = global.HSM_PHYSICAL_SIM_TUBE_DIAGONAL_SIZE;
    HSM_USE_IMAGE_FOR_PLACEMENT = global.HSM_USE_IMAGE_FOR_PLACEMENT;
    HSM_PLACEMENT_IMAGE_USE_HORIZONTAL = global.HSM_PLACEMENT_IMAGE_USE_HORIZONTAL;
    HSM_PLACEMENT_IMAGE_MODE = global.HSM_PLACEMENT_IMAGE_MODE;
    HSM_NON_INTEGER_SCALE_OFFSET = global.HSM_NON_INTEGER_SCALE_OFFSET / 100.0;
    HSM_USE_SNAP_TO_CLOSEST_INT_SCALE = global.HSM_USE_SNAP_TO_CLOSEST_INT_SCALE;
    highp float _481;
    if (HSM_USE_SNAP_TO_CLOSEST_INT_SCALE > 0.5)
    {
        _481 = global.HSM_SNAP_TO_CLOSEST_INT_SCALE_TOLERANCE / 100.0;
    }
    else
    {
        _481 = 0.0;
    }
    HSM_SNAP_TO_CLOSEST_INT_SCALE_TOLERANCE = _481;
    HSM_SCREEN_POSITION_X = global.HSM_SCREEN_POSITION_X / 1000.0;
    HSM_SCREEN_POSITION_Y = ((-1.0) * global.HSM_SCREEN_POSITION_Y) / 1000.0;
    HSM_CROP_MODE = global.HSM_CROP_MODE;
    HSM_CROP_PERCENT_ZOOM = global.HSM_CROP_PERCENT_ZOOM / 100.0;
    HSM_CROP_PERCENT_TOP = global.HSM_CROP_PERCENT_TOP / 100.0;
    HSM_CROP_PERCENT_BOTTOM = global.HSM_CROP_PERCENT_BOTTOM / 100.0;
    HSM_CROP_PERCENT_LEFT = global.HSM_CROP_PERCENT_LEFT / 100.0;
    HSM_CROP_PERCENT_RIGHT = global.HSM_CROP_PERCENT_RIGHT / 100.0;
    HSM_CROP_BLACK_THRESHOLD = global.HSM_CROP_BLACK_THRESHOLD / 100.0;
    HSM_SCANLINE_DIRECTION = global.HSM_SCANLINE_DIRECTION;
    HSM_CORE_RES_SAMPLING_MULT_SCANLINE_DIR = global.HSM_CORE_RES_SAMPLING_MULT_SCANLINE_DIR / 100.0;
    HSM_DOWNSAMPLE_BLUR_SCANLINE_DIR = global.HSM_DOWNSAMPLE_BLUR_SCANLINE_DIR / 100.0;
    HSM_CORE_RES_SAMPLING_MULT_OPPOSITE_DIR = global.HSM_CORE_RES_SAMPLING_MULT_OPPOSITE_DIR / 100.0;
    HSM_DOWNSAMPLE_BLUR_OPPOSITE_DIR = global.HSM_DOWNSAMPLE_BLUR_OPPOSITE_DIR / 100.0;
    HSM_USE_GEOM = 0.0;
    HSM_CURVATURE_MODE = global.HSM_CURVATURE_MODE;
    HSM_CURVATURE_3D_RADIUS = global.HSM_CURVATURE_3D_RADIUS / 100.0;
    HSM_CURVATURE_3D_VIEW_DIST = global.HSM_CURVATURE_3D_VIEW_DIST / 100.0;
    HSM_CURVATURE_3D_TILT_ANGLE_X = global.HSM_CURVATURE_3D_TILT_ANGLE_X / 100.0;
    HSM_CURVATURE_3D_TILT_ANGLE_Y = global.HSM_CURVATURE_3D_TILT_ANGLE_Y / 100.0;
    HSM_CRT_CURVATURE_SCALE = global.HSM_CRT_CURVATURE_SCALE / 100.0;
    HSM_CACHE_GRAPHICS_ON = global.HSM_CACHE_GRAPHICS_ON;
    HSM_CACHE_UPDATE_INDICATOR_MODE = global.HSM_CACHE_UPDATE_INDICATOR_MODE;
    HSM_AB_COMPARE_SHOW_MODE = global.HSM_AB_COMPARE_SHOW_MODE;
    HSM_AB_COMPARE_AREA = global.HSM_AB_COMPARE_AREA;
    HSM_AB_COMPARE_SPLIT_POSITION = global.HSM_AB_COMPARE_SPLIT_POSITION / 100.0;
    HSM_AB_COMPARE_FREEZE_CRT_TUBE = global.HSM_AB_COMPARE_FREEZE_CRT_TUBE;
    HSM_AB_COMPARE_FREEZE_GRAPHICS = global.HSM_AB_COMPARE_FREEZE_GRAPHICS;
    HSM_SHOW_PASS_INDEX = global.HSM_SHOW_PASS_INDEX;
    HSM_SHOW_PASS_APPLY_SCREEN_COORD = global.HSM_SHOW_PASS_APPLY_SCREEN_COORD;
    HSM_SHOW_PASS_ALPHA = global.HSM_SHOW_PASS_ALPHA;
    HSM_SCREEN_VIGNETTE_DUALSCREEN_VIS_MODE = global.HSM_SCREEN_VIGNETTE_DUALSCREEN_VIS_MODE;
    HSM_MONOCHROME_DUALSCREEN_VIS_MODE = global.HSM_MONOCHROME_DUALSCREEN_VIS_MODE;
    HSM_TUBE_DIFFUSE_MODE = global.HSM_TUBE_DIFFUSE_MODE;
    HSM_TUBE_DIFFUSE_IMAGE_AMOUNT = global.HSM_TUBE_DIFFUSE_IMAGE_AMOUNT / 100.0;
    HSM_TUBE_DIFFUSE_IMAGE_DUALSCREEN_VIS_MODE = global.HSM_TUBE_DIFFUSE_IMAGE_DUALSCREEN_VIS_MODE;
    HSM_TUBE_DIFFUSE_IMAGE_COLORIZE_ON = global.HSM_TUBE_DIFFUSE_IMAGE_COLORIZE_ON;
    HSM_TUBE_DIFFUSE_IMAGE_HUE = global.HSM_TUBE_DIFFUSE_IMAGE_HUE / 360.0;
    HSM_TUBE_DIFFUSE_IMAGE_SATURATION = global.HSM_TUBE_DIFFUSE_IMAGE_SATURATION / 100.0;
    HSM_TUBE_DIFFUSE_IMAGE_BRIGHTNESS = global.HSM_TUBE_DIFFUSE_IMAGE_BRIGHTNESS / 100.0;
    HSM_TUBE_DIFFUSE_IMAGE_GAMMA = global.HSM_TUBE_DIFFUSE_IMAGE_GAMMA;
    HSM_TUBE_DIFFUSE_IMAGE_AMBIENT_LIGHTING = global.HSM_TUBE_DIFFUSE_IMAGE_AMBIENT_LIGHTING / 100.0;
    HSM_TUBE_DIFFUSE_IMAGE_AMBIENT2_LIGHTING = global.HSM_TUBE_DIFFUSE_IMAGE_AMBIENT2_LIGHTING / 100.0;
    HSM_TUBE_DIFFUSE_IMAGE_SCALE = global.HSM_TUBE_DIFFUSE_IMAGE_SCALE / 100.0;
    HSM_TUBE_DIFFUSE_IMAGE_SCALE_X = global.HSM_TUBE_DIFFUSE_IMAGE_SCALE_X / 100.0;
    HSM_TUBE_DIFFUSE_IMAGE_ROTATION = global.HSM_TUBE_DIFFUSE_IMAGE_ROTATION;
    HSM_TUBE_SHADOW_IMAGE_ON = global.HSM_TUBE_SHADOW_IMAGE_ON;
    HSM_TUBE_SHADOW_IMAGE_OPACITY = global.HSM_TUBE_SHADOW_IMAGE_OPACITY / 100.0;
    HSM_TUBE_SHADOW_IMAGE_POS_X = global.HSM_TUBE_SHADOW_IMAGE_POS_X / 100.0;
    HSM_TUBE_SHADOW_IMAGE_POS_Y = global.HSM_TUBE_SHADOW_IMAGE_POS_Y / 100.0;
    HSM_TUBE_SHADOW_IMAGE_SCALE_X = global.HSM_TUBE_SHADOW_IMAGE_SCALE_X / 100.0;
    HSM_TUBE_SHADOW_IMAGE_SCALE_Y = global.HSM_TUBE_SHADOW_IMAGE_SCALE_Y / 100.0;
    HSM_TUBE_SHADOW_CURVATURE_SCALE = global.HSM_TUBE_SHADOW_CURVATURE_SCALE / 100.0;
    HSM_TUBE_STATIC_REFLECTION_IMAGE_ON = global.HSM_TUBE_STATIC_REFLECTION_IMAGE_ON;
    HSM_TUBE_STATIC_REFLECTION_IMAGE_DUALSCREEN_VIS_MODE = global.HSM_TUBE_STATIC_REFLECTION_IMAGE_DUALSCREEN_VIS_MODE;
    HSM_TUBE_STATIC_REFLECTION_IMAGE_OPACITY = global.HSM_TUBE_STATIC_REFLECTION_IMAGE_OPACITY / 100.0;
    HSM_TUBE_STATIC_OPACITY_DIFFUSE_MULTIPLY = global.HSM_TUBE_STATIC_OPACITY_DIFFUSE_MULTIPLY / 100.0;
    HSM_TUBE_STATIC_BLACK_LEVEL = (global.HSM_TUBE_STATIC_BLACK_LEVEL / 1000.0) + 1.0;
    HSM_TUBE_STATIC_AMBIENT_LIGHTING = global.HSM_TUBE_STATIC_AMBIENT_LIGHTING / 100.0;
    HSM_TUBE_STATIC_AMBIENT2_LIGHTING = global.HSM_TUBE_STATIC_AMBIENT2_LIGHTING / 100.0;
    HSM_TUBE_STATIC_SCALE = global.HSM_TUBE_STATIC_SCALE / 100.0;
    HSM_TUBE_STATIC_SCALE_X = global.HSM_TUBE_STATIC_SCALE_X / 100.0;
    HSM_TUBE_STATIC_POS_X = global.HSM_TUBE_STATIC_POS_X / (-1000.0);
    HSM_TUBE_STATIC_POS_Y = global.HSM_TUBE_STATIC_POS_Y / 1000.0;
    HSM_TUBE_STATIC_SHADOW_OPACITY = global.HSM_TUBE_STATIC_SHADOW_OPACITY / 100.0;
    HSM_TUBE_STATIC_DITHER_SAMPLES = global.HSM_TUBE_STATIC_DITHER_SAMPLES;
    HSM_TUBE_STATIC_DITHER_DISTANCE = global.HSM_TUBE_STATIC_DITHER_DISTANCE;
    HSM_TUBE_STATIC_DITHER_AMOUNT = global.HSM_TUBE_STATIC_DITHER_AMOUNT;
    HSM_TUBE_OPACITY = global.HSM_TUBE_OPACITY / 100.0;
    HSM_TUBE_COLORED_GEL_IMAGE_ON = global.HSM_TUBE_COLORED_GEL_IMAGE_ON;
    HSM_TUBE_COLORED_GEL_IMAGE_SCALE = global.HSM_TUBE_COLORED_GEL_IMAGE_SCALE / 100.0;
    HSM_TUBE_COLORED_GEL_IMAGE_FLIP_HORIZONTAL = -((global.HSM_TUBE_COLORED_GEL_IMAGE_FLIP_HORIZONTAL * 2.0) - 1.0);
    HSM_TUBE_COLORED_GEL_IMAGE_FLIP_VERTICAL = -((global.HSM_TUBE_COLORED_GEL_IMAGE_FLIP_VERTICAL * 2.0) - 1.0);
    HSM_TUBE_COLORED_GEL_IMAGE_DUALSCREEN_VIS_MODE = global.HSM_TUBE_COLORED_GEL_IMAGE_DUALSCREEN_VIS_MODE;
    HSM_TUBE_COLORED_GEL_IMAGE_MULTIPLY_AMOUNT = global.HSM_TUBE_COLORED_GEL_IMAGE_MULTIPLY_AMOUNT / 100.0;
    HSM_TUBE_COLORED_GEL_IMAGE_ADDITIVE_AMOUNT = global.HSM_TUBE_COLORED_GEL_IMAGE_ADDITIVE_AMOUNT / 100.0;
    HSM_TUBE_COLORED_GEL_IMAGE_NORMAL_AMOUNT = global.HSM_TUBE_COLORED_GEL_IMAGE_NORMAL_AMOUNT / 100.0;
    HSM_TUBE_COLORED_GEL_IMAGE_TRANSPARENCY_THRESHOLD = global.HSM_TUBE_COLORED_GEL_IMAGE_TRANSPARENCY_THRESHOLD / 100.0;
    HSM_TUBE_COLORED_GEL_IMAGE_NORMAL_BRIGHTNESS = global.HSM_TUBE_COLORED_GEL_IMAGE_NORMAL_BRIGHTNESS / 100.0;
    HSM_TUBE_COLORED_GEL_IMAGE_NORMAL_VIGNETTE = global.HSM_TUBE_COLORED_GEL_IMAGE_NORMAL_VIGNETTE / 100.0;
    HSM_TUBE_COLORED_GEL_IMAGE_FAKE_SCANLINE_AMOUNT = global.HSM_TUBE_COLORED_GEL_IMAGE_FAKE_SCANLINE_AMOUNT / 100.0;
    HSM_TUBE_COLORED_GEL_IMAGE_AMBIENT_LIGHTING = global.HSM_TUBE_COLORED_GEL_IMAGE_AMBIENT_LIGHTING / 100.0;
    HSM_TUBE_COLORED_GEL_IMAGE_AMBIENT2_LIGHTING = global.HSM_TUBE_COLORED_GEL_IMAGE_AMBIENT2_LIGHTING / 100.0;
    HSM_SHOW_CRT_ON_TOP_OF_COLORED_GEL = 0.0;
    HSM_DUALSCREEN_MODE = global.HSM_DUALSCREEN_MODE;
    HSM_DUALSCREEN_CORE_IMAGE_SPLIT_MODE = global.HSM_DUALSCREEN_CORE_IMAGE_SPLIT_MODE;
    HSM_DUALSCREEN_CORE_IMAGE_SWAP_SCREENS = global.HSM_DUALSCREEN_CORE_IMAGE_SWAP_SCREENS;
    HSM_DUALSCREEN_CORE_IMAGE_SPLIT_OFFSET = global.HSM_DUALSCREEN_CORE_IMAGE_SPLIT_OFFSET / 1000.0;
    HSM_DUALSCREEN_VIEWPORT_SPLIT_LOCATION = global.HSM_DUALSCREEN_VIEWPORT_SPLIT_LOCATION / 1000.0;
    HSM_DUALSCREEN_SHIFT_POSITION_WITH_SCALE = global.HSM_DUALSCREEN_SHIFT_POSITION_WITH_SCALE;
    HSM_DUALSCREEN_POSITION_OFFSET_BETWEEN_SCREENS = global.HSM_DUALSCREEN_POSITION_OFFSET_BETWEEN_SCREENS / 1000.0;
    HSM_2ND_SCREEN_ASPECT_RATIO_MODE = global.HSM_2ND_SCREEN_ASPECT_RATIO_MODE;
    HSM_2ND_SCREEN_INDEPENDENT_SCALE = global.HSM_2ND_SCREEN_INDEPENDENT_SCALE;
    HSM_2ND_SCREEN_SCALE_OFFSET = global.HSM_2ND_SCREEN_SCALE_OFFSET / 100.0;
    HSM_2ND_SCREEN_POS_X = global.HSM_2ND_SCREEN_POS_X / 1000.0;
    HSM_2ND_SCREEN_POS_Y = global.HSM_2ND_SCREEN_POS_Y / 1000.0;
    HSM_2ND_SCREEN_CROP_PERCENT_ZOOM = global.HSM_2ND_SCREEN_CROP_PERCENT_ZOOM / 100.0;
    HSM_2ND_SCREEN_CROP_PERCENT_TOP = global.HSM_2ND_SCREEN_CROP_PERCENT_TOP / 100.0;
    HSM_2ND_SCREEN_CROP_PERCENT_BOTTOM = global.HSM_2ND_SCREEN_CROP_PERCENT_BOTTOM / 100.0;
    HSM_2ND_SCREEN_CROP_PERCENT_LEFT = global.HSM_2ND_SCREEN_CROP_PERCENT_LEFT / 100.0;
    HSM_2ND_SCREEN_CROP_PERCENT_RIGHT = global.HSM_2ND_SCREEN_CROP_PERCENT_RIGHT / 100.0;
    HSM_SCREEN_REFLECTION_SCALE = global.HSM_SCREEN_REFLECTION_SCALE / 100.0;
    HSM_SCREEN_REFLECTION_POS_X = global.HSM_SCREEN_REFLECTION_POS_X / 600.0;
    HSM_SCREEN_REFLECTION_POS_Y = global.HSM_SCREEN_REFLECTION_POS_Y / 600.0;
    HSM_AMBIENT1_HUE = global.HSM_AMBIENT1_HUE / 360.0;
    HSM_AMBIENT1_SATURATION = global.HSM_AMBIENT1_SATURATION / 100.0;
    HSM_AMBIENT1_VALUE = global.HSM_AMBIENT1_VALUE / 100.0;
    HSM_AMBIENT1_CONTRAST = global.HSM_AMBIENT1_CONTRAST / 100.0;
    HSM_AMBIENT1_SCALE_KEEP_ASPECT = global.HSM_AMBIENT1_SCALE_KEEP_ASPECT;
    HSM_AMBIENT1_SCALE_INHERIT_MODE = global.HSM_AMBIENT1_SCALE_INHERIT_MODE;
    HSM_AMBIENT1_SCALE = global.HSM_AMBIENT1_SCALE / 100.0;
    HSM_AMBIENT1_SCALE_X = global.HSM_AMBIENT1_SCALE_X / 100.0;
    HSM_AMBIENT1_ROTATE = global.HSM_AMBIENT1_ROTATE;
    HSM_AMBIENT1_MIRROR_HORZ = global.HSM_AMBIENT1_MIRROR_HORZ;
    HSM_AMBIENT1_POS_INHERIT_MODE = global.HSM_AMBIENT1_POS_INHERIT_MODE;
    HSM_AMBIENT1_POSITION_X = global.HSM_AMBIENT1_POSITION_X / (-1000.0);
    HSM_AMBIENT1_POSITION_Y = ((-1.0) * global.HSM_AMBIENT1_POSITION_Y) / (-1000.0);
    HSM_AMBIENT1_DITHERING_SAMPLES = 0.0;
    HSM_AMBIENT2_HUE = global.HSM_AMBIENT2_HUE / 360.0;
    HSM_AMBIENT2_SATURATION = global.HSM_AMBIENT2_SATURATION / 100.0;
    HSM_AMBIENT2_VALUE = global.HSM_AMBIENT2_VALUE / 100.0;
    HSM_AMBIENT2_CONTRAST = global.HSM_AMBIENT2_CONTRAST / 100.0;
    HSM_AMBIENT2_SCALE_KEEP_ASPECT = global.HSM_AMBIENT2_SCALE_KEEP_ASPECT;
    HSM_AMBIENT2_SCALE_INHERIT_MODE = global.HSM_AMBIENT2_SCALE_INHERIT_MODE;
    HSM_AMBIENT2_SCALE = global.HSM_AMBIENT2_SCALE / 100.0;
    HSM_AMBIENT2_SCALE_X = global.HSM_AMBIENT2_SCALE_X / 100.0;
    HSM_AMBIENT2_ROTATE = global.HSM_AMBIENT2_ROTATE;
    HSM_AMBIENT2_MIRROR_HORZ = global.HSM_AMBIENT2_MIRROR_HORZ;
    HSM_AMBIENT2_POS_INHERIT_MODE = global.HSM_AMBIENT2_POS_INHERIT_MODE;
    HSM_AMBIENT2_POSITION_X = global.HSM_AMBIENT2_POSITION_X / (-1000.0);
    HSM_AMBIENT2_POSITION_Y = ((-1.0) * global.HSM_AMBIENT2_POSITION_Y) / (-1000.0);
    HSM_BZL_OPACITY = global.HSM_BZL_OPACITY / 100.0;
    HSM_BZL_BLEND_MODE = global.HSM_BZL_BLEND_MODE;
    HSM_BZL_WIDTH = global.HSM_BZL_WIDTH * 0.0008623999892733991146087646484375;
    HSM_BZL_HEIGHT = global.HSM_BZL_HEIGHT * 0.000873200013302266597747802734375;
    HSM_BZL_INNER_CORNER_RADIUS_SCALE = global.HSM_BZL_INNER_CORNER_RADIUS_SCALE / 100.0;
    SOURCE_MATTE_PREMULTIPLIED = 0.0;
    SOURCE_MATTE_WHITE = 1.0;
    SOURCE_MATTE_NONE = 2.0;
    BLEND_MODE_OFF = 0.0;
    BLEND_MODE_NORMAL = 1.0;
    BLEND_MODE_ADD = 2.0;
    BLEND_MODE_MULTIPLY = 3.0;
    CURVATURE_MODE_OFF = 0.0;
    CURVATURE_MODE_2D = 1.0;
    CURVATURE_MODE_2D_CYLINDER = 2.0;
    CURVATURE_MODE_3D_1 = 3.0;
    CURVATURE_MODE_3D_2 = 4.0;
    CURVATURE_MODE_3D_CYLINDER = 5.0;
    highp vec2 param = vTexCoord;
    highp vec2 viewportCoordTransformed = HSM_GetViewportCoordWithZoomAndPan(param);
    highp vec2 param_1 = vTexCoord;
    highp vec4 _3933 = HSM_UpdateGlobalScreenValuesFromCache(InfoCachePass, param_1);
    highp vec2 SourceSize = CROPPED_ROTATED_SIZE_WITH_RES_MULT;
    highp float TATE = USE_VERTICAL_SCANLINES;
    highp vec2 cache_bounds_coord = SCREEN_COORD;
    highp vec2 param_2 = cache_bounds_coord;
    if (HHLP_IsOutsideCoordSpace(param_2))
    {
        FragColor = vec4(0.0);
        return;
    }
    highp float gamma_in = 1.0 / texture(LinearizePass, vec2(0.25)).w;
    highp float intera = texture(LinearizePass, vec2(0.75, 0.25)).w;
    bool interb = intera < 0.5;
    bool notate = TATE < 0.5;
    highp vec2 pos1 = vTexCoord;
    highp float raster_bloom_avg_lum = texture(AvgLumPass, vec2(0.5)).w;
    highp vec2 screen_curved_coord = vec2(0.5);
    highp vec2 param_3 = SCREEN_COORD;
    highp vec2 param_4 = SCREEN_SCALE;
    highp float param_5 = raster_bloom_avg_lum;
    highp vec2 param_6 = screen_curved_coord;
    highp vec2 _3985 = HSM_GetCrtShaderFinalCoord(param_3, param_4, param_5, param_6);
    screen_curved_coord = param_6;
    highp vec2 screen_curved_coord_with_overscan_and_mirror = _3985;
    highp vec2 pos = screen_curved_coord_with_overscan_and_mirror;
    highp vec3 color = texture(Source, pos1).xyz;
    highp vec2 param_7 = pos;
    highp vec3 Bloom = HSM_GetCroppedTexSample(BloomPass, param_7).xyz;
    highp vec2 param_8 = ((screen_curved_coord - vec2(0.5)) * 0.999000012874603271484375) + vec2(0.5);
    highp float param_9 = SCREEN_ASPECT;
    highp float param_10 = global.HSM_GLOBAL_CORNER_RADIUS * (global.HSM_SCREEN_CORNER_RADIUS_SCALE / 100.0);
    highp float param_11 = 0.89999997615814208984375;
    highp float screen_mask = HSM_GetCornerMask(param_8, param_9, param_10, param_11);
    bool is_inside_screen = screen_mask > 0.001000000047497451305389404296875;
    bool _4033;
    if (is_inside_screen)
    {
        _4033 = global.GDV_DECONVERGENCE_ON > 0.5;
    }
    else
    {
        _4033 = is_inside_screen;
    }
    bool _4060;
    if (_4033)
    {
        _4060 = (((((abs(global.deconrr) + abs(global.deconrry)) + abs(global.deconrg)) + abs(global.deconrgy)) + abs(global.deconrb)) + abs(global.deconrby)) > 0.20000000298023223876953125;
    }
    else
    {
        _4060 = _4033;
    }
    if (_4060)
    {
        highp vec3 param_12 = color;
        highp vec3 param_13 = Bloom;
        highp vec2 param_14 = pos1;
        highp vec2 param_15 = pos;
        fetch_pixel(param_12, param_13, param_14, param_15);
        color = param_12;
        Bloom = param_13;
    }
    highp float param_16 = max(max(color.x, color.y), color.z);
    highp float cm = igc(param_16);
    highp float mx1 = texture(Source, pos1).w;
    highp float colmx = max(mx1, cm);
    highp float w3 = min((cm + 9.9999997473787516355514526367188e-05) / (colmx + 0.0005000000237487256526947021484375), 1.0);
    highp vec2 dx = mix(vec2(0.001000000047497451305389404296875, 0.0), vec2(0.0, 0.001000000047497451305389404296875), vec2(TATE));
    highp float mx0 = texture(Source, pos1 - dx).w;
    highp float mx2 = texture(Source, pos1 + dx).w;
    highp float mxg = max(max(mx0, mx1), max(mx2, cm));
    highp float mx = pow(mxg, 1.39999997615814208984375 / gamma_in);
    dx = mix(vec2(1.0 / CROPPED_ROTATED_SIZE_WITH_RES_MULT.x, 0.0), vec2(0.0, 1.0 / CROPPED_ROTATED_SIZE_WITH_RES_MULT.y), vec2(TATE)) * 0.25;
    dx *= (SCREEN_SCALE.y / 0.829699993133544921875);
    mx0 = texture(Source, pos1 - dx).w;
    mx2 = texture(Source, pos1 + dx).w;
    highp float mb = 1.0 - min(abs(mx0 - mx2) / (0.5 + mx1), 1.0);
    highp vec3 one = vec3(1.0);
    highp vec3 orig1 = color;
    highp vec3 cmask = one;
    highp vec2 maskcoord = (vTexCoord * global.OutputSize.xy).yx * 1.000010013580322265625;
    if (notate)
    {
        maskcoord = maskcoord.yx;
    }
    highp vec2 param_17 = maskcoord;
    highp float param_18 = mx;
    highp float _4199 = SlotMask(param_17, param_18);
    highp float smask = _4199;
    smask = clamp(smask + mix(global.smask_mit, 0.0, min(w3, sqrt(max(max(orig1.x, orig1.y), orig1.z)))), 0.0, 1.0);
    highp float mask_average_luma = 0.0;
    highp vec2 param_19 = maskcoord;
    highp float param_20 = mx;
    highp float param_21 = mb;
    highp float param_22 = mask_average_luma;
    highp vec3 _4227 = Mask(param_19, param_20, param_21, param_22);
    mask_average_luma = param_22;
    cmask *= _4227;
    if (!is_inside_screen)
    {
        highp vec2 param_23 = vec2(0.5);
        highp float param_24 = mx;
        smask = HSM_SlotMaskAverage(param_23, param_24);
        smask = clamp(smask + mix(global.smask_mit, 0.0, min(w3, sqrt(max(max(orig1.x, orig1.y), orig1.z)))), 0.0, 1.0);
        cmask = vec3(mask_average_luma);
    }
    if (global.mask_layout > 0.5)
    {
        cmask = cmask.xzy;
    }
    cmask *= smask;
    highp vec3 cmask1 = cmask;
    if (global.mask_bloom > 0.02500000037252902984619140625)
    {
        highp float maxbl = max(max(max(Bloom.x, Bloom.y), Bloom.z), mxg);
        maxbl *= mix(1.0, 2.0 - colmx, global.bloom_dist);
        cmask = max(min(cmask + vec3(maxbl * global.mask_bloom), vec3(1.0)), cmask);
    }
    color = pow(color, vec3(global.mask_gamma / gamma_in));
    color *= cmask;
    color = min(color, vec3(1.0));
    color = pow(color, vec3(gamma_in / global.mask_gamma));
    cmask = min(cmask, vec3(1.0));
    cmask1 = min(cmask1, vec3(1.0));
    highp float bb = mix(global.brightboost, global.brightboost1, mx);
    if (interb)
    {
        highp float _4351;
        if (abs(intera - 0.5) < 0.100000001490116119384765625)
        {
            _4351 = pow(0.800000011920928955078125 * bb, 0.64999997615814208984375);
        }
        else
        {
            _4351 = pow(bb, 0.699999988079071044921875);
        }
        bb = _4351;
    }
    color *= bb;
    highp vec2 param_25 = pos;
    highp vec3 Ref = HSM_GetCroppedTexSample(LinearizePass, param_25).xyz;
    highp vec2 param_26 = pos;
    highp vec3 Glow = HSM_GetCroppedTexSample(GlowPass, param_26).xyz;
    highp vec2 param_27 = pos;
    highp float maxb = HSM_GetCroppedTexSample(BloomPass, param_27).w;
    highp vec3 Bloom1 = Bloom;
    if (abs(global.bloom) > 0.02500000037252902984619140625)
    {
        if (global.bloom < (-0.00999999977648258209228515625))
        {
            highp vec3 param_28 = Bloom;
            highp float param_29 = maxb;
            Bloom1 = plant(param_28, param_29);
        }
        Bloom1 = min(Bloom1 * (orig1 + color), max(((vec3(colmx) + orig1) - color) * 0.5, Bloom1 * 0.001000000047497451305389404296875));
        Bloom1 = (Bloom1 + mix(Bloom1, mix(orig1 * colmx, Bloom1, vec3(0.5)), vec3(1.0) - color)) * 0.5;
        Bloom1 *= mix(1.0, 2.0 - colmx, global.bloom_dist);
        color = pow(pow(color, vec3(global.mask_gamma / gamma_in)) + (pow(Bloom1, vec3(global.mask_gamma / gamma_in)) * abs(global.bloom)), vec3(gamma_in / global.mask_gamma));
    }
    color = min(color, mix(one, cmask1, vec3(global.mclip)));
    if (!interb)
    {
        highp vec3 param_30 = color;
        highp float param_31 = mix(1.0, w3, 0.60000002384185791015625);
        highp vec3 _4482 = declip(param_30, param_31);
        color = _4482;
    }
    else
    {
        w3 = 1.0;
    }
    if (global.halation > 0.00999999977648258209228515625)
    {
        Bloom = mix((Bloom + (Bloom * Bloom)) * 0.5, (Bloom * 0.75) * Bloom, vec3(colmx));
        color += (((mix(one, cmask, vec3(0.60000002384185791015625)) * ((2.0 * max((2.0 * mix(maxb * maxb, maxb, colmx)) - (0.5 * max(max(Ref.x, Ref.y), Ref.z)), 0.25)) * mix(1.0, w3, 0.5 * colmx))) * Bloom) * global.halation);
    }
    else
    {
        if (global.halation < (-0.00999999977648258209228515625))
        {
            highp float mbl = max(max(Bloom.x, Bloom.y), Bloom.z);
            highp vec3 param_32 = ((Bloom + Ref) + orig1) + ((Bloom * Bloom) * Bloom);
            highp float param_33 = min(mbl * mbl, 0.75);
            Bloom = plant(param_32, param_33);
            color += (((mix(one, cmask, vec3(0.5)) * (2.0 * mix(1.0, w3, 0.5 * colmx))) * Bloom) * (-global.halation));
        }
    }
    highp float w = 0.25 + (0.60000002384185791015625 * mix(w3, 1.0, sqrt(colmx)));
    if (global.smoothmask > 0.5)
    {
        w3 = mix(1.0, w3, smoothstep(0.300000011920928955078125, 0.60000002384185791015625, mx1));
        color = max(min(color / vec3(w3), vec3(1.0)) * w3, min(color, color * (1.0 - w3)));
    }
    if (global.m_glow < 0.5)
    {
        Glow = mix(Glow, color * 0.25, vec3(0.699999988079071044921875 * colmx));
    }
    else
    {
        maxb = max(max(Glow.x, Glow.y), Glow.z);
        highp vec3 param_34 = orig1 + (Ref * 0.001000000047497451305389404296875);
        highp float param_35 = 1.0;
        orig1 = plant(param_34, param_35);
        highp vec3 param_36 = Glow;
        highp float param_37 = 1.0;
        Bloom = plant(param_36, param_37);
        Ref = abs(orig1 - Bloom);
        mx0 = max(max(orig1.y, orig1.y), orig1.z) - min(min(orig1.y, orig1.y), orig1.z);
        mx2 = max(max(Bloom.y, Bloom.y), Bloom.z) - min(min(Bloom.y, Bloom.y), Bloom.z);
        Bloom = mix(min(Bloom, orig1) * maxb, mix(mix(Glow, Glow * max(max(Ref.y, Ref.y), Ref.z), vec3(max(mx, mx0))), Glow, Ref * max(mx0, mx2)) * w, vec3(min(sqrt((1.10000002384185791015625 - mx0) * (0.100000001490116119384765625 + mx2)), 1.0)));
        Glow = mix(Glow * global.m_glow_low, Bloom * global.m_glow_high, vec3(pow(colmx, global.m_glow_dist / gamma_in)));
    }
    bool _4755 = global.glow >= 0.0;
    bool _4761;
    if (_4755)
    {
        _4761 = global.m_glow < 0.5;
    }
    else
    {
        _4761 = _4755;
    }
    if (_4761)
    {
        color += ((Glow * 0.5) * global.glow);
    }
    else
    {
        if (global.m_glow > 0.5)
        {
            cmask1 = max(mix(one, cmask1, vec3(global.m_glow_mask)), vec3(0.0));
        }
        color += ((cmask1 * abs(global.glow)) * Glow);
    }
    color = pow(color, vec3(1.0 / global.gamma_out));
    if (global.GDV_NOISE_ON > 0.5)
    {
        highp float rc = (0.60000002384185791015625 * sqrt(max(max(color.x, color.y), color.z))) + 0.4000000059604644775390625;
        highp float _4825;
        if (global.FinalViewportSize.y > 2000.0)
        {
            _4825 = global.noiseresd * global.noiseresd4kmult;
        }
        else
        {
            _4825 = global.noiseresd;
        }
        highp float noise_res = _4825;
        bool _4841 = global.noiseresd4kmult > 1.0;
        bool _4848;
        if (_4841)
        {
            _4848 = global.FinalViewportSize.y > 4200.0;
        }
        else
        {
            _4848 = _4841;
        }
        noise_res *= float(_4848 ? 2 : 1);
        highp vec3 param_38 = vec3(floor((global.OutputSize.xy * vTexCoord) / vec2(noise_res)), float(global.FrameCount));
        highp vec3 _4870 = _noise(param_38);
        highp vec3 noise0 = _4870;
        if (global.noisetype < 0.5)
        {
            color = mix(color, noise0, vec3((0.25 * abs(global.addnoised)) * rc));
        }
        else
        {
            color = min(color * mix(1.0, 1.5 * noise0.x, 0.5 * abs(global.addnoised)), vec3(1.0));
        }
    }
    highp float _4905;
    if (global.bardir < 0.0)
    {
        _4905 = TATE;
    }
    else
    {
        _4905 = global.bardir;
    }
    highp float adjusted_bardir = _4905;
    highp float param_39 = mix(pos.y, pos.x, adjusted_bardir);
    highp float _4920 = humbar(param_39);
    color *= _4920;
    FragColor = vec4(color, 1.0);
    highp vec4 param_40 = FragColor;
    highp float param_41 = 2.2000000476837158203125;
    FragColor = HSM_Linearize(param_40, param_41);
}

