#version 430 es
precision mediump float;
precision highp int;

layout(binding = 0, std140) uniform UBO
{
    highp mat4 MVP;
    highp vec4 SourceSize;
    highp vec4 OriginalSize;
    highp vec4 CorePassSize;
    highp vec4 CorePassFeedbackSize;
    highp vec4 OutputSize;
    highp vec4 FinalViewportSize;
    highp vec4 NegativeCropAddedPassSize;
    highp vec4 DerezedPassSize;
    int FrameDirection;
    uint FrameCount;
    highp float HSM_RESOLUTION_DEBUG_ON;
    highp float HSM_SINDEN_BORDER_ON;
    highp float HSM_SINDEN_BORDER_OPACITY;
    highp float HSM_SINDEN_BORDER_BRIGHTNESS;
    highp float HSM_SINDEN_AMBIENT_LIGHTING;
    highp float HSM_SINDEN_BORDER_THICKNESS;
    highp float HSM_SINDEN_BORDER_EMPTY_TUBE_COMPENSATION;
    highp float HSM_CACHE_GRAPHICS_ON;
    highp float HSM_CACHE_UPDATE_INDICATOR_MODE;
    highp float HSM_GLOBAL_GRAPHICS_BRIGHTNESS;
    highp float HSM_STATIC_LAYERS_GAMMA;
    highp float HSM_AMBIENT_LIGHTING_OPACITY;
    highp float HSM_AMBIENT1_OPACITY;
    highp float HSM_AMBIENT2_OPACITY;
    highp float HSM_AMBIENT_LIGHTING_SWAP_IMAGE_MODE;
    highp float HSM_AMBIENT1_HUE;
    highp float HSM_AMBIENT1_SATURATION;
    highp float HSM_AMBIENT1_VALUE;
    highp float HSM_AMBIENT1_CONTRAST;
    highp float HSM_AMBIENT1_SCALE_KEEP_ASPECT;
    highp float HSM_AMBIENT1_SCALE_INHERIT_MODE;
    highp float HSM_AMBIENT1_SCALE;
    highp float HSM_AMBIENT1_SCALE_X;
    highp float HSM_AMBIENT1_ROTATE;
    highp float HSM_AMBIENT1_MIRROR_HORZ;
    highp float HSM_AMBIENT1_POS_INHERIT_MODE;
    highp float HSM_AMBIENT1_POSITION_X;
    highp float HSM_AMBIENT1_POSITION_Y;
    highp float HSM_AMBIENT1_DITHERING_SAMPLES;
    highp float HSM_AMBIENT2_HUE;
    highp float HSM_AMBIENT2_SATURATION;
    highp float HSM_AMBIENT2_VALUE;
    highp float HSM_AMBIENT2_CONTRAST;
    highp float HSM_AMBIENT2_SCALE_KEEP_ASPECT;
    highp float HSM_AMBIENT2_SCALE_INHERIT_MODE;
    highp float HSM_AMBIENT2_SCALE;
    highp float HSM_AMBIENT2_SCALE_X;
    highp float HSM_AMBIENT2_ROTATE;
    highp float HSM_AMBIENT2_MIRROR_HORZ;
    highp float HSM_AMBIENT2_POS_INHERIT_MODE;
    highp float HSM_AMBIENT2_POSITION_X;
    highp float HSM_AMBIENT2_POSITION_Y;
    highp float HSM_VIEWPORT_ZOOM;
    highp float HSM_VIEWPORT_POSITION_X;
    highp float HSM_VIEWPORT_POSITION_Y;
    highp float HSM_VIEWPORT_ZOOM_MASK;
    highp float HSM_FLIP_VIEWPORT_VERTICAL;
    highp float HSM_FLIP_VIEWPORT_HORIZONTAL;
    highp float HSM_FLIP_CORE_VERTICAL;
    highp float HSM_FLIP_CORE_HORIZONTAL;
    highp float HSM_ROTATE_CORE_IMAGE;
    highp float HSM_ASPECT_RATIO_ORIENTATION;
    highp float HSM_ASPECT_RATIO_MODE;
    highp float HSM_ASPECT_RATIO_EXPLICIT;
    highp float HSM_INT_SCALE_MODE;
    highp float HSM_INT_SCALE_MULTIPLE_OFFSET;
    highp float HSM_INT_SCALE_MULTIPLE_OFFSET_LONG;
    highp float HSM_INT_SCALE_MAX_HEIGHT;
    highp float HSM_VERTICAL_PRESET;
    highp float HSM_NON_INTEGER_SCALE;
    highp float HSM_USE_PHYSICAL_SIZE_FOR_NON_INTEGER;
    highp float HSM_PHYSICAL_MONITOR_ASPECT_RATIO;
    highp float HSM_PHYSICAL_MONITOR_DIAGONAL_SIZE;
    highp float HSM_PHYSICAL_SIM_TUBE_DIAGONAL_SIZE;
    highp float HSM_USE_IMAGE_FOR_PLACEMENT;
    highp float HSM_PLACEMENT_IMAGE_USE_HORIZONTAL;
    highp float HSM_PLACEMENT_IMAGE_MODE;
    highp float HSM_NON_INTEGER_SCALE_OFFSET;
    highp float HSM_USE_SNAP_TO_CLOSEST_INT_SCALE;
    highp float HSM_SNAP_TO_CLOSEST_INT_SCALE_TOLERANCE;
    highp float HSM_SCREEN_POSITION_X;
    highp float HSM_SCREEN_POSITION_Y;
    highp float HSM_CROP_MODE;
    highp float HSM_CROP_PERCENT_ZOOM;
    highp float HSM_CROP_PERCENT_TOP;
    highp float HSM_CROP_PERCENT_BOTTOM;
    highp float HSM_CROP_PERCENT_LEFT;
    highp float HSM_CROP_PERCENT_RIGHT;
    highp float HSM_CROP_BLACK_THRESHOLD;
    highp float HSM_SCANLINE_DIRECTION;
    highp float HSM_CORE_RES_SAMPLING_MULT_SCANLINE_DIR;
    highp float HSM_DOWNSAMPLE_BLUR_SCANLINE_DIR;
    highp float HSM_CORE_RES_SAMPLING_MULT_OPPOSITE_DIR;
    highp float HSM_DOWNSAMPLE_BLUR_OPPOSITE_DIR;
    highp float HSM_CORE_RES_SAMPLING_SHIFT_OPPOSITE_DIR;
    highp float HSM_INTERLACE_TRIGGER_RES;
    highp float HSM_INTERLACE_MODE;
    highp float HSM_INTERLACE_EFFECT_SMOOTHNESS_INTERS;
    highp float HSM_INTERLACE_SCANLINE_EFFECT;
    highp float iscans;
    highp float HSM_FAKE_SCANLINE_MODE;
    highp float HSM_FAKE_SCANLINE_OPACITY;
    highp float HSM_FAKE_SCANLINE_RES_MODE;
    highp float HSM_FAKE_SCANLINE_RES;
    highp float HSM_FAKE_SCANLINE_INT_SCALE;
    highp float HSM_FAKE_SCANLINE_ROLL;
    highp float HSM_FAKE_SCANLINE_CURVATURE;
    highp float HSM_FAKE_SCANLINE_BRIGHTNESS_CUTOFF;
    highp float HSM_DUALSCREEN_MODE;
    highp float HSM_DUALSCREEN_CORE_IMAGE_SPLIT_MODE;
    highp float HSM_DUALSCREEN_CORE_IMAGE_SWAP_SCREENS;
    highp float HSM_DUALSCREEN_CORE_IMAGE_SPLIT_OFFSET;
    highp float HSM_DUALSCREEN_VIEWPORT_SPLIT_LOCATION;
    highp float HSM_DUALSCREEN_SHIFT_POSITION_WITH_SCALE;
    highp float HSM_DUALSCREEN_POSITION_OFFSET_BETWEEN_SCREENS;
    highp float HSM_2ND_SCREEN_ASPECT_RATIO_MODE;
    highp float HSM_2ND_SCREEN_INDEPENDENT_SCALE;
    highp float HSM_2ND_SCREEN_SCALE_OFFSET;
    highp float HSM_2ND_SCREEN_POS_X;
    highp float HSM_2ND_SCREEN_POS_Y;
    highp float HSM_2ND_SCREEN_CROP_PERCENT_ZOOM;
    highp float HSM_2ND_SCREEN_CROP_PERCENT_TOP;
    highp float HSM_2ND_SCREEN_CROP_PERCENT_BOTTOM;
    highp float HSM_2ND_SCREEN_CROP_PERCENT_LEFT;
    highp float HSM_2ND_SCREEN_CROP_PERCENT_RIGHT;
    highp float HSM_CURVATURE_MODE;
    highp float HSM_CURVATURE_2D_SCALE_LONG_AXIS;
    highp float HSM_CURVATURE_2D_SCALE_SHORT_AXIS;
    highp float HSM_CURVATURE_3D_RADIUS;
    highp float HSM_CURVATURE_3D_VIEW_DIST;
    highp float HSM_CURVATURE_3D_TILT_ANGLE_X;
    highp float HSM_CURVATURE_3D_TILT_ANGLE_Y;
    highp float HSM_CRT_CURVATURE_SCALE;
    highp float HSM_SIGNAL_NOISE_ON;
    highp float HSM_SIGNAL_NOISE_AMOUNT;
    highp float HSM_SIGNAL_NOISE_BLACK_LEVEL;
    highp float HSM_SIGNAL_NOISE_SIZE_MODE;
    highp float HSM_SIGNAL_NOISE_SIZE_MULT;
    highp float HSM_SIGNAL_NOISE_TYPE;
    highp float HSM_ANTI_FLICKER_ON;
    highp float HSM_ANTI_FLICKER_THRESHOLD;
    highp float HSM_AB_COMPARE_SHOW_MODE;
    highp float HSM_AB_COMPARE_AREA;
    highp float HSM_AB_COMPARE_FREEZE_CRT_TUBE;
    highp float HSM_AB_COMPARE_FREEZE_GRAPHICS;
    highp float HSM_AB_COMPARE_SPLIT_AREA;
    highp float HSM_AB_COMPARE_SPLIT_POSITION;
    highp float HSM_SHOW_PASS_INDEX;
    highp float HSM_SHOW_PASS_ALPHA;
    highp float HSM_SHOW_PASS_APPLY_SCREEN_COORD;
    highp float HSM_SCREEN_VIGNETTE_ON;
    highp float HSM_SCREEN_VIGNETTE_DUALSCREEN_VIS_MODE;
    highp float HSM_SCREEN_VIGNETTE_STRENGTH;
    highp float HSM_SCREEN_VIGNETTE_POWER;
    highp float HSM_SCREEN_VIGNETTE_IN_REFLECTION;
    highp float HSM_MONOCHROME_MODE;
    highp float HSM_MONOCHROME_BRIGHTNESS;
    highp float HSM_MONOCHROME_GAMMA;
    highp float HSM_MONOCHROME_HUE_OFFSET;
    highp float HSM_MONOCHROME_SATURATION;
    highp float HSM_MONOCHROME_DUALSCREEN_VIS_MODE;
    highp float HSM_SCREEN_REFLECTION_SCALE;
    highp float HSM_SCREEN_REFLECTION_POS_X;
    highp float HSM_SCREEN_REFLECTION_POS_Y;
    highp float HSM_TUBE_DIFFUSE_MODE;
    highp float HSM_TUBE_DIFFUSE_IMAGE_DUALSCREEN_VIS_MODE;
    highp float HSM_TUBE_OPACITY;
    highp float HSM_TUBE_DIFFUSE_IMAGE_AMOUNT;
    highp float HSM_TUBE_DIFFUSE_IMAGE_HUE;
    highp float HSM_TUBE_DIFFUSE_IMAGE_COLORIZE_ON;
    highp float HSM_TUBE_DIFFUSE_IMAGE_SATURATION;
    highp float HSM_TUBE_DIFFUSE_IMAGE_BRIGHTNESS;
    highp float HSM_TUBE_DIFFUSE_IMAGE_GAMMA;
    highp float HSM_TUBE_DIFFUSE_IMAGE_AMBIENT_LIGHTING;
    highp float HSM_TUBE_DIFFUSE_IMAGE_AMBIENT2_LIGHTING;
    highp float HSM_TUBE_DIFFUSE_IMAGE_SCALE;
    highp float HSM_TUBE_DIFFUSE_IMAGE_SCALE_X;
    highp float HSM_TUBE_DIFFUSE_IMAGE_ROTATION;
    highp float HSM_TUBE_EMPTY_THICKNESS;
    highp float HSM_TUBE_EMPTY_THICKNESS_X_SCALE;
    highp float HSM_TUBE_DIFFUSE_FORCE_ASPECT;
    highp float HSM_TUBE_EXPLICIT_ASPECT;
    highp float HSM_SCREEN_CORNER_RADIUS_SCALE;
    highp float HSM_TUBE_COLORED_GEL_IMAGE_ON;
    highp float HSM_TUBE_COLORED_GEL_IMAGE_DUALSCREEN_VIS_MODE;
    highp float HSM_TUBE_COLORED_GEL_IMAGE_MULTIPLY_AMOUNT;
    highp float HSM_TUBE_COLORED_GEL_IMAGE_NORMAL_AMOUNT;
    highp float HSM_TUBE_COLORED_GEL_IMAGE_NORMAL_BRIGHTNESS;
    highp float HSM_TUBE_COLORED_GEL_IMAGE_NORMAL_VIGNETTE;
    highp float HSM_TUBE_COLORED_GEL_IMAGE_TRANSPARENCY_THRESHOLD;
    highp float HSM_TUBE_COLORED_GEL_IMAGE_ADDITIVE_AMOUNT;
    highp float HSM_SHOW_CRT_ON_TOP_OF_COLORED_GEL;
    highp float HSM_TUBE_SHADOW_IMAGE_ON;
    highp float HSM_TUBE_SHADOW_IMAGE_OPACITY;
    highp float HSM_TUBE_SHADOW_IMAGE_SCALE_X;
    highp float HSM_TUBE_SHADOW_IMAGE_SCALE_Y;
    highp float HSM_TUBE_SHADOW_IMAGE_POS_X;
    highp float HSM_TUBE_SHADOW_IMAGE_POS_Y;
    highp float HSM_TUBE_SHADOW_CURVATURE_SCALE;
    highp float HSM_TUBE_COLORED_GEL_IMAGE_AMBIENT_LIGHTING;
    highp float HSM_TUBE_COLORED_GEL_IMAGE_AMBIENT2_LIGHTING;
    highp float HSM_TUBE_COLORED_GEL_IMAGE_FAKE_SCANLINE_AMOUNT;
    highp float HSM_TUBE_COLORED_GEL_IMAGE_SCALE;
    highp float HSM_TUBE_COLORED_GEL_IMAGE_FLIP_HORIZONTAL;
    highp float HSM_TUBE_COLORED_GEL_IMAGE_FLIP_VERTICAL;
    highp float HSM_TUBE_STATIC_REFLECTION_IMAGE_ON;
    highp float HSM_TUBE_STATIC_REFLECTION_IMAGE_DUALSCREEN_VIS_MODE;
    highp float HSM_TUBE_STATIC_REFLECTION_IMAGE_OPACITY;
    highp float HSM_TUBE_STATIC_OPACITY_DIFFUSE_MULTIPLY;
    highp float HSM_TUBE_STATIC_BLACK_LEVEL;
    highp float HSM_TUBE_STATIC_AMBIENT_LIGHTING;
    highp float HSM_TUBE_STATIC_AMBIENT2_LIGHTING;
    highp float HSM_TUBE_STATIC_SCALE;
    highp float HSM_TUBE_STATIC_SCALE_X;
    highp float HSM_TUBE_STATIC_POS_X;
    highp float HSM_TUBE_STATIC_POS_Y;
    highp float HSM_TUBE_STATIC_SHADOW_OPACITY;
    highp float HSM_TUBE_STATIC_DITHER_SAMPLES;
    highp float HSM_TUBE_STATIC_DITHER_DISTANCE;
    highp float HSM_TUBE_STATIC_DITHER_AMOUNT;
    highp float HSM_CRT_BLEND_MODE;
    highp float HSM_CRT_BLEND_AMOUNT;
    highp float HSM_CRT_SCREEN_BLEND_MODE;
    highp float HSM_GLOBAL_CORNER_RADIUS;
    highp float HSM_TUBE_BLACK_EDGE_CORNER_RADIUS_SCALE;
    highp float HSM_TUBE_BLACK_EDGE_SHARPNESS;
    highp float HSM_TUBE_BLACK_EDGE_CURVATURE_SCALE;
    highp float HSM_TUBE_BLACK_EDGE_THICKNESS;
    highp float HSM_TUBE_BLACK_EDGE_THICKNESS_X_SCALE;
    highp float HSM_BZL_USE_INDEPENDENT_SCALE;
    highp float HSM_BZL_INDEPENDENT_SCALE;
    highp float HSM_BZL_USE_INDEPENDENT_CURVATURE;
    highp float HSM_BZL_INDEPENDENT_CURVATURE_SCALE_LONG_AXIS;
    highp float HSM_BZL_INDEPENDENT_CURVATURE_SCALE_SHORT_AXIS;
    highp float HSM_BZL_OPACITY;
    highp float HSM_BZL_BLEND_MODE;
    highp float HSM_BZL_WIDTH;
    highp float HSM_BZL_HEIGHT;
    highp float HSM_BZL_SCALE_OFFSET;
    highp float HSM_BZL_INNER_CURVATURE_SCALE;
    highp float HSM_BZL_INNER_CORNER_RADIUS_SCALE;
    highp float HSM_BZL_OUTER_CURVATURE_SCALE;
    highp float HSM_BZL_INNER_EDGE_THICKNESS;
    highp float HSM_BZL_INNER_EDGE_SHARPNESS;
    highp float HSM_BZL_OUTER_CORNER_RADIUS_SCALE;
    highp float HSM_BZL_INNER_EDGE_SHADOW;
    highp float HSM_BZL_COLOR_HUE;
    highp float HSM_BZL_COLOR_SATURATION;
    highp float HSM_BZL_COLOR_VALUE;
    highp float HSM_BZL_NOISE;
    highp float HSM_BZL_BRIGHTNESS;
    highp float HSM_BZL_BRIGHTNESS_MULT_TOP;
    highp float HSM_BZL_BRIGHTNESS_MULT_BOTTOM;
    highp float HSM_BZL_BRIGHTNESS_MULT_SIDES;
    highp float HSM_BZL_BRIGHTNESS_MULT_SIDE_LEFT;
    highp float HSM_BZL_BRIGHTNESS_MULT_SIDE_RIGHT;
    highp float HSM_BZL_HIGHLIGHT;
    highp float HSM_BZL_AMBIENT_LIGHTING_MULTIPLIER;
    highp float HSM_BZL_AMBIENT2_LIGHTING_MULTIPLIER;
    highp float HSM_FRM_USE_INDEPENDENT_COLOR;
    highp float HSM_FRM_COLOR_HUE;
    highp float HSM_FRM_COLOR_SATURATION;
    highp float HSM_FRM_COLOR_VALUE;
    highp float HSM_FRM_NOISE;
    highp float HSM_FRM_OUTER_CURVATURE_SCALE;
    highp float HSM_FRM_THICKNESS;
    highp float HSM_FRM_THICKNESS_SCALE_X;
    highp float HSM_FRM_OUTER_POS_Y;
    highp float HSM_FRM_INNER_EDGE_THICKNESS;
    highp float HSM_FRM_OUTER_EDGE_THICKNESS;
    highp float HSM_FRM_OUTER_EDGE_SHADING;
    highp float HSM_FRM_OUTER_CORNER_RADIUS;
    highp float HSM_BZL_OUTER_POSITION_Y;
    highp float HSM_FRM_SHADOW_OPACITY;
    highp float HSM_FRM_SHADOW_WIDTH;
    highp float HSM_REFLECT_CORNER_FADE;
    highp float HSM_REFLECT_CORNER_INNER_SPREAD;
    highp float HSM_REFLECT_CORNER_OUTER_SPREAD;
    highp float HSM_REFLECT_CORNER_ROTATION_OFFSET_TOP;
    highp float HSM_REFLECT_CORNER_ROTATION_OFFSET_BOTTOM;
    highp float HSM_REFLECT_CORNER_SPREAD_FALLOFF;
    highp float HSM_REFLECT_CORNER_FADE_DISTANCE;
    highp float HSM_REFLECT_GLOBAL_AMOUNT;
    highp float HSM_REFLECT_GLOBAL_GAMMA_ADJUST;
    highp float HSM_REFLECT_BEZEL_INNER_EDGE_AMOUNT;
    highp float HSM_REFLECT_BEZEL_INNER_EDGE_FULLSCREEN_GLOW;
    highp float HSM_REFLECT_FRAME_INNER_EDGE_AMOUNT;
    highp float HSM_REFLECT_FRAME_INNER_EDGE_SHARPNESS;
    highp float HSM_REFLECT_SHOW_TUBE_FX_AMOUNT;
    highp float HSM_REFLECT_DIRECT_AMOUNT;
    highp float HSM_REFLECT_DIFFUSED_AMOUNT;
    highp float HSM_REFLECT_FULLSCREEN_GLOW;
    highp float HSM_REFLECT_FULLSCREEN_GLOW_GAMMA;
    highp float HSM_REFLECT_FADE_AMOUNT;
    highp float HSM_REFLECT_RADIAL_FADE_WIDTH;
    highp float HSM_REFLECT_RADIAL_FADE_HEIGHT;
    highp float HSM_REFLECT_LATERAL_OUTER_FADE_POSITION;
    highp float HSM_REFLECT_LATERAL_OUTER_FADE_DISTANCE;
    highp float HSM_REFLECT_NOISE_AMOUNT;
    highp float HSM_REFLECT_NOISE_SAMPLES;
    highp float HSM_REFLECT_NOISE_SAMPLE_DISTANCE;
    highp float HSM_REFLECT_BLUR_NUM_SAMPLES;
    highp float HSM_REFLECT_BLUR_FALLOFF_DISTANCE;
    highp float HSM_REFLECT_BLUR_MIN;
    highp float HSM_REFLECT_BLUR_MAX;
    highp float HSM_REFLECT_MASK_IMAGE_AMOUNT;
    highp float HSM_REFLECT_MASK_FOLLOW_LAYER;
    highp float HSM_REFLECT_MASK_FOLLOW_MODE;
    highp float HSM_REFLECT_MASK_BRIGHTNESS;
    highp float HSM_REFLECT_MASK_BLACK_LEVEL;
    highp float HSM_REFLECT_MASK_MIPMAPPING_BLEND_BIAS;
    highp float HSM_GLASS_BORDER_ON;
    highp float HSM_REFLECT_VIGNETTE_AMOUNT;
    highp float HSM_REFLECT_VIGNETTE_SIZE;
    highp float HSM_POTATO_SHOW_BG_OVER_SCREEN;
    highp float HSM_POTATO_COLORIZE_CRT_WITH_BG;
    highp float HSM_POTATO_COLORIZE_BRIGHTNESS;
    highp float HSM_STANDARD_DECAL_SCALE_WITH_FRAME;
    highp float HSM_STANDARD_TOP_SCALE_WITH_FRAME;
    highp float HSM_BG_LAYER_ORDER;
    highp float HSM_VIEWPORT_VIGNETTE_LAYER_ORDER;
    highp float HSM_CRT_LAYER_ORDER;
    highp float HSM_DEVICE_LAYER_ORDER;
    highp float HSM_DEVICELED_LAYER_ORDER;
    highp float HSM_CAB_GLASS_LAYER_ORDER;
    highp float HSM_DECAL_LAYER_ORDER;
    highp float HSM_LED_LAYER_ORDER;
    highp float HSM_TOP_LAYER_ORDER;
    highp float HSM_CUTOUT_ASPECT_MODE;
    highp float HSM_CUTOUT_EXPLICIT_ASPECT;
    highp float HSM_CUTOUT_FOLLOW_LAYER;
    highp float HSM_CUTOUT_FOLLOW_FULL_USES_ZOOM;
    highp float HSM_CUTOUT_SCALE;
    highp float HSM_CUTOUT_SCALE_X;
    highp float HSM_CUTOUT_CORNER_RADIUS;
    highp float HSM_CUTOUT_POS_X;
    highp float HSM_CUTOUT_POS_Y;
    highp float HSM_BG_OPACITY;
    highp float HSM_BG_HUE;
    highp float HSM_BG_COLORIZE_ON;
    highp float HSM_BG_SATURATION;
    highp float HSM_BG_BRIGHTNESS;
    highp float HSM_BG_GAMMA;
    highp float HSM_BG_AMBIENT_LIGHTING_MULTIPLIER;
    highp float HSM_BG_AMBIENT2_LIGHTING_MULTIPLIER;
    highp float HSM_BG_APPLY_AMBIENT_IN_ADD_MODE;
    highp float HSM_BG_BLEND_MODE;
    highp float HSM_BG_SOURCE_MATTE_TYPE;
    highp float HSM_BG_MASK_MODE;
    highp float HSM_BG_CUTOUT_MODE;
    highp float HSM_BG_DUALSCREEN_VIS_MODE;
    highp float HSM_BG_FOLLOW_LAYER;
    highp float HSM_BG_FOLLOW_MODE;
    highp float HSM_BG_FOLLOW_FULL_USES_ZOOM;
    highp float HSM_BG_FILL_MODE;
    highp float HSM_BG_SPLIT_PRESERVE_CENTER;
    highp float HSM_BG_SPLIT_REPEAT_WIDTH;
    highp float HSM_BG_SCALE;
    highp float HSM_BG_SCALE_X;
    highp float HSM_BG_POS_X;
    highp float HSM_BG_POS_Y;
    highp float HSM_BG_WRAP_MODE;
    highp float HSM_BG_MIPMAPPING_BLEND_BIAS;
    highp float HSM_VIEWPORT_VIGNETTE_OPACITY;
    highp float HSM_VIEWPORT_VIGNETTE_MASK_MODE;
    highp float HSM_VIEWPORT_VIGNETTE_CUTOUT_MODE;
    highp float HSM_VIEWPORT_VIGNETTE_FOLLOW_LAYER;
    highp float HSM_VIEWPORT_VIGNETTE_SCALE;
    highp float HSM_VIEWPORT_VIGNETTE_SCALE_X;
    highp float HSM_VIEWPORT_VIGNETTE_POS_X;
    highp float HSM_VIEWPORT_VIGNETTE_POS_Y;
    highp float HSM_LED_OPACITY;
    highp float HSM_LED_HUE;
    highp float HSM_LED_COLORIZE_ON;
    highp float HSM_LED_SATURATION;
    highp float HSM_LED_BRIGHTNESS;
    highp float HSM_LED_GAMMA;
    highp float HSM_LED_AMBIENT_LIGHTING_MULTIPLIER;
    highp float HSM_LED_AMBIENT2_LIGHTING_MULTIPLIER;
    highp float HSM_LED_APPLY_AMBIENT_IN_ADD_MODE;
    highp float HSM_LED_BLEND_MODE;
    highp float HSM_LED_SOURCE_MATTE_TYPE;
    highp float HSM_LED_MASK_MODE;
    highp float HSM_LED_CUTOUT_MODE;
    highp float HSM_LED_DUALSCREEN_VIS_MODE;
    highp float HSM_LED_FOLLOW_LAYER;
    highp float HSM_LED_FOLLOW_MODE;
    highp float HSM_LED_FOLLOW_FULL_USES_ZOOM;
    highp float HSM_LED_FILL_MODE;
    highp float HSM_LED_SPLIT_PRESERVE_CENTER;
    highp float HSM_LED_SPLIT_REPEAT_WIDTH;
    highp float HSM_LED_SCALE;
    highp float HSM_LED_SCALE_X;
    highp float HSM_LED_POS_X;
    highp float HSM_LED_POS_Y;
    highp float HSM_LED_MIPMAPPING_BLEND_BIAS;
    highp float HSM_DEVICE_OPACITY;
    highp float HSM_DEVICE_HUE;
    highp float HSM_DEVICE_COLORIZE_ON;
    highp float HSM_DEVICE_SATURATION;
    highp float HSM_DEVICE_BRIGHTNESS;
    highp float HSM_DEVICE_GAMMA;
    highp float HSM_DEVICE_AMBIENT_LIGHTING_MULTIPLIER;
    highp float HSM_DEVICE_AMBIENT2_LIGHTING_MULTIPLIER;
    highp float HSM_DEVICE_APPLY_AMBIENT_IN_ADD_MODE;
    highp float HSM_DEVICE_BLEND_MODE;
    highp float HSM_DEVICE_SOURCE_MATTE_TYPE;
    highp float HSM_DEVICE_MASK_MODE;
    highp float HSM_DEVICE_CUTOUT_MODE;
    highp float HSM_DEVICE_DUALSCREEN_VIS_MODE;
    highp float HSM_DEVICE_FOLLOW_LAYER;
    highp float HSM_DEVICE_FOLLOW_MODE;
    highp float HSM_DEVICE_FOLLOW_FULL_USES_ZOOM;
    highp float HSM_DEVICE_FILL_MODE;
    highp float HSM_DEVICE_SPLIT_PRESERVE_CENTER;
    highp float HSM_DEVICE_SPLIT_REPEAT_WIDTH;
    highp float HSM_DEVICE_SCALE;
    highp float HSM_DEVICE_SCALE_X;
    highp float HSM_DEVICE_POS_X;
    highp float HSM_DEVICE_POS_Y;
    highp float HSM_DEVICE_MIPMAPPING_BLEND_BIAS;
    highp float HSM_DEVICELED_OPACITY;
    highp float HSM_DEVICELED_HUE;
    highp float HSM_DEVICELED_COLORIZE_ON;
    highp float HSM_DEVICELED_SATURATION;
    highp float HSM_DEVICELED_BRIGHTNESS;
    highp float HSM_DEVICELED_GAMMA;
    highp float HSM_DEVICELED_AMBIENT_LIGHTING_MULTIPLIER;
    highp float HSM_DEVICELED_AMBIENT2_LIGHTING_MULTIPLIER;
    highp float HSM_DEVICELED_APPLY_AMBIENT_IN_ADD_MODE;
    highp float HSM_DEVICELED_BLEND_MODE;
    highp float HSM_DEVICELED_SOURCE_MATTE_TYPE;
    highp float HSM_DEVICELED_MASK_MODE;
    highp float HSM_DEVICELED_CUTOUT_MODE;
    highp float HSM_DEVICELED_DUALSCREEN_VIS_MODE;
    highp float HSM_DEVICELED_FOLLOW_LAYER;
    highp float HSM_DEVICELED_FOLLOW_MODE;
    highp float HSM_DEVICELED_FOLLOW_FULL_USES_ZOOM;
    highp float HSM_DEVICELED_FILL_MODE;
    highp float HSM_DEVICELED_SPLIT_PRESERVE_CENTER;
    highp float HSM_DEVICELED_SPLIT_REPEAT_WIDTH;
    highp float HSM_DEVICELED_SCALE;
    highp float HSM_DEVICELED_SCALE_X;
    highp float HSM_DEVICELED_POS_X;
    highp float HSM_DEVICELED_POS_Y;
    highp float HSM_DEVICELED_MIPMAPPING_BLEND_BIAS;
    highp float HSM_FRM_OPACITY;
    highp float HSM_FRM_BLEND_MODE;
    highp float HSM_FRM_TEXTURE_OPACITY;
    highp float HSM_FRM_TEXTURE_BLEND_MODE;
    highp float HSM_DECAL_OPACITY;
    highp float HSM_DECAL_HUE;
    highp float HSM_DECAL_COLORIZE_ON;
    highp float HSM_DECAL_SATURATION;
    highp float HSM_DECAL_BRIGHTNESS;
    highp float HSM_DECAL_GAMMA;
    highp float HSM_DECAL_AMBIENT_LIGHTING_MULTIPLIER;
    highp float HSM_DECAL_AMBIENT2_LIGHTING_MULTIPLIER;
    highp float HSM_DECAL_APPLY_AMBIENT_IN_ADD_MODE;
    highp float HSM_DECAL_BLEND_MODE;
    highp float HSM_DECAL_SOURCE_MATTE_TYPE;
    highp float HSM_DECAL_MASK_MODE;
    highp float HSM_DECAL_CUTOUT_MODE;
    highp float HSM_DECAL_DUALSCREEN_VIS_MODE;
    highp float HSM_DECAL_FOLLOW_LAYER;
    highp float HSM_DECAL_FOLLOW_MODE;
    highp float HSM_DECAL_FOLLOW_FULL_USES_ZOOM;
    highp float HSM_DECAL_FILL_MODE;
    highp float HSM_DECAL_SPLIT_PRESERVE_CENTER;
    highp float HSM_DECAL_SPLIT_REPEAT_WIDTH;
    highp float HSM_DECAL_SCALE;
    highp float HSM_DECAL_SCALE_X;
    highp float HSM_DECAL_POS_X;
    highp float HSM_DECAL_POS_Y;
    highp float HSM_DECAL_MIPMAPPING_BLEND_BIAS;
    highp float HSM_CAB_GLASS_OPACITY;
    highp float HSM_CAB_GLASS_HUE;
    highp float HSM_CAB_GLASS_COLORIZE_ON;
    highp float HSM_CAB_GLASS_SATURATION;
    highp float HSM_CAB_GLASS_BRIGHTNESS;
    highp float HSM_CAB_GLASS_GAMMA;
    highp float HSM_CAB_GLASS_AMBIENT_LIGHTING_MULTIPLIER;
    highp float HSM_CAB_GLASS_AMBIENT2_LIGHTING_MULTIPLIER;
    highp float HSM_CAB_GLASS_APPLY_AMBIENT_IN_ADD_MODE;
    highp float HSM_CAB_GLASS_BLEND_MODE;
    highp float HSM_CAB_GLASS_SOURCE_MATTE_TYPE;
    highp float HSM_CAB_GLASS_MASK_MODE;
    highp float HSM_CAB_GLASS_CUTOUT_MODE;
    highp float HSM_CAB_GLASS_DUALSCREEN_VIS_MODE;
    highp float HSM_CAB_GLASS_FOLLOW_LAYER;
    highp float HSM_CAB_GLASS_FOLLOW_MODE;
    highp float HSM_CAB_GLASS_FOLLOW_FULL_USES_ZOOM;
    highp float HSM_CAB_GLASS_FILL_MODE;
    highp float HSM_CAB_GLASS_SPLIT_PRESERVE_CENTER;
    highp float HSM_CAB_GLASS_SPLIT_REPEAT_WIDTH;
    highp float HSM_CAB_GLASS_SCALE;
    highp float HSM_CAB_GLASS_SCALE_X;
    highp float HSM_CAB_GLASS_POS_X;
    highp float HSM_CAB_GLASS_POS_Y;
    highp float HSM_CAB_GLASS_MIPMAPPING_BLEND_BIAS;
    highp float HSM_TOP_OPACITY;
    highp float HSM_TOP_HUE;
    highp float HSM_TOP_COLORIZE_ON;
    highp float HSM_TOP_SATURATION;
    highp float HSM_TOP_BRIGHTNESS;
    highp float HSM_TOP_GAMMA;
    highp float HSM_TOP_AMBIENT_LIGHTING_MULTIPLIER;
    highp float HSM_TOP_AMBIENT2_LIGHTING_MULTIPLIER;
    highp float HSM_TOP_APPLY_AMBIENT_IN_ADD_MODE;
    highp float HSM_TOP_BLEND_MODE;
    highp float HSM_TOP_SOURCE_MATTE_TYPE;
    highp float HSM_TOP_MASK_MODE;
    highp float HSM_TOP_CUTOUT_MODE;
    highp float HSM_TOP_DUALSCREEN_VIS_MODE;
    highp float HSM_TOP_FOLLOW_LAYER;
    highp float HSM_TOP_FOLLOW_MODE;
    highp float HSM_TOP_FOLLOW_FULL_USES_ZOOM;
    highp float HSM_TOP_FILL_MODE;
    highp float HSM_TOP_SPLIT_PRESERVE_CENTER;
    highp float HSM_TOP_SPLIT_REPEAT_WIDTH;
    highp float HSM_TOP_SCALE;
    highp float HSM_TOP_SCALE_X;
    highp float HSM_TOP_POS_X;
    highp float HSM_TOP_POS_Y;
    highp float HSM_TOP_MIRROR_WRAP;
    highp float HSM_TOP_MIPMAPPING_BLEND_BIAS;
    highp float HSM_RENDER_SIMPLE_MODE;
    highp float HSM_RENDER_SIMPLE_MASK_TYPE;
    highp float HSM_LAYERING_DEBUG_MASK_MODE;
    highp float HSM_INTRO_LOGO_BLEND_MODE;
    highp float HSM_INTRO_LOGO_FLIP_VERTICAL;
    highp float HSM_INTRO_NOISE_BLEND_MODE;
    highp float HSM_INTRO_NOISE_HOLD;
    highp float HSM_INTRO_NOISE_FADE_OUT;
    highp float HSM_INTRO_SOLID_BLACK_HOLD;
    highp float HSM_INTRO_SOLID_BLACK_FADE_OUT;
    highp float HSM_INTRO_SOLID_COLOR_BLEND_MODE;
    highp float HSM_INTRO_LOGO_OVER_SOLID_COLOR;
    highp float HSM_INTRO_LOGO_PLACEMENT;
    highp float HSM_INTRO_LOGO_HEIGHT;
    highp float HSM_INTRO_LOGO_POS_X;
    highp float HSM_INTRO_LOGO_POS_Y;
    highp float HSM_INTRO_WHEN_TO_SHOW;
    highp float HSM_INTRO_SPEED;
    highp float HSM_INTRO_LOGO_WAIT;
    highp float HSM_INTRO_LOGO_FADE_IN;
    highp float HSM_INTRO_LOGO_HOLD;
    highp float HSM_INTRO_LOGO_FADE_OUT;
    highp float HSM_INTRO_SOLID_COLOR_HUE;
    highp float HSM_INTRO_SOLID_COLOR_SAT;
    highp float HSM_INTRO_SOLID_COLOR_VALUE;
    highp float HSM_INTRO_SOLID_COLOR_HOLD;
    highp float HSM_INTRO_SOLID_COLOR_FADE_OUT;
    highp float GAMMA_INPUT;
    highp float gamma_out;
    highp float post_br;
    highp float post_br_affect_black_level;
    highp float m_glow;
    highp float m_glow_low;
    highp float m_glow_high;
    highp float m_glow_dist;
    highp float m_glow_mask;
    highp float smask_mit;
    highp float glow;
    highp float bloom;
    highp float mask_bloom;
    highp float bloom_dist;
    highp float halation;
    highp float TATE;
    highp float IOS;
    highp float GDV_RASTER_BLOOM_ON;
    highp float OS;
    highp float BLOOM;
    highp float GDV_OVERSCAN;
    highp float GDV_OVERSCAN_X;
    highp float GDV_OVERSCAN_Y;
    highp float overscanX;
    highp float overscanY;
    highp float intres;
    highp float prescalex;
    highp float c_shape;
    highp float sborder;
    highp float csize;
    highp float bsize1;
    highp float warpX;
    highp float warpY;
    highp float gamma_c;
    highp float brightboost;
    highp float brightboost1;
    highp float blendMode;
    highp float gsl;
    highp float scanline1;
    highp float scanline2;
    highp float beam_min;
    highp float beam_max;
    highp float beam_size;
    highp float vertmask;
    highp float scans;
    highp float scan_falloff;
    highp float spike;
    highp float ring;
    highp float no_scanlines;
    highp float scangamma;
    highp float rolling_scan;
    highp float h_sharp;
    highp float s_sharp;
    highp float smart_ei;
    highp float ei_limit;
    highp float sth;
    highp float barspeed;
    highp float barintensity;
    highp float bardir;
    highp float shadowMask;
    highp float maskstr;
    highp float mcut;
    highp float maskboost;
    highp float masksize;
    highp float masksizeautothreshold;
    highp float maskDark;
    highp float maskLight;
    highp float mask_gamma;
    highp float slotmask;
    highp float slotmask1;
    highp float slotwidth;
    highp float double_slot;
    highp float slotms;
    highp float mclip;
    highp float smoothmask;
    highp float mshift;
    highp float mask_layout;
    highp float GDV_DECONVERGENCE_ON;
    highp float decons;
    highp float deconrr;
    highp float deconrg;
    highp float deconrb;
    highp float deconrry;
    highp float deconrgy;
    highp float deconrby;
    highp float deconsmooth;
    highp float dctypex;
    highp float dctypey;
    highp float dcscalemode;
    highp float GDV_NOISE_ON;
    highp float addnoised;
    highp float noisetype;
    highp float noiseresd;
    highp float noiseresd4kmult;
    highp float g_grade_on;
    highp float wp_temperature;
    highp float g_satr;
    highp float g_satg;
    highp float g_satb;
    highp float AS;
    highp float asat;
    highp float hcrt_h_size;
    highp float hcrt_v_size;
    highp float hcrt_h_cent;
    highp float hcrt_v_cent;
    highp float hcrt_pin_phase;
    highp float hcrt_pin_amp;
} global;

layout(binding = 15) uniform highp sampler2D BR_LayersUnderCRTPassFeedback;
layout(binding = 1) uniform highp sampler2D InfoCachePass;
layout(binding = 4) uniform highp sampler2D NightLightingImage;
layout(binding = 5) uniform highp sampler2D NightLighting2Image;
layout(binding = 7) uniform highp sampler2D FrameTextureImage;
layout(binding = 3) uniform highp sampler2D BackgroundVertImage;
layout(binding = 2) uniform highp sampler2D BackgroundImage;
layout(binding = 9) uniform highp sampler2D DeviceVertImage;
layout(binding = 8) uniform highp sampler2D DeviceImage;
layout(binding = 10) uniform highp sampler2D DeviceLEDImage;
layout(binding = 6) uniform highp sampler2D LEDImage;
layout(binding = 11) uniform highp sampler2D DecalImage;
layout(binding = 13) uniform highp sampler2D TopLayerImage;
layout(binding = 12) uniform highp sampler2D CabinetGlassImage;
layout(binding = 14) uniform highp sampler2D ReflectionMaskImage;

layout(location = 6) in highp vec2 vTexCoord;
layout(location = 0) out highp vec4 FragColor;
layout(location = 7) in highp vec2 UNFLIPPED_VIEWPORT_COORD;
layout(location = 8) in highp vec3 BEZEL_FRAME_ORIGINAL_COLOR_RGB;
highp float FOLLOW_MODE_SCALE_AND_POS;
highp float FOLLOW_MODE_EXACT;
highp float NEGATIVE_CROP_EXPAND_MULTIPLIER;
highp float MAX_NEGATIVE_CROP;
highp float DEFAULT_SCREEN_ASPECT;
highp float DEFAULT_BEZEL_ASPECT;
highp vec2 DEFAULT_SCREEN_SCALE;
highp vec2 DEFAULT_BEZEL_SCALE;
int INFOCACHE_MAX_INDEX;
bool CACHE_INFO_CHANGED;
highp float CURRENT_FRAME_FROM_CACHE_INFO;
highp float TUBE_DIFFUSE_MASK;
highp float TUBE_MASK;
highp float BEZEL_MASK;
highp float INSIDE_BEZEL_MASK;
highp float OUTSIDE_TUBE_MASK_FOR_IMAGE;
highp float FRAME_MASK;
highp float FRAME_MASK_FOR_IMAGE;
highp float OUTSIDE_BEZEL_MASK;
highp float OUTSIDE_FRAME_MASK_FOR_IMAGE;
highp float OUTSIDE_FRAME_MASK;
highp float CUTOUT_MASK;
highp float SCREEN_INDEX;
highp float SCREEN_ASPECT;
highp vec2 SCREEN_SCALE;
highp vec2 SCREEN_SCALE_WITH_ZOOM;
highp vec2 SCREEN_POS_OFFSET;
highp vec2 SCREEN_SCALE_2ND_SCREEN;
highp vec2 SCREEN_POS_OFFSET_1ST_SCREEN;
highp vec2 SCREEN_POS_OFFSET_2ND_SCREEN;
highp vec2 VIEWPORT_SCALE;
highp vec2 VIEWPORT_POS;
highp vec2 TUBE_SCALE;
highp vec2 TUBE_DIFFUSE_SCALE;
highp float TUBE_DIFFUSE_ASPECT;
highp vec2 TUBE_DIFFUSE_SCALE_1ST_SCREEN;
highp vec2 TUBE_DIFFUSE_SCALE_2ND_SCREEN;
highp vec2 FRAME_SCALE;
highp vec2 BEZEL_OUTSIDE_SCALE;
highp vec2 BACKGROUND_SCALE;
highp vec2 LED_SCALE;
highp vec2 DEVICE_SCALE;
highp vec2 DEVICELED_SCALE;
highp vec2 DECAL_SCALE;
highp vec2 CAB_GLASS_SCALE;
highp vec2 TOP_IMAGE_SCALE;
highp float AVERAGE_LUMA;
highp float USE_VERTICAL_SCANLINES;
highp float SAMPLING_SCANLINE_DIR_MULT;
highp float SAMPLING_OPPOSITE_DIR_MULT;
highp vec2 CORE_SIZE;
highp vec2 ROTATED_CORE_ORIGINAL_SIZE;
highp vec2 ROTATED_CORE_PREPPED_SIZE;
highp vec2 ROTATED_DEREZED_SIZE;
highp vec2 CROPPED_ROTATED_SIZE_WITH_RES_MULT;
highp vec2 CROPPED_ROTATED_SIZE_WITH_RES_MULT_FEEDBACK;
highp vec2 CROPPED_ROTATED_SIZE;
highp vec2 SAMPLE_AREA_START_PIXEL_COORD;
highp vec2 SCREEN_SIZE;
highp vec2 VIEWPORT_UNSCALED_COORD;
highp vec2 SCREEN_COORD;
highp vec2 TUBE_COORD;
highp vec2 TUBE_DIFFUSE_COORD;
highp vec2 TUBE_DIFFUSE_COORD_MIXED_POS;
highp vec2 BEZEL_OUTSIDE_COORD;
highp vec2 BACKGROUND_COORD;
highp vec2 DEVICE_COORD;
highp vec2 DEVICELED_COORD;
highp vec2 LED_COORD;
highp vec2 DECAL_COORD;
highp vec2 CAB_GLASS_COORD;
highp vec2 TOP_IMAGE_COORD;
highp vec2 SCREEN_CURVED_COORD;
highp vec2 TUBE_CURVED_COORD;
highp vec2 TUBE_DIFFUSE_CURVED_COORD;
highp vec2 BEZEL_OUTSIDE_CURVED_COORD;
highp vec2 FRAME_OUTSIDE_CURVED_COORD;
highp vec2 BACKGROUND_CURVED_COORD;
highp vec2 LED_CURVED_COORD;
highp vec2 DEVICE_CURVED_COORD;
highp vec2 DEVICELED_CURVED_COORD;
highp vec2 DECAL_CURVED_COORD;
highp vec2 CAB_GLASS_CURVED_COORD;
highp vec2 TOP_IMAGE_CURVED_COORD;
highp float HSM_RESOLUTION_DEBUG_ON;
highp float HSM_GLOBAL_GRAPHICS_BRIGHTNESS;
highp float HSM_STATIC_LAYERS_GAMMA;
highp float HSM_AMBIENT_LIGHTING_OPACITY;
highp float HSM_AMBIENT1_OPACITY;
highp float HSM_AMBIENT2_OPACITY;
highp float HSM_AMBIENT_LIGHTING_SWAP_IMAGE_MODE;
highp float HSM_SINDEN_BORDER_ON;
highp float HSM_SINDEN_BORDER_BRIGHTNESS;
highp float HSM_SINDEN_BORDER_THICKNESS;
highp float HSM_SINDEN_BORDER_EMPTY_TUBE_COMPENSATION;
highp float HSM_VIEWPORT_ZOOM;
highp float HSM_VIEWPORT_ZOOM_MASK;
highp float HSM_VIEWPORT_POSITION_X;
highp float HSM_VIEWPORT_POSITION_Y;
highp float HSM_FLIP_VIEWPORT_VERTICAL;
highp float HSM_FLIP_VIEWPORT_HORIZONTAL;
highp float HSM_FLIP_CORE_VERTICAL;
highp float HSM_FLIP_CORE_HORIZONTAL;
highp float HSM_ROTATE_CORE_IMAGE;
highp float HSM_ASPECT_RATIO_ORIENTATION;
highp float HSM_ASPECT_RATIO_MODE;
highp float HSM_ASPECT_RATIO_EXPLICIT;
highp float HSM_VERTICAL_PRESET;
highp float HSM_INT_SCALE_MAX_HEIGHT;
highp float HSM_NON_INTEGER_SCALE;
highp float HSM_USE_PHYSICAL_SIZE_FOR_NON_INTEGER;
highp float HSM_PHYSICAL_MONITOR_ASPECT_RATIO;
highp float HSM_PHYSICAL_MONITOR_DIAGONAL_SIZE;
highp float HSM_PHYSICAL_SIM_TUBE_DIAGONAL_SIZE;
highp float HSM_USE_IMAGE_FOR_PLACEMENT;
highp float HSM_PLACEMENT_IMAGE_USE_HORIZONTAL;
highp float HSM_PLACEMENT_IMAGE_MODE;
highp float HSM_NON_INTEGER_SCALE_OFFSET;
highp float HSM_USE_SNAP_TO_CLOSEST_INT_SCALE;
highp float HSM_SNAP_TO_CLOSEST_INT_SCALE_TOLERANCE;
highp float HSM_SCREEN_POSITION_X;
highp float HSM_SCREEN_POSITION_Y;
highp float HSM_CROP_MODE;
highp float HSM_CROP_PERCENT_ZOOM;
highp float HSM_CROP_PERCENT_TOP;
highp float HSM_CROP_PERCENT_BOTTOM;
highp float HSM_CROP_PERCENT_LEFT;
highp float HSM_CROP_PERCENT_RIGHT;
highp float HSM_CROP_BLACK_THRESHOLD;
highp float HSM_SCANLINE_DIRECTION;
highp float HSM_CORE_RES_SAMPLING_MULT_SCANLINE_DIR;
highp float HSM_DOWNSAMPLE_BLUR_SCANLINE_DIR;
highp float HSM_CORE_RES_SAMPLING_MULT_OPPOSITE_DIR;
highp float HSM_DOWNSAMPLE_BLUR_OPPOSITE_DIR;
highp float HSM_USE_GEOM;
highp float HSM_CURVATURE_MODE;
highp float HSM_CURVATURE_3D_RADIUS;
highp float HSM_CURVATURE_3D_VIEW_DIST;
highp float HSM_CURVATURE_3D_TILT_ANGLE_X;
highp float HSM_CURVATURE_3D_TILT_ANGLE_Y;
highp float HSM_CRT_CURVATURE_SCALE;
highp float HSM_CACHE_GRAPHICS_ON;
highp float HSM_CACHE_UPDATE_INDICATOR_MODE;
highp float HSM_AB_COMPARE_SHOW_MODE;
highp float HSM_AB_COMPARE_AREA;
highp float HSM_AB_COMPARE_SPLIT_POSITION;
highp float HSM_AB_COMPARE_FREEZE_CRT_TUBE;
highp float HSM_AB_COMPARE_FREEZE_GRAPHICS;
highp float HSM_SHOW_PASS_INDEX;
highp float HSM_SHOW_PASS_APPLY_SCREEN_COORD;
highp float HSM_SHOW_PASS_ALPHA;
highp float HSM_SCREEN_VIGNETTE_DUALSCREEN_VIS_MODE;
highp float HSM_MONOCHROME_DUALSCREEN_VIS_MODE;
highp float HSM_TUBE_DIFFUSE_MODE;
highp float HSM_TUBE_DIFFUSE_IMAGE_AMOUNT;
highp float HSM_TUBE_DIFFUSE_IMAGE_DUALSCREEN_VIS_MODE;
highp float HSM_TUBE_DIFFUSE_IMAGE_COLORIZE_ON;
highp float HSM_TUBE_DIFFUSE_IMAGE_HUE;
highp float HSM_TUBE_DIFFUSE_IMAGE_SATURATION;
highp float HSM_TUBE_DIFFUSE_IMAGE_BRIGHTNESS;
highp float HSM_TUBE_DIFFUSE_IMAGE_GAMMA;
highp float HSM_TUBE_DIFFUSE_IMAGE_AMBIENT_LIGHTING;
highp float HSM_TUBE_DIFFUSE_IMAGE_AMBIENT2_LIGHTING;
highp float HSM_TUBE_DIFFUSE_IMAGE_SCALE;
highp float HSM_TUBE_DIFFUSE_IMAGE_SCALE_X;
highp float HSM_TUBE_DIFFUSE_IMAGE_ROTATION;
highp float HSM_TUBE_SHADOW_IMAGE_ON;
highp float HSM_TUBE_SHADOW_IMAGE_OPACITY;
highp float HSM_TUBE_SHADOW_IMAGE_POS_X;
highp float HSM_TUBE_SHADOW_IMAGE_POS_Y;
highp float HSM_TUBE_SHADOW_IMAGE_SCALE_X;
highp float HSM_TUBE_SHADOW_IMAGE_SCALE_Y;
highp float HSM_TUBE_SHADOW_CURVATURE_SCALE;
highp float HSM_TUBE_STATIC_REFLECTION_IMAGE_ON;
highp float HSM_TUBE_STATIC_REFLECTION_IMAGE_DUALSCREEN_VIS_MODE;
highp float HSM_TUBE_STATIC_REFLECTION_IMAGE_OPACITY;
highp float HSM_TUBE_STATIC_OPACITY_DIFFUSE_MULTIPLY;
highp float HSM_TUBE_STATIC_BLACK_LEVEL;
highp float HSM_TUBE_STATIC_AMBIENT_LIGHTING;
highp float HSM_TUBE_STATIC_AMBIENT2_LIGHTING;
highp float HSM_TUBE_STATIC_SCALE;
highp float HSM_TUBE_STATIC_SCALE_X;
highp float HSM_TUBE_STATIC_POS_X;
highp float HSM_TUBE_STATIC_POS_Y;
highp float HSM_TUBE_STATIC_SHADOW_OPACITY;
highp float HSM_TUBE_STATIC_DITHER_SAMPLES;
highp float HSM_TUBE_STATIC_DITHER_DISTANCE;
highp float HSM_TUBE_STATIC_DITHER_AMOUNT;
highp float HSM_TUBE_OPACITY;
highp float HSM_TUBE_COLORED_GEL_IMAGE_ON;
highp float HSM_TUBE_COLORED_GEL_IMAGE_SCALE;
highp float HSM_TUBE_COLORED_GEL_IMAGE_FLIP_HORIZONTAL;
highp float HSM_TUBE_COLORED_GEL_IMAGE_FLIP_VERTICAL;
highp float HSM_TUBE_COLORED_GEL_IMAGE_DUALSCREEN_VIS_MODE;
highp float HSM_TUBE_COLORED_GEL_IMAGE_MULTIPLY_AMOUNT;
highp float HSM_TUBE_COLORED_GEL_IMAGE_ADDITIVE_AMOUNT;
highp float HSM_TUBE_COLORED_GEL_IMAGE_NORMAL_AMOUNT;
highp float HSM_TUBE_COLORED_GEL_IMAGE_TRANSPARENCY_THRESHOLD;
highp float HSM_TUBE_COLORED_GEL_IMAGE_NORMAL_BRIGHTNESS;
highp float HSM_TUBE_COLORED_GEL_IMAGE_NORMAL_VIGNETTE;
highp float HSM_TUBE_COLORED_GEL_IMAGE_FAKE_SCANLINE_AMOUNT;
highp float HSM_TUBE_COLORED_GEL_IMAGE_AMBIENT_LIGHTING;
highp float HSM_TUBE_COLORED_GEL_IMAGE_AMBIENT2_LIGHTING;
highp float HSM_SHOW_CRT_ON_TOP_OF_COLORED_GEL;
highp float HSM_DUALSCREEN_MODE;
highp float HSM_DUALSCREEN_CORE_IMAGE_SPLIT_MODE;
highp float HSM_DUALSCREEN_CORE_IMAGE_SWAP_SCREENS;
highp float HSM_DUALSCREEN_CORE_IMAGE_SPLIT_OFFSET;
highp float HSM_DUALSCREEN_VIEWPORT_SPLIT_LOCATION;
highp float HSM_DUALSCREEN_SHIFT_POSITION_WITH_SCALE;
highp float HSM_DUALSCREEN_POSITION_OFFSET_BETWEEN_SCREENS;
highp float HSM_2ND_SCREEN_ASPECT_RATIO_MODE;
highp float HSM_2ND_SCREEN_INDEPENDENT_SCALE;
highp float HSM_2ND_SCREEN_SCALE_OFFSET;
highp float HSM_2ND_SCREEN_POS_X;
highp float HSM_2ND_SCREEN_POS_Y;
highp float HSM_2ND_SCREEN_CROP_PERCENT_ZOOM;
highp float HSM_2ND_SCREEN_CROP_PERCENT_TOP;
highp float HSM_2ND_SCREEN_CROP_PERCENT_BOTTOM;
highp float HSM_2ND_SCREEN_CROP_PERCENT_LEFT;
highp float HSM_2ND_SCREEN_CROP_PERCENT_RIGHT;
highp float HSM_SCREEN_REFLECTION_SCALE;
highp float HSM_SCREEN_REFLECTION_POS_X;
highp float HSM_SCREEN_REFLECTION_POS_Y;
highp float HSM_AMBIENT1_HUE;
highp float HSM_AMBIENT1_SATURATION;
highp float HSM_AMBIENT1_VALUE;
highp float HSM_AMBIENT1_CONTRAST;
highp float HSM_AMBIENT1_SCALE_KEEP_ASPECT;
highp float HSM_AMBIENT1_SCALE_INHERIT_MODE;
highp float HSM_AMBIENT1_SCALE;
highp float HSM_AMBIENT1_SCALE_X;
highp float HSM_AMBIENT1_ROTATE;
highp float HSM_AMBIENT1_MIRROR_HORZ;
highp float HSM_AMBIENT1_POS_INHERIT_MODE;
highp float HSM_AMBIENT1_POSITION_X;
highp float HSM_AMBIENT1_POSITION_Y;
highp float HSM_AMBIENT1_DITHERING_SAMPLES;
highp float HSM_AMBIENT2_HUE;
highp float HSM_AMBIENT2_SATURATION;
highp float HSM_AMBIENT2_VALUE;
highp float HSM_AMBIENT2_CONTRAST;
highp float HSM_AMBIENT2_SCALE_KEEP_ASPECT;
highp float HSM_AMBIENT2_SCALE_INHERIT_MODE;
highp float HSM_AMBIENT2_SCALE;
highp float HSM_AMBIENT2_SCALE_X;
highp float HSM_AMBIENT2_ROTATE;
highp float HSM_AMBIENT2_MIRROR_HORZ;
highp float HSM_AMBIENT2_POS_INHERIT_MODE;
highp float HSM_AMBIENT2_POSITION_X;
highp float HSM_AMBIENT2_POSITION_Y;
highp float HSM_BZL_OPACITY;
highp float HSM_BZL_BLEND_MODE;
highp float HSM_BZL_WIDTH;
highp float HSM_BZL_HEIGHT;
highp float HSM_BZL_INNER_CORNER_RADIUS_SCALE;
highp float HSM_BZL_INNER_EDGE_THICKNESS;
highp float HSM_BZL_INNER_EDGE_SHARPNESS;
highp float HSM_BZL_OUTER_POSITION_Y;
highp float HSM_BZL_OUTER_CURVATURE_SCALE;
highp float HSM_BZL_OUTER_CORNER_RADIUS_SCALE;
highp float HSM_BZL_NOISE;
highp float HSM_BZL_INNER_EDGE_SHADOW;
highp float HSM_BZL_BRIGHTNESS;
highp float HSM_BZL_BRIGHTNESS_MULT_TOP;
highp float HSM_BZL_BRIGHTNESS_MULT_BOTTOM;
highp float HSM_BZL_BRIGHTNESS_MULT_SIDES;
highp float HSM_BZL_BRIGHTNESS_MULT_SIDE_LEFT;
highp float HSM_BZL_BRIGHTNESS_MULT_SIDE_RIGHT;
highp float HSM_BZL_HIGHLIGHT;
highp float HSM_BZL_COLOR_HUE;
highp float HSM_BZL_COLOR_SATURATION;
highp float HSM_BZL_COLOR_VALUE;
highp float HSM_BZL_AMBIENT_LIGHTING_MULTIPLIER;
highp float HSM_BZL_AMBIENT2_LIGHTING_MULTIPLIER;
highp float HSM_FRM_USE_INDEPENDENT_COLOR;
highp float HSM_FRM_COLOR_HUE;
highp float HSM_FRM_COLOR_SATURATION;
highp float HSM_FRM_COLOR_VALUE;
highp float HSM_FRM_OPACITY;
highp float HSM_FRM_BLEND_MODE;
highp float HSM_FRM_TEXTURE_OPACITY;
highp float HSM_FRM_TEXTURE_BLEND_MODE;
highp float HSM_FRM_NOISE;
highp float HSM_FRM_INNER_EDGE_THICKNESS;
highp float HSM_FRM_THICKNESS;
highp float HSM_FRM_THICKNESS_SCALE_X;
highp float HSM_FRM_OUTER_POS_Y;
highp float HSM_FRM_OUTER_CURVATURE_SCALE;
highp float HSM_FRM_OUTER_CORNER_RADIUS;
highp float HSM_FRM_OUTER_EDGE_THICKNESS;
highp float HSM_FRM_OUTER_EDGE_SHADING;
highp float HSM_FRM_SHADOW_OPACITY;
highp float HSM_FRM_SHADOW_WIDTH;
highp float HSM_REFLECT_CORNER_FADE;
highp float HSM_REFLECT_CORNER_FADE_DISTANCE;
highp float HSM_REFLECT_CORNER_INNER_SPREAD;
highp float HSM_REFLECT_CORNER_OUTER_SPREAD;
highp float HSM_REFLECT_CORNER_ROTATION_OFFSET_TOP;
highp float HSM_REFLECT_CORNER_ROTATION_OFFSET_BOTTOM;
highp float HSM_REFLECT_CORNER_SPREAD_FALLOFF;
highp float HSM_BG_LAYER_ORDER;
highp float HSM_VIEWPORT_VIGNETTE_LAYER_ORDER;
highp float HSM_LED_LAYER_ORDER;
highp float HSM_DEVICE_LAYER_ORDER;
highp float HSM_DEVICELED_LAYER_ORDER;
highp float HSM_CRT_LAYER_ORDER;
highp float HSM_DECAL_LAYER_ORDER;
highp float HSM_CAB_GLASS_LAYER_ORDER;
highp float HSM_TOP_LAYER_ORDER;
highp float HSM_CUTOUT_ASPECT_MODE;
highp float HSM_CUTOUT_EXPLICIT_ASPECT;
highp float HSM_CUTOUT_FOLLOW_LAYER;
highp float HSM_CUTOUT_FOLLOW_FULL_USES_ZOOM;
highp float HSM_CUTOUT_SCALE;
highp float HSM_CUTOUT_SCALE_X;
highp float HSM_CUTOUT_POS_X;
highp float HSM_CUTOUT_POS_Y;
highp float HSM_CUTOUT_CORNER_RADIUS;
highp float HSM_LAYERING_DEBUG_MASK_MODE;
highp float HSM_BG_OPACITY;
highp float HSM_BG_COLORIZE_ON;
highp float HSM_BG_HUE;
highp float HSM_BG_SATURATION;
highp float HSM_BG_BRIGHTNESS;
highp float HSM_BG_GAMMA;
highp float HSM_BG_AMBIENT_LIGHTING_MULTIPLIER;
highp float HSM_BG_AMBIENT2_LIGHTING_MULTIPLIER;
highp float HSM_BG_APPLY_AMBIENT_IN_ADD_MODE;
highp float HSM_BG_BLEND_MODE;
highp float HSM_BG_SOURCE_MATTE_TYPE;
highp float HSM_BG_MIPMAPPING_BLEND_BIAS;
highp float HSM_BG_MASK_MODE;
highp float HSM_BG_CUTOUT_MODE;
highp float HSM_BG_DUALSCREEN_VIS_MODE;
highp float HSM_BG_FOLLOW_LAYER;
highp float HSM_BG_FOLLOW_MODE;
highp float HSM_BG_FOLLOW_FULL_USES_ZOOM;
highp float HSM_BG_FILL_MODE;
highp float HSM_BG_SPLIT_PRESERVE_CENTER;
highp float HSM_BG_SPLIT_REPEAT_WIDTH;
highp float HSM_BG_SCALE;
highp float HSM_BG_SCALE_X;
highp float HSM_BG_POS_X;
highp float HSM_BG_POS_Y;
highp float HSM_BG_WRAP_MODE;
highp float HSM_VIEWPORT_VIGNETTE_OPACITY;
highp float HSM_VIEWPORT_VIGNETTE_MASK_MODE;
highp float HSM_VIEWPORT_VIGNETTE_CUTOUT_MODE;
highp float HSM_VIEWPORT_VIGNETTE_FOLLOW_LAYER;
highp float HSM_VIEWPORT_VIGNETTE_SCALE;
highp float HSM_VIEWPORT_VIGNETTE_SCALE_X;
highp float HSM_VIEWPORT_VIGNETTE_POS_X;
highp float HSM_VIEWPORT_VIGNETTE_POS_Y;
highp float HSM_LED_OPACITY;
highp float HSM_LED_COLORIZE_ON;
highp float HSM_LED_HUE;
highp float HSM_LED_SATURATION;
highp float HSM_LED_BRIGHTNESS;
highp float HSM_LED_GAMMA;
highp float HSM_LED_AMBIENT_LIGHTING_MULTIPLIER;
highp float HSM_LED_AMBIENT2_LIGHTING_MULTIPLIER;
highp float HSM_LED_APPLY_AMBIENT_IN_ADD_MODE;
highp float HSM_LED_BLEND_MODE;
highp float HSM_LED_SOURCE_MATTE_TYPE;
highp float HSM_LED_MASK_MODE;
highp float HSM_LED_MIPMAPPING_BLEND_BIAS;
highp float HSM_LED_CUTOUT_MODE;
highp float HSM_LED_DUALSCREEN_VIS_MODE;
highp float HSM_LED_FOLLOW_LAYER;
highp float HSM_LED_FOLLOW_MODE;
highp float HSM_LED_FOLLOW_FULL_USES_ZOOM;
highp float HSM_LED_FILL_MODE;
highp float HSM_LED_SPLIT_PRESERVE_CENTER;
highp float HSM_LED_SPLIT_REPEAT_WIDTH;
highp float HSM_LED_SCALE;
highp float HSM_LED_SCALE_X;
highp float HSM_LED_POS_X;
highp float HSM_LED_POS_Y;
highp float HSM_DEVICE_OPACITY;
highp float HSM_DEVICE_COLORIZE_ON;
highp float HSM_DEVICE_HUE;
highp float HSM_DEVICE_SATURATION;
highp float HSM_DEVICE_BRIGHTNESS;
highp float HSM_DEVICE_GAMMA;
highp float HSM_DEVICE_AMBIENT_LIGHTING_MULTIPLIER;
highp float HSM_DEVICE_AMBIENT2_LIGHTING_MULTIPLIER;
highp float HSM_DEVICE_APPLY_AMBIENT_IN_ADD_MODE;
highp float HSM_DEVICE_BLEND_MODE;
highp float HSM_DEVICE_SOURCE_MATTE_TYPE;
highp float HSM_DEVICE_MASK_MODE;
highp float HSM_DEVICE_MIPMAPPING_BLEND_BIAS;
highp float HSM_DEVICE_CUTOUT_MODE;
highp float HSM_DEVICE_DUALSCREEN_VIS_MODE;
highp float HSM_DEVICE_FOLLOW_LAYER;
highp float HSM_DEVICE_FOLLOW_MODE;
highp float HSM_DEVICE_FOLLOW_FULL_USES_ZOOM;
highp float HSM_DEVICE_FILL_MODE;
highp float HSM_DEVICE_SPLIT_PRESERVE_CENTER;
highp float HSM_DEVICE_SPLIT_REPEAT_WIDTH;
highp float HSM_DEVICE_SCALE;
highp float HSM_DEVICE_SCALE_X;
highp float HSM_DEVICE_POS_X;
highp float HSM_DEVICE_POS_Y;
highp float HSM_DEVICELED_OPACITY;
highp float HSM_DEVICELED_COLORIZE_ON;
highp float HSM_DEVICELED_HUE;
highp float HSM_DEVICELED_SATURATION;
highp float HSM_DEVICELED_BRIGHTNESS;
highp float HSM_DEVICELED_GAMMA;
highp float HSM_DEVICELED_AMBIENT_LIGHTING_MULTIPLIER;
highp float HSM_DEVICELED_AMBIENT2_LIGHTING_MULTIPLIER;
highp float HSM_DEVICELED_APPLY_AMBIENT_IN_ADD_MODE;
highp float HSM_DEVICELED_BLEND_MODE;
highp float HSM_DEVICELED_SOURCE_MATTE_TYPE;
highp float HSM_DEVICELED_MASK_MODE;
highp float HSM_DEVICELED_MIPMAPPING_BLEND_BIAS;
highp float HSM_DEVICELED_CUTOUT_MODE;
highp float HSM_DEVICELED_DUALSCREEN_VIS_MODE;
highp float HSM_DEVICELED_FOLLOW_LAYER;
highp float HSM_DEVICELED_FOLLOW_MODE;
highp float HSM_DEVICELED_FOLLOW_FULL_USES_ZOOM;
highp float HSM_DEVICELED_FILL_MODE;
highp float HSM_DEVICELED_SPLIT_PRESERVE_CENTER;
highp float HSM_DEVICELED_SPLIT_REPEAT_WIDTH;
highp float HSM_DEVICELED_SCALE;
highp float HSM_DEVICELED_SCALE_X;
highp float HSM_DEVICELED_POS_X;
highp float HSM_DEVICELED_POS_Y;
highp float HSM_DECAL_OPACITY;
highp float HSM_DECAL_COLORIZE_ON;
highp float HSM_DECAL_HUE;
highp float HSM_DECAL_SATURATION;
highp float HSM_DECAL_BRIGHTNESS;
highp float HSM_DECAL_GAMMA;
highp float HSM_DECAL_AMBIENT_LIGHTING_MULTIPLIER;
highp float HSM_DECAL_AMBIENT2_LIGHTING_MULTIPLIER;
highp float HSM_DECAL_APPLY_AMBIENT_IN_ADD_MODE;
highp float HSM_DECAL_BLEND_MODE;
highp float HSM_DECAL_SOURCE_MATTE_TYPE;
highp float HSM_DECAL_MIPMAPPING_BLEND_BIAS;
highp float HSM_DECAL_MASK_MODE;
highp float HSM_DECAL_CUTOUT_MODE;
highp float HSM_DECAL_DUALSCREEN_VIS_MODE;
highp float HSM_DECAL_FOLLOW_LAYER;
highp float HSM_DECAL_FOLLOW_MODE;
highp float HSM_DECAL_FOLLOW_FULL_USES_ZOOM;
highp float HSM_DECAL_FILL_MODE;
highp float HSM_DECAL_SPLIT_PRESERVE_CENTER;
highp float HSM_DECAL_SPLIT_REPEAT_WIDTH;
highp float HSM_DECAL_SCALE;
highp float HSM_DECAL_SCALE_X;
highp float HSM_DECAL_POS_X;
highp float HSM_DECAL_POS_Y;
highp float HSM_CAB_GLASS_OPACITY;
highp float HSM_CAB_GLASS_COLORIZE_ON;
highp float HSM_CAB_GLASS_HUE;
highp float HSM_CAB_GLASS_SATURATION;
highp float HSM_CAB_GLASS_BRIGHTNESS;
highp float HSM_CAB_GLASS_GAMMA;
highp float HSM_CAB_GLASS_AMBIENT_LIGHTING_MULTIPLIER;
highp float HSM_CAB_GLASS_AMBIENT2_LIGHTING_MULTIPLIER;
highp float HSM_CAB_GLASS_APPLY_AMBIENT_IN_ADD_MODE;
highp float HSM_CAB_GLASS_BLEND_MODE;
highp float HSM_CAB_GLASS_SOURCE_MATTE_TYPE;
highp float HSM_CAB_GLASS_MIPMAPPING_BLEND_BIAS;
highp float HSM_CAB_GLASS_MASK_MODE;
highp float HSM_CAB_GLASS_CUTOUT_MODE;
highp float HSM_CAB_GLASS_DUALSCREEN_VIS_MODE;
highp float HSM_CAB_GLASS_FOLLOW_LAYER;
highp float HSM_CAB_GLASS_FOLLOW_MODE;
highp float HSM_CAB_GLASS_FOLLOW_FULL_USES_ZOOM;
highp float HSM_CAB_GLASS_FILL_MODE;
highp float HSM_CAB_GLASS_SPLIT_PRESERVE_CENTER;
highp float HSM_CAB_GLASS_SPLIT_REPEAT_WIDTH;
highp float HSM_CAB_GLASS_SCALE;
highp float HSM_CAB_GLASS_SCALE_X;
highp float HSM_CAB_GLASS_POS_X;
highp float HSM_CAB_GLASS_POS_Y;
highp float HSM_TOP_OPACITY;
highp float HSM_TOP_COLORIZE_ON;
highp float HSM_TOP_HUE;
highp float HSM_TOP_SATURATION;
highp float HSM_TOP_BRIGHTNESS;
highp float HSM_TOP_GAMMA;
highp float HSM_TOP_AMBIENT_LIGHTING_MULTIPLIER;
highp float HSM_TOP_AMBIENT2_LIGHTING_MULTIPLIER;
highp float HSM_TOP_APPLY_AMBIENT_IN_ADD_MODE;
highp float HSM_TOP_BLEND_MODE;
highp float HSM_TOP_SOURCE_MATTE_TYPE;
highp float HSM_TOP_MIPMAPPING_BLEND_BIAS;
highp float HSM_TOP_MASK_MODE;
highp float HSM_TOP_CUTOUT_MODE;
highp float HSM_TOP_DUALSCREEN_VIS_MODE;
highp float HSM_TOP_FOLLOW_LAYER;
highp float HSM_TOP_FOLLOW_MODE;
highp float HSM_TOP_FOLLOW_FULL_USES_ZOOM;
highp float HSM_TOP_FILL_MODE;
highp float HSM_TOP_SPLIT_PRESERVE_CENTER;
highp float HSM_TOP_SPLIT_REPEAT_WIDTH;
highp float HSM_TOP_SCALE;
highp float HSM_TOP_SCALE_X;
highp float HSM_TOP_POS_X;
highp float HSM_TOP_POS_Y;
highp float HSM_TOP_MIRROR_WRAP;
highp float HSM_RENDER_SIMPLE_MODE;
highp float HSM_RENDER_SIMPLE_MASK_TYPE;
highp float SOURCE_MATTE_PREMULTIPLIED;
highp float SOURCE_MATTE_WHITE;
highp float SOURCE_MATTE_NONE;
highp float BLEND_MODE_OFF;
highp float BLEND_MODE_NORMAL;
highp float BLEND_MODE_ADD;
highp float BLEND_MODE_MULTIPLY;
highp float CURVATURE_MODE_OFF;
highp float CURVATURE_MODE_2D;
highp float CURVATURE_MODE_2D_CYLINDER;
highp float CURVATURE_MODE_3D_1;
highp float CURVATURE_MODE_3D_2;
highp float CURVATURE_MODE_3D_CYLINDER;
highp float MAX_LAYER_ORDER;
highp float FILL_MODE_KEEP_TEXTURE_ASPECT;
highp float FILL_MODE_SPLIT;
highp float FILL_MODE_STRETCH;
highp float USE_INHERITED_COORD_OFF;
highp float USE_INHERITED_COORD_ON;
highp vec2 VIEWPORT_COORD;

bool HSM_GetIsInABCompareArea(highp vec2 viewport_coord)
{
    highp float _6093;
    if (HSM_AB_COMPARE_AREA > 1.5)
    {
        _6093 = viewport_coord.y;
    }
    else
    {
        _6093 = viewport_coord.x;
    }
    highp float test_value = _6093;
    highp float _6106;
    if (mod(HSM_AB_COMPARE_AREA, 2.0) == 1.0)
    {
        _6106 = 1.0 - HSM_AB_COMPARE_SPLIT_POSITION;
    }
    else
    {
        _6106 = HSM_AB_COMPARE_SPLIT_POSITION;
    }
    highp float position = _6106;
    bool _6120 = (mod(HSM_AB_COMPARE_AREA, 2.0) == 0.0) && (test_value < position);
    bool _6131;
    if (!_6120)
    {
        _6131 = (mod(HSM_AB_COMPARE_AREA, 2.0) == 1.0) && (test_value > position);
    }
    else
    {
        _6131 = _6120;
    }
    return _6131;
}

highp vec2 HSM_GetViewportCoordWithFlip(highp vec2 viewport_coord)
{
    highp vec2 out_coord = viewport_coord;
    if (HSM_FLIP_VIEWPORT_VERTICAL == (-1.0))
    {
        out_coord.y = 1.0 - out_coord.y;
    }
    if (HSM_FLIP_VIEWPORT_HORIZONTAL == (-1.0))
    {
        out_coord.x = 1.0 - out_coord.x;
    }
    return out_coord;
}

highp vec2 HSM_GetViewportCoordWithZoomAndPan(highp vec2 viewport_coord)
{
    highp vec2 param = viewport_coord;
    highp vec2 out_coord = HSM_GetViewportCoordWithFlip(param);
    out_coord = ((out_coord - vec2(0.5)) / vec2(HSM_VIEWPORT_ZOOM)) + vec2(0.5);
    out_coord.x += HSM_VIEWPORT_POSITION_X;
    out_coord.y -= HSM_VIEWPORT_POSITION_Y;
    return out_coord;
}

highp float HSM_GetScreenIndex(highp vec2 viewport_coord)
{
    highp float out_index = 1.0;
    highp float output_aspect = global.FinalViewportSize.x / global.FinalViewportSize.y;
    if (HSM_DUALSCREEN_MODE == 0.0)
    {
        out_index = 1.0;
    }
    if (HSM_DUALSCREEN_MODE == 1.0)
    {
        out_index = float((viewport_coord.y < (0.5 + (HSM_DUALSCREEN_VIEWPORT_SPLIT_LOCATION / output_aspect))) ? 1 : 2);
    }
    if (HSM_DUALSCREEN_MODE == 2.0)
    {
        out_index = float((viewport_coord.x < (0.5 + (HSM_DUALSCREEN_VIEWPORT_SPLIT_LOCATION / output_aspect))) ? 1 : 2);
    }
    return out_index;
}

highp vec4 HSM_GetCacheSampleRange(highp float column_index, highp float row_index)
{
    highp float num_rows = 8.0;
    highp float num_columns = 8.0;
    highp float range_width = 1.0 / num_columns;
    highp float range_height = 1.0 / num_rows;
    highp float zero_based_row_index = row_index - 1.0;
    highp float zero_based_column_index = column_index - 1.0;
    highp vec4 out_sample_range = vec4(0.0);
    out_sample_range.x = zero_based_column_index * range_width;
    out_sample_range.y = zero_based_row_index * range_height;
    out_sample_range.z = out_sample_range.x + range_width;
    out_sample_range.w = out_sample_range.y + range_height;
    return out_sample_range;
}

highp vec2 HSM_GetCacheSampleCoord(highp float column_index, highp float row_index)
{
    highp float num_rows = 8.0;
    highp float num_columns = 8.0;
    highp float range_width = 1.0 / num_columns;
    highp float range_height = 1.0 / num_rows;
    highp float param = column_index;
    highp float param_1 = row_index;
    highp vec4 sample_range = HSM_GetCacheSampleRange(param, param_1);
    return vec2(sample_range.x + (range_width / 2.0), sample_range.y + (range_height / 2.0));
}

highp vec2 HSM_GetCoordWithPositionOffset(highp vec2 in_coord, highp vec2 position_offset)
{
    return in_coord - position_offset;
}

highp vec2 HSM_GetInverseScaledCoord(highp vec2 in_coord, highp vec2 in_scale)
{
    highp vec2 middle = vec2(0.499989986419677734375);
    highp vec2 diff = in_coord - middle;
    highp vec2 screen_inverse_scale = vec2(1.0) / in_scale;
    highp vec2 scaled_coord = middle + (diff * screen_inverse_scale);
    return scaled_coord;
}

highp vec2 HSM_GetVTexCoordWithArgs(highp vec2 in_coord, highp vec2 in_scale, highp vec2 position_offset)
{
    highp vec2 param = in_coord;
    highp vec2 param_1 = position_offset;
    highp vec2 param_2 = HSM_GetCoordWithPositionOffset(param, param_1);
    highp vec2 param_3 = in_scale;
    return HSM_GetInverseScaledCoord(param_2, param_3);
}

highp vec4 HSM_UpdateGlobalScreenValuesFromCache(highp sampler2D in_cache_pass, highp vec2 vTexCoord_1)
{
    highp float output_aspect = global.FinalViewportSize.x / global.FinalViewportSize.y;
    highp vec2 param = vTexCoord_1;
    highp vec2 flipped_viewport_coord = HSM_GetViewportCoordWithZoomAndPan(param);
    highp vec2 param_1 = flipped_viewport_coord;
    SCREEN_INDEX = HSM_GetScreenIndex(param_1);
    highp vec2 sample_coord = vec2(0.0);
    highp vec4 texture_sample = vec4(0.0);
    highp float param_2 = 1.0;
    highp float param_3 = 1.0;
    sample_coord = HSM_GetCacheSampleCoord(param_2, param_3);
    texture_sample = texture(in_cache_pass, sample_coord);
    AVERAGE_LUMA = texture_sample.w;
    SAMPLING_SCANLINE_DIR_MULT = texture_sample.x;
    SAMPLING_OPPOSITE_DIR_MULT = texture_sample.y;
    highp float res_mult_size_sum = 0.0;
    highp float res_mult_size2_sum = 0.0;
    if (SCREEN_INDEX == 1.0)
    {
        highp float param_4 = 2.0;
        highp float param_5 = 1.0;
        sample_coord = HSM_GetCacheSampleCoord(param_4, param_5);
        texture_sample = texture(in_cache_pass, sample_coord);
        SCREEN_ASPECT = texture_sample.x;
        SCREEN_SCALE = texture_sample.zw;
        highp float param_6 = 3.0;
        highp float param_7 = 1.0;
        sample_coord = HSM_GetCacheSampleCoord(param_6, param_7);
        texture_sample = texture(in_cache_pass, sample_coord);
        TUBE_SCALE = texture_sample.xy;
        SCREEN_POS_OFFSET = texture_sample.zw;
        highp float param_8 = 3.0;
        highp float param_9 = 4.0;
        sample_coord = HSM_GetCacheSampleCoord(param_8, param_9);
        texture_sample = texture(in_cache_pass, sample_coord);
        TUBE_DIFFUSE_SCALE = texture_sample.xy;
        TUBE_DIFFUSE_ASPECT = (TUBE_DIFFUSE_SCALE.x / TUBE_DIFFUSE_SCALE.y) * output_aspect;
        highp float param_10 = 4.0;
        highp float param_11 = 1.0;
        sample_coord = HSM_GetCacheSampleCoord(param_10, param_11);
        texture_sample = texture(in_cache_pass, sample_coord);
        CROPPED_ROTATED_SIZE_WITH_RES_MULT = texture_sample.xy;
        res_mult_size_sum = CROPPED_ROTATED_SIZE_WITH_RES_MULT.x + CROPPED_ROTATED_SIZE_WITH_RES_MULT.y;
        ROTATED_CORE_PREPPED_SIZE = texture_sample.zw;
        highp float param_12 = 1.0;
        highp float param_13 = 2.0;
        sample_coord = HSM_GetCacheSampleCoord(param_12, param_13);
        texture_sample = texture(in_cache_pass, sample_coord);
        CROPPED_ROTATED_SIZE = texture_sample.xy;
        SAMPLE_AREA_START_PIXEL_COORD = texture_sample.zw;
        highp float param_14 = 4.0;
        highp float param_15 = 4.0;
        sample_coord = HSM_GetCacheSampleCoord(param_14, param_15);
        texture_sample = texture(in_cache_pass, sample_coord);
        SCREEN_SIZE = texture_sample.xy;
    }
    if (SCREEN_INDEX == 2.0)
    {
        highp float param_16 = 2.0;
        highp float param_17 = 2.0;
        sample_coord = HSM_GetCacheSampleCoord(param_16, param_17);
        texture_sample = texture(in_cache_pass, sample_coord);
        SCREEN_ASPECT = texture_sample.x;
        SCREEN_SCALE = texture_sample.yz;
        highp float param_18 = 3.0;
        highp float param_19 = 2.0;
        sample_coord = HSM_GetCacheSampleCoord(param_18, param_19);
        texture_sample = texture(in_cache_pass, sample_coord);
        TUBE_SCALE = texture_sample.xy;
        SCREEN_POS_OFFSET = texture_sample.zw;
        highp float param_20 = 3.0;
        highp float param_21 = 4.0;
        sample_coord = HSM_GetCacheSampleCoord(param_20, param_21);
        texture_sample = texture(in_cache_pass, sample_coord);
        TUBE_DIFFUSE_SCALE = texture_sample.zw;
        TUBE_DIFFUSE_ASPECT = (TUBE_DIFFUSE_SCALE.x / TUBE_DIFFUSE_SCALE.y) * output_aspect;
        highp float param_22 = 4.0;
        highp float param_23 = 2.0;
        sample_coord = HSM_GetCacheSampleCoord(param_22, param_23);
        texture_sample = texture(in_cache_pass, sample_coord);
        CROPPED_ROTATED_SIZE_WITH_RES_MULT = texture_sample.xy;
        res_mult_size2_sum = CROPPED_ROTATED_SIZE_WITH_RES_MULT.x + CROPPED_ROTATED_SIZE_WITH_RES_MULT.y;
        highp float param_24 = 1.0;
        highp float param_25 = 3.0;
        sample_coord = HSM_GetCacheSampleCoord(param_24, param_25);
        texture_sample = texture(in_cache_pass, sample_coord);
        CROPPED_ROTATED_SIZE = texture_sample.xy;
        SAMPLE_AREA_START_PIXEL_COORD = texture_sample.zw;
        highp float param_26 = 4.0;
        highp float param_27 = 4.0;
        sample_coord = HSM_GetCacheSampleCoord(param_26, param_27);
        texture_sample = texture(in_cache_pass, sample_coord);
        SCREEN_SIZE = texture_sample.zw;
    }
    highp float param_28 = 3.0;
    highp float param_29 = 1.0;
    sample_coord = HSM_GetCacheSampleCoord(param_28, param_29);
    texture_sample = texture(in_cache_pass, sample_coord);
    SCREEN_POS_OFFSET_1ST_SCREEN = texture_sample.zw;
    highp float param_30 = 3.0;
    highp float param_31 = 4.0;
    sample_coord = HSM_GetCacheSampleCoord(param_30, param_31);
    texture_sample = texture(in_cache_pass, sample_coord);
    TUBE_DIFFUSE_SCALE_1ST_SCREEN = texture_sample.xy;
    highp float param_32 = 3.0;
    highp float param_33 = 2.0;
    sample_coord = HSM_GetCacheSampleCoord(param_32, param_33);
    texture_sample = texture(in_cache_pass, sample_coord);
    SCREEN_POS_OFFSET_2ND_SCREEN = texture_sample.zw;
    highp float param_34 = 3.0;
    highp float param_35 = 4.0;
    sample_coord = HSM_GetCacheSampleCoord(param_34, param_35);
    texture_sample = texture(in_cache_pass, sample_coord);
    TUBE_DIFFUSE_SCALE_2ND_SCREEN = texture_sample.zw;
    highp float param_36 = 2.0;
    highp float param_37 = 3.0;
    sample_coord = HSM_GetCacheSampleCoord(param_36, param_37);
    texture_sample = texture(in_cache_pass, sample_coord);
    CORE_SIZE = texture_sample.xy;
    ROTATED_CORE_ORIGINAL_SIZE = texture_sample.zw;
    highp float param_38 = 3.0;
    highp float param_39 = 3.0;
    sample_coord = HSM_GetCacheSampleCoord(param_38, param_39);
    texture_sample = texture(in_cache_pass, sample_coord);
    VIEWPORT_SCALE = texture_sample.xy;
    VIEWPORT_POS = texture_sample.zw;
    highp float param_40 = 4.0;
    highp float param_41 = 3.0;
    sample_coord = HSM_GetCacheSampleCoord(param_40, param_41);
    texture_sample = texture(in_cache_pass, sample_coord);
    SCREEN_SCALE_2ND_SCREEN = texture_sample.xy;
    SCREEN_POS_OFFSET_2ND_SCREEN = texture_sample.zw;
    highp float param_42 = 1.0;
    highp float param_43 = 4.0;
    sample_coord = HSM_GetCacheSampleCoord(param_42, param_43);
    texture_sample = texture(in_cache_pass, sample_coord);
    CURRENT_FRAME_FROM_CACHE_INFO = texture_sample.y;
    ROTATED_DEREZED_SIZE = texture_sample.zw;
    highp float param_44 = 2.0;
    highp float param_45 = 4.0;
    sample_coord = HSM_GetCacheSampleCoord(param_44, param_45);
    texture_sample = texture(in_cache_pass, sample_coord);
    NEGATIVE_CROP_EXPAND_MULTIPLIER = texture_sample.x;
    MAX_NEGATIVE_CROP = texture_sample.y;
    USE_VERTICAL_SCANLINES = texture_sample.z;
    highp float param_46 = 8.0;
    highp float param_47 = 8.0;
    sample_coord = HSM_GetCacheSampleCoord(param_46, param_47);
    texture_sample = texture(in_cache_pass, sample_coord);
    CACHE_INFO_CHANGED = (texture_sample.x > 0.5) ? true : false;
    SCREEN_SCALE_WITH_ZOOM = SCREEN_SCALE * HSM_VIEWPORT_ZOOM;
    highp vec2 param_48 = flipped_viewport_coord;
    highp vec2 param_49 = SCREEN_SCALE;
    highp vec2 param_50 = SCREEN_POS_OFFSET;
    SCREEN_COORD = HSM_GetVTexCoordWithArgs(param_48, param_49, param_50);
    highp vec2 param_51 = flipped_viewport_coord;
    highp vec2 param_52 = TUBE_DIFFUSE_SCALE;
    highp vec2 param_53 = SCREEN_POS_OFFSET;
    TUBE_DIFFUSE_COORD = HSM_GetVTexCoordWithArgs(param_51, param_52, param_53);
    highp vec2 param_54 = flipped_viewport_coord;
    highp vec2 param_55 = TUBE_DIFFUSE_SCALE_1ST_SCREEN;
    highp vec2 param_56 = (SCREEN_POS_OFFSET_1ST_SCREEN + SCREEN_POS_OFFSET_2ND_SCREEN) / vec2(2.0);
    TUBE_DIFFUSE_COORD_MIXED_POS = HSM_GetVTexCoordWithArgs(param_54, param_55, param_56);
    return vec4(0.0);
}

highp vec2 HSM_RotateCoordinate(highp vec2 in_coord, highp float rotation)
{
    if (rotation == 0.0)
    {
        return in_coord;
    }
    highp float abs_rotation = abs(rotation);
    highp vec2 ctr_coord = in_coord - vec2(0.5);
    ctr_coord = ((ctr_coord * (1.0 - abs_rotation)) + (vec2(-ctr_coord.y, ctr_coord.x) * (clamp(abs_rotation, 0.0, 1.0) * abs_rotation))) + (vec2(ctr_coord.y, -ctr_coord.x) * (abs(clamp(abs_rotation, -1.0, 0.0)) * abs_rotation));
    if (rotation < 0.0)
    {
        ctr_coord *= (-1.0);
    }
    return ctr_coord + vec2(0.5);
}

highp vec2 HSM_AddPosScaleToCoord(highp vec2 in_base_coord, highp vec2 in_pos, highp vec2 in_scale)
{
    highp vec2 positioned_coord = in_base_coord + in_pos;
    highp vec2 param = positioned_coord;
    highp vec2 param_1 = in_scale;
    highp vec2 out_coord = HSM_GetInverseScaledCoord(param, param_1);
    return out_coord;
}

highp vec2 GetSimpleImageScaledCoord(inout highp vec2 in_viewport_coord, highp vec2 in_viewport_unscaled_coord, highp vec2 in_tube_coord, highp vec2 in_tube_scale, highp sampler2D in_sampler, highp vec2 in_pos, highp float in_inherit_pos, highp vec2 in_scale, highp float in_scale_inherit_mode, highp float in_keep_aspect, highp float in_mirror_horz, highp float in_rotate)
{
    highp float output_aspect = global.FinalViewportSize.x / global.FinalViewportSize.y;
    highp vec2 coord_ctr = vec2(1.0);
    if (in_scale_inherit_mode == 0.0)
    {
        coord_ctr = in_viewport_unscaled_coord - vec2(0.5);
    }
    if (in_scale_inherit_mode == 1.0)
    {
        coord_ctr = in_viewport_coord - vec2(0.5);
    }
    if (in_scale_inherit_mode == 2.0)
    {
        if ((in_inherit_pos < 0.5) || (HSM_DUALSCREEN_MODE > 0.5))
        {
            coord_ctr = (((in_viewport_coord - vec2(0.5)) / in_tube_scale) * vec2(in_tube_scale.x / in_tube_scale.y, 1.0)) * 0.829699993133544921875;
        }
        else
        {
            coord_ctr = ((in_tube_coord - vec2(0.5)) * vec2(in_tube_scale.x / in_tube_scale.y, 1.0)) * 0.829699993133544921875;
        }
        if (HSM_DUALSCREEN_MODE > 0.5)
        {
            coord_ctr *= 0.5;
        }
    }
    highp float _5126;
    if (in_mirror_horz == 1.0)
    {
        _5126 = (-1.0) * coord_ctr.x;
    }
    else
    {
        _5126 = coord_ctr.x;
    }
    coord_ctr.x = _5126;
    highp vec2 param = in_viewport_coord;
    highp float param_1 = in_rotate;
    in_viewport_coord = HSM_RotateCoordinate(param, param_1);
    highp vec2 tex_size = vec2(textureSize(in_sampler, 0));
    highp float _5151;
    if (in_rotate == 1.0)
    {
        _5151 = tex_size.y / tex_size.x;
    }
    else
    {
        _5151 = tex_size.x / tex_size.y;
    }
    highp float tex_aspect = _5151;
    highp float _5168;
    if (in_keep_aspect == 1.0)
    {
        _5168 = output_aspect / tex_aspect;
    }
    else
    {
        _5168 = 1.0;
    }
    coord_ctr.x *= _5168;
    highp float _5182;
    if (in_rotate > 0.5)
    {
        _5182 = global.FinalViewportSize.x / global.FinalViewportSize.y;
    }
    else
    {
        _5182 = 1.0;
    }
    coord_ctr /= vec2(_5182);
    if (in_rotate > 0.5)
    {
        coord_ctr = vec2(-coord_ctr.y, -coord_ctr.x);
    }
    highp vec2 param_2 = coord_ctr + vec2(0.5);
    highp vec2 param_3 = in_pos;
    highp vec2 param_4 = in_scale;
    return HSM_AddPosScaleToCoord(param_2, param_3, param_4);
}

highp vec4 HSM_GetMipmappedTexSample(highp sampler2D in_sampler, highp vec2 in_coord, highp vec2 in_scale, highp float in_blend_bias)
{
    highp vec2 tex_size = vec2(textureSize(in_sampler, 0));
    highp vec2 scaled_tex_size = in_scale * global.FinalViewportSize.xy;
    highp float mipmap_lod = log2(tex_size.y / scaled_tex_size.y);
    return textureLod(in_sampler, in_coord, mipmap_lod + in_blend_bias);
}

highp vec4 HSM_ApplyGamma(highp vec4 in_color, highp float in_gamma)
{
    highp vec3 out_color = pow(in_color.xyz, vec3(1.0 / in_gamma));
    return vec4(out_color, in_color.w);
}

highp vec4 HSM_Linearize(highp vec4 in_color, highp float encoded_gamma)
{
    highp vec4 param = in_color;
    highp float param_1 = 1.0 / encoded_gamma;
    return HSM_ApplyGamma(param, param_1);
}

highp vec3 HSM_RGBtoHSV(highp vec3 c)
{
    highp vec4 K = vec4(0.0, -0.3333333432674407958984375, 0.666666686534881591796875, -1.0);
    highp vec4 _2635;
    if (c.y < c.z)
    {
        _2635 = vec4(c.zy, K.wz);
    }
    else
    {
        _2635 = vec4(c.yz, K.xy);
    }
    highp vec4 p = _2635;
    highp vec4 _2665;
    if (c.x < p.x)
    {
        _2665 = vec4(p.xyw, c.x);
    }
    else
    {
        _2665 = vec4(c.x, p.yzx);
    }
    highp vec4 q = _2665;
    highp float d = q.x - min(q.w, q.y);
    highp float e = 1.0000000133514319600180897396058e-10;
    return vec3(abs(q.z + ((q.w - q.y) / ((6.0 * d) + e))), d / (q.x + e), q.x);
}

highp vec3 HSM_HSVtoRGB(highp vec3 c)
{
    highp vec4 K = vec4(1.0, 0.666666686534881591796875, 0.3333333432674407958984375, 3.0);
    highp vec3 p = abs((fract(c.xxx + K.xyz) * 6.0) - K.www);
    return mix(K.xxx, clamp(p - K.xxx, vec3(0.0), vec3(1.0)), vec3(c.y)) * c.z;
}

highp vec4 HSM_GetNightLightingMultiplyColor(highp vec2 in_coord, highp float hue, highp float saturation, highp float value, highp float contrast, highp float global_ambient_opacity, highp sampler2D NightLightingImage_1)
{
    highp vec4 lighting_image = vec4(0.0);
    highp vec2 param = in_coord;
    highp vec2 param_1 = vec2(1.0);
    highp float param_2 = 0.0;
    lighting_image = HSM_GetMipmappedTexSample(NightLightingImage_1, param, param_1, param_2);
    highp vec4 param_3 = lighting_image;
    highp float param_4 = 2.2000000476837158203125;
    lighting_image = HSM_Linearize(param_3, param_4);
    lighting_image = ((lighting_image - vec4(0.5)) * contrast) + vec4(0.5);
    if (((hue != 0.0) || (saturation != 1.0)) || (value != 1.0))
    {
        highp vec3 param_5 = lighting_image.xyz;
        highp vec3 night_lighting_image_hsv = HSM_RGBtoHSV(param_5);
        night_lighting_image_hsv.x += hue;
        night_lighting_image_hsv.y *= saturation;
        night_lighting_image_hsv.z *= value;
        highp vec3 param_6 = night_lighting_image_hsv;
        lighting_image = vec4(HSM_HSVtoRGB(param_6), lighting_image.w);
    }
    highp vec4 _6266 = lighting_image;
    highp vec3 _6270 = mix(vec3(1.0), _6266.xyz, vec3(global_ambient_opacity));
    lighting_image.x = _6270.x;
    lighting_image.y = _6270.y;
    lighting_image.z = _6270.z;
    return lighting_image;
}

bool HSM_Fill_Ambient_Images(highp vec2 in_viewport_coord, highp vec2 in_viewport_unscaled_coord, highp vec2 in_tube_coord, highp vec2 in_tube_scale, highp float in_swap_images, highp sampler2D in_ambient_sampler, highp sampler2D in_ambient2_sampler, out highp vec4 ambient_lighting_image, out highp vec4 ambient2_lighting_image)
{
    ambient_lighting_image = vec4(1.0);
    ambient2_lighting_image = vec4(1.0);
    if (HSM_AMBIENT1_OPACITY > 0.0)
    {
        highp float ambient1_scale = HSM_AMBIENT1_SCALE;
        bool _6288 = HSM_AMBIENT1_SCALE_INHERIT_MODE == 1.0;
        bool _6295;
        if (_6288)
        {
            _6295 = (HSM_AMBIENT1_SCALE * HSM_VIEWPORT_ZOOM) < 1.0;
        }
        else
        {
            _6295 = _6288;
        }
        if (_6295)
        {
            ambient1_scale = 1.0 / HSM_VIEWPORT_ZOOM;
        }
        highp vec2 param = in_viewport_coord;
        highp vec2 param_1 = in_viewport_unscaled_coord;
        highp vec2 param_2 = in_tube_coord;
        highp vec2 param_3 = in_tube_scale;
        highp vec2 param_4 = vec2(HSM_AMBIENT1_POSITION_X, HSM_AMBIENT1_POSITION_Y);
        highp float param_5 = HSM_AMBIENT1_POS_INHERIT_MODE;
        highp vec2 param_6 = vec2(ambient1_scale * HSM_AMBIENT1_SCALE_X, ambient1_scale);
        highp float param_7 = HSM_AMBIENT1_SCALE_INHERIT_MODE;
        highp float param_8 = HSM_AMBIENT1_SCALE_KEEP_ASPECT;
        highp float param_9 = HSM_AMBIENT1_MIRROR_HORZ;
        highp float param_10 = HSM_AMBIENT1_ROTATE;
        highp vec2 _6329 = GetSimpleImageScaledCoord(param, param_1, param_2, param_3, in_ambient_sampler, param_4, param_5, param_6, param_7, param_8, param_9, param_10);
        highp vec2 lighting_coord = _6329;
        highp vec2 param_11 = lighting_coord;
        highp float param_12 = HSM_AMBIENT1_HUE;
        highp float param_13 = HSM_AMBIENT1_SATURATION;
        highp float param_14 = HSM_AMBIENT1_VALUE;
        highp float param_15 = HSM_AMBIENT1_CONTRAST;
        highp float param_16 = HSM_AMBIENT1_OPACITY;
        ambient_lighting_image = HSM_GetNightLightingMultiplyColor(param_11, param_12, param_13, param_14, param_15, param_16, in_ambient_sampler);
    }
    if (HSM_AMBIENT2_OPACITY > 0.0)
    {
        highp float ambient2_scale = HSM_AMBIENT2_SCALE;
        bool _6350 = HSM_AMBIENT2_SCALE_INHERIT_MODE == 1.0;
        bool _6357;
        if (_6350)
        {
            _6357 = (HSM_AMBIENT2_SCALE * HSM_VIEWPORT_ZOOM) < 1.0;
        }
        else
        {
            _6357 = _6350;
        }
        if (_6357)
        {
            ambient2_scale = 1.0 / HSM_VIEWPORT_ZOOM;
        }
        highp vec2 param_17 = in_viewport_coord;
        highp vec2 param_18 = in_viewport_unscaled_coord;
        highp vec2 param_19 = in_tube_coord;
        highp vec2 param_20 = in_tube_scale;
        highp vec2 param_21 = vec2(HSM_AMBIENT2_POSITION_X, HSM_AMBIENT2_POSITION_Y);
        highp float param_22 = HSM_AMBIENT2_POS_INHERIT_MODE;
        highp vec2 param_23 = vec2(ambient2_scale * HSM_AMBIENT2_SCALE_X, ambient2_scale);
        highp float param_24 = HSM_AMBIENT2_SCALE_INHERIT_MODE;
        highp float param_25 = HSM_AMBIENT2_SCALE_KEEP_ASPECT;
        highp float param_26 = HSM_AMBIENT2_MIRROR_HORZ;
        highp float param_27 = HSM_AMBIENT2_ROTATE;
        highp vec2 _6391 = GetSimpleImageScaledCoord(param_17, param_18, param_19, param_20, in_ambient2_sampler, param_21, param_22, param_23, param_24, param_25, param_26, param_27);
        highp vec2 lighting2_coord = _6391;
        highp vec2 param_28 = lighting2_coord;
        highp float param_29 = HSM_AMBIENT2_HUE;
        highp float param_30 = HSM_AMBIENT2_SATURATION;
        highp float param_31 = HSM_AMBIENT2_VALUE;
        highp float param_32 = HSM_AMBIENT2_CONTRAST;
        highp float param_33 = HSM_AMBIENT2_OPACITY;
        ambient2_lighting_image = HSM_GetNightLightingMultiplyColor(param_28, param_29, param_30, param_31, param_32, param_33, in_ambient2_sampler);
    }
    return true;
}

highp float intersect(highp vec2 in_coord, highp vec2 sinangle, highp vec2 cosangle, highp float in_radius, highp float in_distance)
{
    highp float A = dot(in_coord, in_coord) + (in_distance * in_distance);
    highp float B = 2.0 * ((in_radius * (dot(in_coord, sinangle) - ((in_distance * cosangle.x) * cosangle.y))) - (in_distance * in_distance));
    highp float C = (in_distance * in_distance) + ((((2.0 * in_radius) * in_distance) * cosangle.x) * cosangle.y);
    return ((-B) - sqrt((B * B) - ((4.0 * A) * C))) / (2.0 * A);
}

highp vec2 bkwtrans(highp vec2 in_coord, highp vec2 sinangle, highp vec2 cosangle, highp float in_radius, highp float in_distance)
{
    highp vec2 param = in_coord;
    highp vec2 param_1 = sinangle;
    highp vec2 param_2 = cosangle;
    highp float param_3 = in_radius;
    highp float param_4 = in_distance;
    highp float c = intersect(param, param_1, param_2, param_3, param_4);
    highp vec2 pt = vec2(c) * in_coord;
    pt -= (vec2(-in_radius) * sinangle);
    pt /= vec2(in_radius);
    highp vec2 tang = sinangle / cosangle;
    highp vec2 poc = pt / cosangle;
    highp float A = dot(tang, tang) + 1.0;
    highp float B = (-2.0) * dot(poc, tang);
    highp float C = dot(poc, poc) - 1.0;
    highp float a = ((-B) + sqrt((B * B) - ((4.0 * A) * C))) / (2.0 * A);
    highp vec2 uv = (pt - (sinangle * a)) / cosangle;
    highp float r = max(abs(in_radius * acos(a)), 9.9999997473787516355514526367188e-06);
    return (uv * r) / vec2(sin(r / in_radius));
}

highp vec2 fwtrans(inout highp vec2 uv, highp vec2 sinangle, highp vec2 cosangle, highp float in_radius, highp float in_distance)
{
    highp float r = max(abs(sqrt(dot(uv, uv))), 9.9999997473787516355514526367188e-06);
    uv *= (sin(r / in_radius) / r);
    highp float x = 1.0 - cos(r / in_radius);
    highp float D = ((in_distance / in_radius) + ((x * cosangle.x) * cosangle.y)) + dot(uv, sinangle);
    return (((uv * cosangle) - (sinangle * x)) * in_distance) / vec2(D);
}

highp vec3 maxscale(highp vec2 sinangle, highp vec2 cosangle, highp float in_radius, highp float in_distance, highp float in_aspect)
{
    highp vec2 aspect_vec2 = vec2(1.0, 1.0 / in_aspect);
    highp vec2 param = (sinangle * (-in_radius)) / vec2(1.0 + (((in_radius / in_distance) * cosangle.x) * cosangle.y));
    highp vec2 param_1 = sinangle;
    highp vec2 param_2 = cosangle;
    highp float param_3 = in_radius;
    highp float param_4 = in_distance;
    highp vec2 c = bkwtrans(param, param_1, param_2, param_3, param_4);
    highp vec2 a = vec2(0.5) * aspect_vec2;
    highp vec2 param_5 = vec2(-a.x, c.y);
    highp vec2 param_6 = sinangle;
    highp vec2 param_7 = cosangle;
    highp float param_8 = in_radius;
    highp float param_9 = in_distance;
    highp vec2 _5508 = fwtrans(param_5, param_6, param_7, param_8, param_9);
    highp vec2 param_10 = vec2(c.x, -a.y);
    highp vec2 param_11 = sinangle;
    highp vec2 param_12 = cosangle;
    highp float param_13 = in_radius;
    highp float param_14 = in_distance;
    highp vec2 _5525 = fwtrans(param_10, param_11, param_12, param_13, param_14);
    highp vec2 lo = vec2(_5508.x, _5525.y) / aspect_vec2;
    highp vec2 param_15 = vec2(a.x, c.y);
    highp vec2 param_16 = sinangle;
    highp vec2 param_17 = cosangle;
    highp float param_18 = in_radius;
    highp float param_19 = in_distance;
    highp vec2 _5545 = fwtrans(param_15, param_16, param_17, param_18, param_19);
    highp vec2 param_20 = vec2(c.x, a.y);
    highp vec2 param_21 = sinangle;
    highp vec2 param_22 = cosangle;
    highp float param_23 = in_radius;
    highp float param_24 = in_distance;
    highp vec2 _5561 = fwtrans(param_20, param_21, param_22, param_23, param_24);
    highp vec2 hi = vec2(_5545.x, _5561.y) / aspect_vec2;
    return vec3(((hi + lo) * aspect_vec2) * 0.5, max(hi.x - lo.x, hi.y - lo.y));
}

highp vec2 transform(inout highp vec2 coord, highp vec3 stretch, highp vec2 sinangle, highp vec2 cosangle, highp float in_radius, highp float in_distance, highp vec2 aspect)
{
    coord = (((coord - vec2(0.5)) * aspect) * stretch.z) + stretch.xy;
    highp vec2 param = coord;
    highp vec2 param_1 = sinangle;
    highp vec2 param_2 = cosangle;
    highp float param_3 = in_radius;
    highp float param_4 = in_distance;
    return (bkwtrans(param, param_1, param_2, param_3, param_4) / aspect) + vec2(0.5);
}

highp vec2 HSM_GetGeomCurvedCoord(highp vec2 in_coord, highp float tilt_x, highp float tilt_y, highp float in_radius, inout highp float in_distance, highp float in_aspect)
{
    in_distance *= 1.39999997615814208984375;
    highp vec2 ang = vec2(tilt_x, tilt_y);
    highp vec2 v_sinangle = sin(ang);
    highp vec2 v_cosangle = cos(ang);
    highp vec2 param = v_sinangle;
    highp vec2 param_1 = v_cosangle;
    highp float param_2 = in_radius;
    highp float param_3 = in_distance;
    highp float param_4 = in_aspect;
    highp vec3 v_stretch = maxscale(param, param_1, param_2, param_3, param_4);
    highp vec2 aspect_vec2 = vec2(1.0, 1.0 / in_aspect);
    highp vec2 param_5 = in_coord;
    highp vec3 param_6 = v_stretch;
    highp vec2 param_7 = v_sinangle;
    highp vec2 param_8 = v_cosangle;
    highp float param_9 = in_radius;
    highp float param_10 = in_distance;
    highp vec2 param_11 = aspect_vec2;
    highp vec2 _5658 = transform(param_5, param_6, param_7, param_8, param_9, param_10, param_11);
    highp vec2 curved_coord = _5658;
    return curved_coord;
}

highp vec2 HSM_GetGeomCurvedCoordRetainWidth(highp vec2 in_coord, highp float tilt_x, highp float tilt_y, highp float in_radius, highp float in_distance, highp float in_aspect)
{
    highp vec2 param = in_coord;
    highp float param_1 = tilt_x;
    highp float param_2 = tilt_y;
    highp float param_3 = in_radius;
    highp float param_4 = in_distance;
    highp float param_5 = in_aspect;
    highp vec2 _5675 = HSM_GetGeomCurvedCoord(param, param_1, param_2, param_3, param_4, param_5);
    highp vec2 ctr_curved_coord = _5675 - vec2(0.5);
    highp vec2 param_6 = vec2(1.0, 0.5);
    highp float param_7 = tilt_x;
    highp float param_8 = tilt_y;
    highp float param_9 = in_radius;
    highp float param_10 = in_distance;
    highp float param_11 = in_aspect;
    highp vec2 _5690 = HSM_GetGeomCurvedCoord(param_6, param_7, param_8, param_9, param_10, param_11);
    highp vec2 right_edge_curved_ctr_coord = _5690 - vec2(0.5);
    ctr_curved_coord.x = (ctr_curved_coord.x * 0.5) / right_edge_curved_ctr_coord.x;
    return ctr_curved_coord + vec2(0.5);
}

highp vec2 hrg_get_aspect_vector(highp float geom_aspect_ratio)
{
    highp float geom_max_aspect_ratio = 1.0;
    highp float geom_clamped_aspect_ratio = min(geom_aspect_ratio, geom_max_aspect_ratio);
    highp vec2 output_aspect = normalize(vec2(geom_clamped_aspect_ratio, 1.0));
    return output_aspect;
}

highp vec3 hrg_sphere_uv_to_xyz(highp vec2 video_uv, highp vec2 output_aspect, highp float in_geom_radius)
{
    highp vec2 square_uv = video_uv * output_aspect;
    highp vec2 square_uv_unit = normalize(square_uv);
    highp float arc_len = square_uv.y / square_uv_unit.y;
    highp float angle_from_image_center = arc_len / in_geom_radius;
    highp float xy_dist_from_sphere_center = sin(angle_from_image_center) * in_geom_radius;
    highp vec2 xy_pos = square_uv_unit * xy_dist_from_sphere_center;
    highp float z_pos = cos(angle_from_image_center) * in_geom_radius;
    highp vec3 intersection_pos_local = vec3(xy_pos.x, -xy_pos.y, z_pos);
    return intersection_pos_local;
}

highp vec3 hrg_sphere_alt_uv_to_xyz(highp vec2 video_uv, highp vec2 output_aspect, highp float in_geom_radius)
{
    highp vec2 square_uv = video_uv * output_aspect;
    highp vec2 arc_len = square_uv;
    highp vec2 angle_from_image_center = arc_len / vec2(in_geom_radius);
    highp vec2 xy_pos = sin(angle_from_image_center) * in_geom_radius;
    highp float z_pos = sqrt((in_geom_radius * in_geom_radius) - dot(xy_pos, xy_pos));
    return vec3(xy_pos.x, -xy_pos.y, z_pos);
}

highp vec3 hrg_cylinder_uv_to_xyz(highp vec2 video_uv, highp vec2 output_aspect, highp float in_geom_radius)
{
    highp vec2 square_uv = video_uv * output_aspect;
    highp float arc_len = square_uv.x;
    highp float angle_from_image_center = arc_len / in_geom_radius;
    highp float x_pos = sin(angle_from_image_center) * in_geom_radius;
    highp float z_pos = cos(angle_from_image_center) * in_geom_radius;
    highp vec3 intersection_pos_local = vec3(x_pos, -square_uv.y, z_pos);
    return intersection_pos_local;
}

highp vec3 hrg_uv_to_xyz(highp vec2 uv, highp vec2 output_aspect, highp float in_geom_mode, highp float in_geom_radius)
{
    highp vec3 _3908;
    if (in_geom_mode < 1.5)
    {
        highp vec2 param = uv;
        highp vec2 param_1 = output_aspect;
        highp float param_2 = in_geom_radius;
        _3908 = hrg_sphere_uv_to_xyz(param, param_1, param_2);
    }
    else
    {
        highp vec3 _3921;
        if (in_geom_mode < 2.5)
        {
            highp vec2 param_3 = uv;
            highp vec2 param_4 = output_aspect;
            highp float param_5 = in_geom_radius;
            _3921 = hrg_sphere_alt_uv_to_xyz(param_3, param_4, param_5);
        }
        else
        {
            highp vec2 param_6 = uv;
            highp vec2 param_7 = output_aspect;
            highp float param_8 = in_geom_radius;
            _3921 = hrg_cylinder_uv_to_xyz(param_6, param_7, param_8);
        }
        _3908 = _3921;
    }
    return _3908;
}

highp vec3 hrg_get_ideal_global_eye_pos_for_points(inout highp vec3 eye_pos, highp vec2 output_aspect, highp vec3 global_coords[9], int num_points, highp float in_geom_radius, highp float in_geom_view_dist)
{
    int max_centering_iters = 1;
    highp vec3 eyespace_coords[9];
    highp float _4153;
    highp float _4166;
    highp float _4179;
    highp float _4192;
    for (int iter = 0; iter < max_centering_iters; iter++)
    {
        for (int i = 0; i < num_points; i++)
        {
            eyespace_coords[i] = global_coords[i] - eye_pos;
        }
        highp float abs_radius = abs(in_geom_radius);
        highp vec2 offset_dr_min = vec2(10.0 * abs_radius, 10.0 * abs_radius);
        highp vec2 offset_ul_max = vec2((-10.0) * abs_radius, (-10.0) * abs_radius);
        for (int i_1 = 0; i_1 < num_points; i_1++)
        {
            highp vec2 flipy = vec2(1.0, -1.0);
            highp vec3 eyespace_xyz = eyespace_coords[i_1];
            highp vec2 offset_dr = eyespace_xyz.xy - ((vec2(-0.5) * (output_aspect * (-eyespace_xyz.z))) / (flipy * in_geom_view_dist));
            highp vec2 offset_ul = eyespace_xyz.xy - ((vec2(0.5) * (output_aspect * (-eyespace_xyz.z))) / (flipy * in_geom_view_dist));
            offset_dr_min = min(offset_dr_min, offset_dr);
            offset_ul_max = max(offset_ul_max, offset_ul);
        }
        highp vec2 center_offset = (offset_ul_max + offset_dr_min) * 0.5;
        highp vec3 _4087 = eye_pos;
        highp vec2 _4089 = _4087.xy + center_offset;
        eye_pos.x = _4089.x;
        eye_pos.y = _4089.y;
        for (int i_2 = 0; i_2 < num_points; i_2++)
        {
            eyespace_coords[i_2] = global_coords[i_2] - eye_pos;
        }
        highp float offset_z_max = ((-10.0) * in_geom_radius) * in_geom_view_dist;
        for (int i_3 = 0; i_3 < num_points; i_3++)
        {
            highp vec3 eyespace_xyz_flipy = eyespace_coords[i_3] * vec3(1.0, -1.0, 1.0);
            highp vec4 offset_zzzz = eyespace_xyz_flipy.zzzz + ((eyespace_xyz_flipy.xyxy * in_geom_view_dist) / (vec4(-0.5, -0.5, 0.5, 0.5) * vec4(output_aspect, output_aspect)));
            if (eyespace_xyz_flipy.x < 0.0)
            {
                _4153 = max(offset_z_max, offset_zzzz.x);
            }
            else
            {
                _4153 = offset_z_max;
            }
            offset_z_max = _4153;
            if (eyespace_xyz_flipy.y < 0.0)
            {
                _4166 = max(offset_z_max, offset_zzzz.y);
            }
            else
            {
                _4166 = offset_z_max;
            }
            offset_z_max = _4166;
            if (eyespace_xyz_flipy.x > 0.0)
            {
                _4179 = max(offset_z_max, offset_zzzz.z);
            }
            else
            {
                _4179 = offset_z_max;
            }
            offset_z_max = _4179;
            if (eyespace_xyz_flipy.y > 0.0)
            {
                _4192 = max(offset_z_max, offset_zzzz.w);
            }
            else
            {
                _4192 = offset_z_max;
            }
            offset_z_max = _4192;
            offset_z_max = max(offset_z_max, eyespace_xyz_flipy.z);
        }
        eye_pos.z += offset_z_max;
    }
    return eye_pos;
}

highp vec3 hrg_get_ideal_global_eye_pos(highp mat3 local_to_global, highp vec2 output_aspect, highp float in_geom_mode, highp float in_geom_radius, highp float in_geom_view_dist)
{
    highp vec3 high_view = vec3(0.0, output_aspect.y, -in_geom_view_dist);
    highp vec3 low_view = high_view * vec3(1.0, -1.0, 1.0);
    highp float len_sq = dot(high_view, high_view);
    highp float fov = abs(acos(dot(high_view, low_view) / len_sq));
    highp float eye_z_spherical = in_geom_radius / sin(fov * 0.5);
    highp vec3 _4248;
    if (in_geom_mode < 2.5)
    {
        _4248 = vec3(0.0, 0.0, eye_z_spherical);
    }
    else
    {
        _4248 = vec3(0.0, 0.0, max(in_geom_view_dist, eye_z_spherical));
    }
    highp vec3 eye_pos = _4248;
    int num_points = 9;
    highp vec2 param = vec2(0.0);
    highp vec2 param_1 = output_aspect;
    highp float param_2 = in_geom_mode;
    highp float param_3 = in_geom_radius;
    highp vec3 global_coords[9];
    global_coords[0] = hrg_uv_to_xyz(param, param_1, param_2, param_3) * local_to_global;
    highp vec2 param_4 = vec2(0.0, -0.5);
    highp vec2 param_5 = output_aspect;
    highp float param_6 = in_geom_mode;
    highp float param_7 = in_geom_radius;
    global_coords[1] = hrg_uv_to_xyz(param_4, param_5, param_6, param_7) * local_to_global;
    highp vec2 param_8 = vec2(0.0, 0.5);
    highp vec2 param_9 = output_aspect;
    highp float param_10 = in_geom_mode;
    highp float param_11 = in_geom_radius;
    global_coords[2] = hrg_uv_to_xyz(param_8, param_9, param_10, param_11) * local_to_global;
    highp vec2 param_12 = vec2(-0.5, 0.0);
    highp vec2 param_13 = output_aspect;
    highp float param_14 = in_geom_mode;
    highp float param_15 = in_geom_radius;
    global_coords[3] = hrg_uv_to_xyz(param_12, param_13, param_14, param_15) * local_to_global;
    highp vec2 param_16 = vec2(0.5, 0.0);
    highp vec2 param_17 = output_aspect;
    highp float param_18 = in_geom_mode;
    highp float param_19 = in_geom_radius;
    global_coords[4] = hrg_uv_to_xyz(param_16, param_17, param_18, param_19) * local_to_global;
    highp vec2 param_20 = vec2(-0.5);
    highp vec2 param_21 = output_aspect;
    highp float param_22 = in_geom_mode;
    highp float param_23 = in_geom_radius;
    global_coords[5] = hrg_uv_to_xyz(param_20, param_21, param_22, param_23) * local_to_global;
    highp vec2 param_24 = vec2(0.5, -0.5);
    highp vec2 param_25 = output_aspect;
    highp float param_26 = in_geom_mode;
    highp float param_27 = in_geom_radius;
    global_coords[6] = hrg_uv_to_xyz(param_24, param_25, param_26, param_27) * local_to_global;
    highp vec2 param_28 = vec2(-0.5, 0.5);
    highp vec2 param_29 = output_aspect;
    highp float param_30 = in_geom_mode;
    highp float param_31 = in_geom_radius;
    global_coords[7] = hrg_uv_to_xyz(param_28, param_29, param_30, param_31) * local_to_global;
    highp vec2 param_32 = vec2(0.5);
    highp vec2 param_33 = output_aspect;
    highp float param_34 = in_geom_mode;
    highp float param_35 = in_geom_radius;
    global_coords[8] = hrg_uv_to_xyz(param_32, param_33, param_34, param_35) * local_to_global;
    highp float num_negative_z_coords = 0.0;
    for (int i = 0; i < num_points; i++)
    {
        num_negative_z_coords += float(global_coords[0].z < 0.0);
    }
    highp vec3 _4391;
    if (num_negative_z_coords > 0.5)
    {
        _4391 = eye_pos;
    }
    else
    {
        highp vec3 param_36 = eye_pos;
        highp vec2 param_37 = output_aspect;
        highp vec3 param_38[9] = global_coords;
        int param_39 = num_points;
        highp float param_40 = in_geom_radius;
        highp float param_41 = in_geom_view_dist;
        highp vec3 _4408 = hrg_get_ideal_global_eye_pos_for_points(param_36, param_37, param_38, param_39, param_40, param_41);
        _4391 = _4408;
    }
    return _4391;
}

highp vec2 hrg_quadratic_solve(highp float a, highp float b_over_2, highp float c)
{
    highp float discriminant = (b_over_2 * b_over_2) - (a * c);
    highp float solution0 = c / ((-b_over_2) + sqrt(discriminant));
    return vec2(solution0, discriminant);
}

highp vec2 hrg_intersect_sphere(highp vec3 view_vec, highp vec3 eye_pos_vec, highp float in_geom_radius)
{
    highp float a = dot(view_vec, view_vec);
    highp float b_over_2 = dot(view_vec, eye_pos_vec);
    highp float c = dot(eye_pos_vec, eye_pos_vec) - (in_geom_radius * in_geom_radius);
    highp float param = a;
    highp float param_1 = b_over_2;
    highp float param_2 = c;
    return hrg_quadratic_solve(param, param_1, param_2);
}

highp vec2 hrg_intersect_cylinder(highp vec3 view_vec, highp vec3 eye_pos_vec, highp float in_geom_radius)
{
    highp vec3 cylinder_top_vec = vec3(0.0, in_geom_radius, 0.0);
    highp vec3 cylinder_axis_vec = vec3(0.0, 1.0, 0.0);
    highp vec3 top_to_eye_vec = eye_pos_vec - cylinder_top_vec;
    highp vec3 axis_x_view = cross(cylinder_axis_vec, view_vec);
    highp vec3 axis_x_top_to_eye = cross(cylinder_axis_vec, top_to_eye_vec);
    highp float a = dot(axis_x_view, axis_x_view);
    highp float b_over_2 = dot(axis_x_top_to_eye, axis_x_view);
    highp float c = dot(axis_x_top_to_eye, axis_x_top_to_eye) - (in_geom_radius * in_geom_radius);
    highp float param = a;
    highp float param_1 = b_over_2;
    highp float param_2 = c;
    return hrg_quadratic_solve(param, param_1, param_2);
}

highp vec2 hrg_intersect(highp vec3 view_vec_local, highp vec3 eye_pos_local, highp float in_geom_mode, highp float in_geom_radius)
{
    highp vec2 _3847;
    if (in_geom_mode < 2.5)
    {
        highp vec3 param = view_vec_local;
        highp vec3 param_1 = eye_pos_local;
        highp float param_2 = in_geom_radius;
        _3847 = hrg_intersect_sphere(param, param_1, param_2);
    }
    else
    {
        highp vec3 param_3 = view_vec_local;
        highp vec3 param_4 = eye_pos_local;
        highp float param_5 = in_geom_radius;
        _3847 = hrg_intersect_cylinder(param_3, param_4, param_5);
    }
    return _3847;
}

highp vec2 hrg_sphere_xyz_to_uv(highp vec3 intersection_pos_local, highp vec2 output_aspect, highp float in_geom_radius)
{
    highp vec3 image_center_pos_local = vec3(0.0, 0.0, in_geom_radius);
    highp float cp_len = length(cross(intersection_pos_local, image_center_pos_local));
    highp float dp = dot(intersection_pos_local, image_center_pos_local);
    highp float angle_from_image_center = atan(cp_len, dp);
    highp float arc_len = angle_from_image_center * in_geom_radius;
    highp vec2 square_uv_unit = normalize(vec2(intersection_pos_local.x, -intersection_pos_local.y));
    highp vec2 square_uv = square_uv_unit * arc_len;
    highp vec2 video_uv = square_uv / output_aspect;
    return video_uv;
}

highp vec2 hrg_sphere_alt_xyz_to_uv(highp vec3 intersection_pos_local, highp vec2 output_aspect, highp float in_geom_radius)
{
    highp vec2 angle_from_image_center = atan(vec2(intersection_pos_local.x, -intersection_pos_local.y), intersection_pos_local.zz);
    highp vec2 signed_arc_len = angle_from_image_center * in_geom_radius;
    highp vec2 video_uv = signed_arc_len / output_aspect;
    return video_uv;
}

highp vec2 hrg_cylinder_xyz_to_uv(highp vec3 intersection_pos_local, highp vec2 output_aspect, highp float in_geom_radius)
{
    highp float angle_from_image_center = atan(intersection_pos_local.x, intersection_pos_local.z);
    highp float signed_arc_len = angle_from_image_center * in_geom_radius;
    highp vec2 square_uv = vec2(signed_arc_len, -intersection_pos_local.y);
    highp vec2 video_uv = square_uv / output_aspect;
    return video_uv;
}

highp vec2 hrg_xyz_to_uv(highp vec3 intersection_pos_local, highp vec2 output_aspect, highp float in_geom_mode, highp float in_geom_radius)
{
    highp vec2 _3871;
    if (in_geom_mode < 1.5)
    {
        highp vec3 param = intersection_pos_local;
        highp vec2 param_1 = output_aspect;
        highp float param_2 = in_geom_radius;
        _3871 = hrg_sphere_xyz_to_uv(param, param_1, param_2);
    }
    else
    {
        highp vec2 _3884;
        if (in_geom_mode < 2.5)
        {
            highp vec3 param_3 = intersection_pos_local;
            highp vec2 param_4 = output_aspect;
            highp float param_5 = in_geom_radius;
            _3884 = hrg_sphere_alt_xyz_to_uv(param_3, param_4, param_5);
        }
        else
        {
            highp vec3 param_6 = intersection_pos_local;
            highp vec2 param_7 = output_aspect;
            highp float param_8 = in_geom_radius;
            _3884 = hrg_cylinder_xyz_to_uv(param_6, param_7, param_8);
        }
        _3871 = _3884;
    }
    return _3871;
}

highp vec2 hrg_view_vec_to_uv(highp vec3 view_vec_local, highp vec3 eye_pos_local, highp vec2 output_aspect, highp float in_geom_mode, highp float in_geom_radius, out highp vec3 intersection_pos)
{
    highp vec3 param = view_vec_local;
    highp vec3 param_1 = eye_pos_local;
    highp float param_2 = in_geom_mode;
    highp float param_3 = in_geom_radius;
    highp vec2 intersect_dist_and_discriminant = hrg_intersect(param, param_1, param_2, param_3);
    highp vec3 intersection_pos_local = eye_pos_local + (view_vec_local * intersect_dist_and_discriminant.x);
    intersection_pos = intersection_pos_local;
    highp vec2 _3965;
    if (intersect_dist_and_discriminant.y > 0.004999999888241291046142578125)
    {
        highp vec3 param_4 = intersection_pos_local;
        highp vec2 param_5 = output_aspect;
        highp float param_6 = in_geom_mode;
        highp float param_7 = in_geom_radius;
        _3965 = hrg_xyz_to_uv(param_4, param_5, param_6, param_7);
    }
    else
    {
        _3965 = vec2(1.0);
    }
    return _3965;
}

highp mat3 hrg_get_pixel_to_object_matrix(highp mat3 global_to_local, highp vec3 eye_pos_local, highp vec3 view_vec_global, highp vec3 intersection_pos_local, highp vec3 normal, highp vec2 output_pixel_size)
{
    highp vec3 pos = intersection_pos_local;
    highp vec3 eye_pos = eye_pos_local;
    highp vec3 view_vec_right_global = view_vec_global + vec3(output_pixel_size.x, 0.0, 0.0);
    highp vec3 view_vec_down_global = view_vec_global + vec3(0.0, -output_pixel_size.y, 0.0);
    highp vec3 view_vec_right_local = view_vec_right_global * global_to_local;
    highp vec3 view_vec_down_local = view_vec_down_global * global_to_local;
    highp vec3 intersection_vec_dot_normal = vec3(dot(pos - eye_pos, normal));
    highp vec3 right_pos = eye_pos + ((intersection_vec_dot_normal / vec3(dot(view_vec_right_local, normal))) * view_vec_right_local);
    highp vec3 down_pos = eye_pos + ((intersection_vec_dot_normal / vec3(dot(view_vec_down_local, normal))) * view_vec_down_local);
    highp vec3 object_right_vec = right_pos - pos;
    highp vec3 object_down_vec = down_pos - pos;
    highp mat3 pixel_to_object = mat3(vec3(object_right_vec.x, object_down_vec.x, 0.0), vec3(object_right_vec.y, object_down_vec.y, 0.0), vec3(object_right_vec.z, object_down_vec.z, 0.0));
    return pixel_to_object;
}

highp mat3 hrg_get_object_to_tangent_matrix(highp vec3 intersection_pos_local, highp vec3 normal, highp vec2 output_aspect, highp float in_geom_mode)
{
    highp vec3 pos = intersection_pos_local;
    highp vec3 x_vec = vec3(1.0, 0.0, 0.0);
    highp vec3 y_vec = vec3(0.0, 1.0, 0.0);
    highp vec3 cotangent_unscaled;
    highp vec3 cobitangent_unscaled;
    if (in_geom_mode < 1.5)
    {
        cotangent_unscaled = normalize(cross(y_vec, pos)) * output_aspect.y;
        cobitangent_unscaled = normalize(cross(x_vec, pos)) * output_aspect.x;
    }
    else
    {
        if (in_geom_mode < 2.5)
        {
            highp vec3 tangent = normalize(cross(y_vec, vec3(pos.x, 0.0, pos.z))) * output_aspect.x;
            highp vec3 bitangent = normalize(cross(x_vec, vec3(0.0, pos.yz))) * output_aspect.y;
            cotangent_unscaled = cross(normal, bitangent);
            cobitangent_unscaled = cross(tangent, normal);
        }
        else
        {
            cotangent_unscaled = cross(y_vec, normal) * output_aspect.y;
            cobitangent_unscaled = vec3(0.0, -output_aspect.x, 0.0);
        }
    }
    highp vec3 computed_normal = cross(cobitangent_unscaled, cotangent_unscaled);
    highp float inv_determinant = inversesqrt(dot(computed_normal, computed_normal));
    highp vec3 cotangent = cotangent_unscaled * inv_determinant;
    highp vec3 cobitangent = cobitangent_unscaled * inv_determinant;
    highp mat3 object_to_tangent = mat3(vec3(cotangent), vec3(cobitangent), vec3(normal));
    return object_to_tangent;
}

highp vec2 hrg_get_curved_video_uv_coords_and_tangent_matrix(highp vec2 flat_video_uv, highp vec3 eye_pos_local, highp vec2 output_pixel_size, highp vec2 output_aspect, highp float in_geom_mode, highp float in_geom_radius, highp float in_geom_view_dist, highp mat3 global_to_local, out highp mat2 pixel_to_tangent_video_uv)
{
    highp vec2 view_uv = (flat_video_uv - vec2(0.5)) * output_aspect;
    highp vec3 view_vec_global = vec3(view_uv.x, -view_uv.y, -in_geom_view_dist);
    highp vec3 view_vec_local = view_vec_global * global_to_local;
    highp vec3 param = view_vec_local;
    highp vec3 param_1 = eye_pos_local;
    highp vec2 param_2 = output_aspect;
    highp float param_3 = in_geom_mode;
    highp float param_4 = in_geom_radius;
    highp vec3 param_5;
    highp vec2 _4633 = hrg_view_vec_to_uv(param, param_1, param_2, param_3, param_4, param_5);
    highp vec3 pos = param_5;
    highp vec2 centered_uv = _4633;
    highp vec2 video_uv = centered_uv + vec2(0.5);
    bool geom_force_correct_tangent_matrix = true;
    if (geom_force_correct_tangent_matrix)
    {
        highp vec3 _4645;
        if (in_geom_mode < 2.5)
        {
            _4645 = pos;
        }
        else
        {
            _4645 = vec3(pos.x, 0.0, pos.z);
        }
        highp vec3 normal_base = _4645;
        highp vec3 normal = normalize(normal_base);
        highp mat3 param_6 = global_to_local;
        highp vec3 param_7 = eye_pos_local;
        highp vec3 param_8 = view_vec_global;
        highp vec3 param_9 = pos;
        highp vec3 param_10 = normal;
        highp vec2 param_11 = output_pixel_size;
        highp mat3 pixel_to_object = hrg_get_pixel_to_object_matrix(param_6, param_7, param_8, param_9, param_10, param_11);
        highp vec3 param_12 = pos;
        highp vec3 param_13 = normal;
        highp vec2 param_14 = output_aspect;
        highp float param_15 = in_geom_mode;
        highp mat3 object_to_tangent = hrg_get_object_to_tangent_matrix(param_12, param_13, param_14, param_15);
        highp mat3 pixel_to_tangent3x3 = pixel_to_object * object_to_tangent;
        pixel_to_tangent_video_uv = mat2(vec2(pixel_to_tangent3x3[0].x, pixel_to_tangent3x3[0].y), vec2(pixel_to_tangent3x3[1].x, pixel_to_tangent3x3[1].y));
    }
    else
    {
        pixel_to_tangent_video_uv = mat2(vec2(output_pixel_size.x, 0.0), vec2(0.0, output_pixel_size.y));
    }
    return video_uv;
}

highp vec2 HRG_GetGeomCurvedCoord(highp vec2 in_coord, highp float in_geom_mode, highp float in_geom_radius, highp float in_geom_view_dist, highp float in_geom_tilt_angle_x, highp float in_geom_tilt_angle_y, highp float in_screen_aspect, highp float pin_inner_edge, highp vec2 in_source_size, highp vec2 in_output_size, out highp mat2 pixel_to_video_uv)
{
    highp vec2 output_pixel_size = vec2(1.0) / in_output_size;
    highp float geom_radius_scaled = in_geom_radius;
    highp float param = in_screen_aspect;
    highp vec2 output_aspect = hrg_get_aspect_vector(param);
    highp vec2 geom_tilt_angle = vec2(in_geom_tilt_angle_x, in_geom_tilt_angle_y);
    highp vec2 sin_tilt = sin(geom_tilt_angle);
    highp vec2 cos_tilt = cos(geom_tilt_angle);
    highp mat3 rot_x_matrix = mat3(vec3(1.0, 0.0, 0.0), vec3(0.0, cos_tilt.y, -sin_tilt.y), vec3(0.0, sin_tilt.y, cos_tilt.y));
    highp mat3 rot_y_matrix = mat3(vec3(cos_tilt.x, 0.0, sin_tilt.x), vec3(0.0, 1.0, 0.0), vec3(-sin_tilt.x, 0.0, cos_tilt.x));
    highp mat3 local_to_global = rot_x_matrix * rot_y_matrix;
    highp mat3 global_to_local = transpose(local_to_global);
    highp mat3 param_1 = local_to_global;
    highp vec2 param_2 = output_aspect;
    highp float param_3 = in_geom_mode;
    highp float param_4 = geom_radius_scaled;
    highp float param_5 = in_geom_view_dist;
    highp vec3 eye_pos_global = hrg_get_ideal_global_eye_pos(param_1, param_2, param_3, param_4, param_5);
    highp vec3 eye_pos_local = eye_pos_global * global_to_local;
    highp vec2 curved_coord;
    if (in_geom_mode > 0.5)
    {
        highp vec2 param_6 = in_coord;
        highp vec3 param_7 = eye_pos_local;
        highp vec2 param_8 = output_pixel_size;
        highp vec2 param_9 = output_aspect;
        highp float param_10 = in_geom_mode;
        highp float param_11 = geom_radius_scaled;
        highp float param_12 = in_geom_view_dist;
        highp mat3 param_13 = global_to_local;
        highp mat2 param_14;
        highp vec2 _4813 = hrg_get_curved_video_uv_coords_and_tangent_matrix(param_6, param_7, param_8, param_9, param_10, param_11, param_12, param_13, param_14);
        pixel_to_video_uv = param_14;
        highp vec2 ctr_curved_coord = _4813 - vec2(0.5);
        if ((in_geom_tilt_angle_x == 0.0) && (in_geom_tilt_angle_y == 0.0))
        {
            highp vec2 param_15 = vec2(1.0, 0.5);
            highp vec3 param_16 = eye_pos_local;
            highp vec2 param_17 = output_pixel_size;
            highp vec2 param_18 = output_aspect;
            highp float param_19 = in_geom_mode;
            highp float param_20 = geom_radius_scaled;
            highp float param_21 = in_geom_view_dist;
            highp mat3 param_22 = global_to_local;
            highp mat2 param_23;
            highp vec2 _4842 = hrg_get_curved_video_uv_coords_and_tangent_matrix(param_15, param_16, param_17, param_18, param_19, param_20, param_21, param_22, param_23);
            pixel_to_video_uv = param_23;
            highp vec2 right_edge_curved_ctr_coord = _4842 - vec2(0.5);
            highp vec2 param_24 = vec2(0.5, 1.0);
            highp vec3 param_25 = eye_pos_local;
            highp vec2 param_26 = output_pixel_size;
            highp vec2 param_27 = output_aspect;
            highp float param_28 = in_geom_mode;
            highp float param_29 = geom_radius_scaled;
            highp float param_30 = in_geom_view_dist;
            highp mat3 param_31 = global_to_local;
            highp mat2 param_32;
            highp vec2 _4864 = hrg_get_curved_video_uv_coords_and_tangent_matrix(param_24, param_25, param_26, param_27, param_28, param_29, param_30, param_31, param_32);
            pixel_to_video_uv = param_32;
            highp vec2 bottom_edge_curved_ctr_coord = _4864 - vec2(0.5);
            ctr_curved_coord.x = (ctr_curved_coord.x * 0.5) / right_edge_curved_ctr_coord.x;
            ctr_curved_coord.y = (ctr_curved_coord.y * 0.5) / bottom_edge_curved_ctr_coord.y;
        }
        if (pin_inner_edge == 1.0)
        {
            if (in_geom_tilt_angle_y != 0.0)
            {
                highp vec2 param_33 = vec2(0.5, 0.0);
                highp vec3 param_34 = eye_pos_local;
                highp vec2 param_35 = output_pixel_size;
                highp vec2 param_36 = output_aspect;
                highp float param_37 = in_geom_mode;
                highp float param_38 = geom_radius_scaled;
                highp float param_39 = in_geom_view_dist;
                highp mat3 param_40 = global_to_local;
                highp mat2 param_41;
                highp vec2 _4907 = hrg_get_curved_video_uv_coords_and_tangent_matrix(param_33, param_34, param_35, param_36, param_37, param_38, param_39, param_40, param_41);
                pixel_to_video_uv = param_41;
                highp vec2 top_edge_curved_ctr_coord = _4907;
                ctr_curved_coord.y -= top_edge_curved_ctr_coord.y;
            }
            if (in_geom_tilt_angle_x != 0.0)
            {
                highp vec2 param_42 = vec2(0.0, 0.5);
                highp vec3 param_43 = eye_pos_local;
                highp vec2 param_44 = output_pixel_size;
                highp vec2 param_45 = output_aspect;
                highp float param_46 = in_geom_mode;
                highp float param_47 = geom_radius_scaled;
                highp float param_48 = in_geom_view_dist;
                highp mat3 param_49 = global_to_local;
                highp mat2 param_50;
                highp vec2 _4936 = hrg_get_curved_video_uv_coords_and_tangent_matrix(param_42, param_43, param_44, param_45, param_46, param_47, param_48, param_49, param_50);
                pixel_to_video_uv = param_50;
                highp vec2 left_edge_curved_ctr_coord = _4936;
                ctr_curved_coord.x -= left_edge_curved_ctr_coord.x;
            }
        }
        curved_coord = ctr_curved_coord + vec2(0.5);
    }
    else
    {
        curved_coord = in_coord;
        pixel_to_video_uv = mat2(vec2(output_pixel_size.x, 0.0), vec2(0.0, output_pixel_size.y));
    }
    return curved_coord;
}

highp vec2 HSM_GetCurvatureValues(highp float screen_aspect)
{
    highp vec2 _5220;
    if (screen_aspect < 1.0)
    {
        _5220 = vec2((((2.0 * global.HSM_CURVATURE_2D_SCALE_SHORT_AXIS) / 100.0) * 2.0) / 100.0, ((global.HSM_CURVATURE_2D_SCALE_LONG_AXIS / 100.0) * 3.0) / 100.0);
    }
    else
    {
        _5220 = vec2(((global.HSM_CURVATURE_2D_SCALE_LONG_AXIS / 100.0) * 3.0) / 100.0, (((2.0 * global.HSM_CURVATURE_2D_SCALE_SHORT_AXIS) / 100.0) * 2.0) / 100.0);
    }
    highp vec2 curvature_values = _5220;
    return curvature_values;
}

highp vec2 HSM_GetCrtPiCurvedCoord(inout highp vec2 in_coord, inout highp vec2 in_curvature)
{
    in_curvature *= 5.0;
    highp vec2 barrelScale = vec2(1.0) - (in_curvature * 0.23000000417232513427734375);
    in_coord -= vec2(0.5);
    highp float _5723;
    if (HSM_CURVATURE_MODE == 2.0)
    {
        _5723 = 0.0;
    }
    else
    {
        _5723 = in_coord.y * in_coord.y;
    }
    highp float rsq = (in_coord.x * in_coord.x) + _5723;
    in_coord += (in_coord * (in_curvature * rsq));
    in_coord *= barrelScale;
    in_coord += vec2(0.5);
    return in_coord;
}

highp vec2 HSM_Get2DCurvedCoord(highp vec2 in_coord, highp vec2 curvature_values)
{
    highp vec2 ctr_curved_coord = vec2(0.0);
    highp vec2 param = in_coord;
    highp vec2 param_1 = curvature_values;
    highp vec2 _5754 = HSM_GetCrtPiCurvedCoord(param, param_1);
    ctr_curved_coord = _5754 - vec2(0.5);
    highp vec2 param_2 = vec2(1.0, 0.5);
    highp vec2 param_3 = curvature_values;
    highp vec2 _5761 = HSM_GetCrtPiCurvedCoord(param_2, param_3);
    highp vec2 right_edge_curved_ctr_coord = _5761 - vec2(0.5);
    ctr_curved_coord.x = (ctr_curved_coord.x * 0.5) / right_edge_curved_ctr_coord.x;
    highp vec2 param_4 = vec2(0.5, 1.0);
    highp vec2 param_5 = curvature_values;
    highp vec2 _5775 = HSM_GetCrtPiCurvedCoord(param_4, param_5);
    highp vec2 bottom_edge_curved_ctr_coord = _5775 - vec2(0.5);
    ctr_curved_coord.y = (ctr_curved_coord.y * 0.5) / bottom_edge_curved_ctr_coord.y;
    return ctr_curved_coord + vec2(0.5);
}

highp vec2 HSM_GetCurvedCoord(highp vec2 in_coord, highp float curvature_multiplier, highp float screen_aspect)
{
    if (HSM_CURVATURE_MODE == CURVATURE_MODE_OFF)
    {
        return in_coord;
    }
    highp float epsilon = 0.00200000009499490261077880859375;
    highp vec2 adjusted_coord = in_coord;
    highp float tilt_angle_y = HSM_CURVATURE_3D_TILT_ANGLE_Y;
    highp float tilt_angle_x = HSM_CURVATURE_3D_TILT_ANGLE_X;
    highp float pin_inner_edge = 0.0;
    highp vec2 curved_coord = vec2(0.0);
    if (HSM_CURVATURE_MODE > CURVATURE_MODE_2D_CYLINDER)
    {
        if (HSM_USE_GEOM > 0.5)
        {
            highp vec2 param = in_coord;
            highp float param_1 = HSM_CURVATURE_3D_TILT_ANGLE_X;
            highp float param_2 = HSM_CURVATURE_3D_TILT_ANGLE_Y;
            highp float param_3 = HSM_CURVATURE_3D_RADIUS;
            highp float param_4 = HSM_CURVATURE_3D_VIEW_DIST;
            highp float param_5 = screen_aspect;
            curved_coord = HSM_GetGeomCurvedCoordRetainWidth(param, param_1, param_2, param_3, param_4, param_5);
        }
        else
        {
            highp float geom_radius_with_mult = HSM_CURVATURE_3D_RADIUS;
            if (HSM_CURVATURE_MODE == CURVATURE_MODE_3D_1)
            {
                geom_radius_with_mult -= 0.4000000059604644775390625;
            }
            if (HSM_CURVATURE_MODE == CURVATURE_MODE_3D_CYLINDER)
            {
                geom_radius_with_mult -= 1.0;
            }
            geom_radius_with_mult *= (1.0 / (curvature_multiplier + epsilon));
            highp float geom_mode = HSM_CURVATURE_MODE - 2.0;
            highp vec2 param_6 = adjusted_coord;
            highp float param_7 = geom_mode;
            highp float param_8 = geom_radius_with_mult;
            highp float param_9 = HSM_CURVATURE_3D_VIEW_DIST;
            highp float param_10 = tilt_angle_x;
            highp float param_11 = tilt_angle_y;
            highp float param_12 = screen_aspect;
            highp float param_13 = pin_inner_edge;
            highp vec2 param_14 = global.SourceSize.xy;
            highp vec2 param_15 = global.OutputSize.xy;
            highp mat2 param_16;
            highp vec2 _5883 = HRG_GetGeomCurvedCoord(param_6, param_7, param_8, param_9, param_10, param_11, param_12, param_13, param_14, param_15, param_16);
            highp mat2 pixel_to_video_uv = param_16;
            curved_coord = _5883;
        }
    }
    else
    {
        highp float param_17 = screen_aspect;
        highp vec2 curvature_values = HSM_GetCurvatureValues(param_17) * curvature_multiplier;
        highp vec2 param_18 = adjusted_coord;
        highp vec2 param_19 = curvature_values;
        curved_coord = HSM_Get2DCurvedCoord(param_18, param_19);
    }
    return curved_coord;
}

highp vec2 HSM_GetTubeCurvedCoord(highp vec2 screen_coord, highp float curvature_scale, highp vec2 screen_scale, highp vec2 tube_scale, highp float screen_aspect, highp float apply_black_edge_offset)
{
    highp vec2 black_edge_scale_offset = tube_scale / screen_scale;
    highp vec2 tube_curved_coord = vec2(0.5);
    if (global.HSM_BZL_USE_INDEPENDENT_CURVATURE == 1.0)
    {
        highp vec2 _6022;
        if (screen_aspect < 1.0)
        {
            _6022 = vec2((((2.0 * global.HSM_BZL_INDEPENDENT_CURVATURE_SCALE_SHORT_AXIS) / 100.0) * 2.0) / 100.0, ((global.HSM_BZL_INDEPENDENT_CURVATURE_SCALE_LONG_AXIS / 100.0) * 3.0) / 100.0);
        }
        else
        {
            _6022 = vec2(((global.HSM_BZL_INDEPENDENT_CURVATURE_SCALE_LONG_AXIS / 100.0) * 3.0) / 100.0, (((2.0 * global.HSM_BZL_INDEPENDENT_CURVATURE_SCALE_SHORT_AXIS) / 100.0) * 2.0) / 100.0);
        }
        highp vec2 curvature_values = _6022;
        curvature_values *= ((curvature_scale * global.HSM_BZL_INNER_CURVATURE_SCALE) / 100.0);
        highp vec2 param = screen_coord;
        highp vec2 param_1 = curvature_values;
        tube_curved_coord = HSM_Get2DCurvedCoord(param, param_1);
    }
    else
    {
        highp vec2 param_2 = screen_coord;
        highp float param_3 = (curvature_scale * global.HSM_BZL_INNER_CURVATURE_SCALE) / 100.0;
        highp float param_4 = screen_aspect;
        tube_curved_coord = HSM_GetCurvedCoord(param_2, param_3, param_4);
    }
    if (apply_black_edge_offset == 1.0)
    {
        highp vec2 param_5 = tube_curved_coord;
        highp vec2 param_6 = black_edge_scale_offset;
        tube_curved_coord = HSM_GetInverseScaledCoord(param_5, param_6);
    }
    return tube_curved_coord;
}

highp float HSM_GetCornerMask(highp vec2 in_coord, highp float screen_aspect, highp float corner_radius, highp float edge_sharpness)
{
    highp vec2 new_coord = min(in_coord, vec2(1.0) - in_coord) * vec2(screen_aspect, 1.0);
    highp vec2 corner_distance = vec2(max(corner_radius / 1000.0, (1.0 - edge_sharpness) * 0.00999999977648258209228515625));
    new_coord = corner_distance - min(new_coord, corner_distance);
    highp float _distance = sqrt(dot(new_coord, new_coord));
    return clamp((corner_distance.x - _distance) * ((edge_sharpness * 500.0) + 100.0), 0.0, 1.0);
}

highp vec2 HSM_GetOuterBezelScale(highp vec2 tube_diffuse_scale, highp float screen_aspect)
{
    highp vec2 bezel_outer_scale_offset = vec2((HSM_BZL_WIDTH / screen_aspect) + 1.0, HSM_BZL_HEIGHT + 1.0);
    return bezel_outer_scale_offset;
}

highp vec2 GetDefaultScreenScale()
{
    highp float output_aspect = global.FinalViewportSize.x / global.FinalViewportSize.y;
    highp vec2 out_placement_scale = vec2(1.1058499813079833984375, 0.82959997653961181640625);
    out_placement_scale.x /= output_aspect;
    return out_placement_scale;
}

highp vec2 GetDefaultBezelScale()
{
    highp float output_aspect = global.FinalViewportSize.x / global.FinalViewportSize.y;
    highp vec2 out_placement_scale = vec2(1.20500004291534423828125, 0.9110000133514404296875);
    out_placement_scale.x /= output_aspect;
    return out_placement_scale;
}

highp float HSM_GetBezelCoords(highp vec2 tube_diffuse_coord, highp vec2 tube_diffuse_scale, highp vec2 tube_scale, highp float screen_aspect, bool curve_coords_on, out highp vec2 bezel_outside_scale, inout highp vec2 bezel_outside_coord, inout highp vec2 bezel_outside_curved_coord, inout highp vec2 frame_outside_curved_coord)
{
    highp float output_aspect = global.OutputSize.x / global.OutputSize.y;
    highp vec2 bezel_outer_pos_offset = vec2(0.0, HSM_BZL_OUTER_POSITION_Y);
    highp vec2 param = tube_diffuse_scale;
    highp float param_1 = screen_aspect;
    highp vec2 bezel_outer_scale_offset = HSM_GetOuterBezelScale(param, param_1);
    bezel_outside_coord = tube_diffuse_coord + bezel_outer_pos_offset;
    bezel_outside_curved_coord = bezel_outside_coord;
    if (curve_coords_on)
    {
        bool _6551 = HSM_CURVATURE_MODE > 0.0;
        bool _6559;
        if (_6551)
        {
            _6559 = (HSM_CURVATURE_3D_TILT_ANGLE_X != 0.0) || (HSM_CURVATURE_3D_TILT_ANGLE_Y != 0.0);
        }
        else
        {
            _6559 = _6551;
        }
        if (_6559)
        {
            highp vec2 param_2 = bezel_outside_curved_coord;
            highp float param_3 = 0.0;
            highp float param_4 = (bezel_outer_scale_offset.x * output_aspect) / bezel_outer_scale_offset.y;
            bezel_outside_curved_coord = HSM_GetCurvedCoord(param_2, param_3, param_4);
        }
    }
    highp vec2 black_edge_scale_offset = tube_scale / tube_diffuse_scale;
    bezel_outside_scale = (tube_diffuse_scale * black_edge_scale_offset) * bezel_outer_scale_offset;
    highp vec2 param_5 = bezel_outside_coord;
    highp vec2 param_6 = black_edge_scale_offset * bezel_outer_scale_offset;
    bezel_outside_coord = HSM_GetInverseScaledCoord(param_5, param_6) + vec2(0.0, HSM_BZL_OUTER_POSITION_Y);
    highp vec2 param_7 = bezel_outside_curved_coord;
    highp vec2 param_8 = black_edge_scale_offset * bezel_outer_scale_offset;
    bezel_outside_curved_coord = HSM_GetInverseScaledCoord(param_7, param_8) + vec2(0.0, HSM_BZL_OUTER_POSITION_Y);
    frame_outside_curved_coord = (((bezel_outside_curved_coord + vec2(0.0, HSM_FRM_OUTER_POS_Y)) - vec2(0.5)) / vec2(((HSM_FRM_THICKNESS * HSM_FRM_THICKNESS_SCALE_X) / ((tube_diffuse_scale.x / tube_diffuse_scale.y) * output_aspect)) + 1.0, HSM_FRM_THICKNESS + 1.0)) + vec2(0.5);
    if (HSM_BZL_OUTER_CURVATURE_SCALE > 0.0)
    {
        if (curve_coords_on)
        {
            highp vec2 param_9 = bezel_outside_curved_coord;
            highp float param_10 = HSM_BZL_OUTER_CURVATURE_SCALE;
            highp vec2 param_11 = tube_diffuse_scale;
            highp vec2 param_12 = tube_scale;
            highp float param_13 = ((bezel_outer_scale_offset.x * global.OutputSize.x) / global.OutputSize.y) / bezel_outer_scale_offset.y;
            highp float param_14 = 0.0;
            bezel_outside_curved_coord = HSM_GetTubeCurvedCoord(param_9, param_10, param_11, param_12, param_13, param_14);
        }
        if (curve_coords_on)
        {
            if (HSM_FRM_OUTER_CURVATURE_SCALE > 0.0)
            {
                highp vec2 param_15 = frame_outside_curved_coord;
                highp float param_16 = HSM_BZL_OUTER_CURVATURE_SCALE * HSM_FRM_OUTER_CURVATURE_SCALE;
                highp vec2 param_17 = tube_diffuse_scale;
                highp vec2 param_18 = tube_scale;
                highp float param_19 = ((bezel_outer_scale_offset.x * global.OutputSize.x) / global.OutputSize.y) / bezel_outer_scale_offset.y;
                highp float param_20 = 0.0;
                frame_outside_curved_coord = HSM_GetTubeCurvedCoord(param_15, param_16, param_17, param_18, param_19, param_20);
            }
        }
    }
    DEFAULT_SCREEN_SCALE = GetDefaultScreenScale();
    DEFAULT_BEZEL_SCALE = GetDefaultBezelScale();
    return 0.0;
}

highp float HHLP_GetDistanceToLine(highp float x1, highp float y1, highp float a, highp float b, highp float c)
{
    highp float d = abs(((a * x1) + (b * y1)) + c) / sqrt((a * a) + (b * b));
    return d;
}

highp float HHLP_QuadraticBezier(highp float x, inout highp vec2 a)
{
    highp float epsilon = 9.9999997473787516355514526367188e-06;
    a.x = clamp(a.x, 0.0, 1.0);
    a.y = clamp(a.y, 0.0, 1.0);
    if (a.x == 0.5)
    {
        a += vec2(epsilon);
    }
    highp float om2a = 1.0 - (2.0 * a.x);
    highp float t = (sqrt((a.x * a.x) + (om2a * x)) - a.x) / om2a;
    highp float y = ((1.0 - (2.0 * a.y)) * (t * t)) + ((2.0 * a.y) * t);
    return y;
}

highp vec4 HSM_PreMultAlphaBlend(highp vec4 color_under, highp vec4 color_over)
{
    highp vec4 out_color = vec4(color_over.xyz + (color_under.xyz * (1.0 - color_over.w)), clamp(color_under.w + color_over.w, 0.0, 1.0));
    return out_color;
}

highp vec4 HSM_BlendModeLayerMix(highp vec4 color_under, inout highp vec4 color_over, highp float blend_mode, highp float layer_opacity)
{
    if (blend_mode == 0.0)
    {
        return color_under;
    }
    if (blend_mode == BLEND_MODE_OFF)
    {
        return color_under;
    }
    color_over.w *= layer_opacity;
    highp vec4 out_color = vec4(0.0);
    if (blend_mode == BLEND_MODE_NORMAL)
    {
        highp float _2930 = color_over.w;
        highp vec4 _2931 = color_over;
        highp vec3 _2933 = _2931.xyz * _2930;
        color_over.x = _2933.x;
        color_over.y = _2933.y;
        color_over.z = _2933.z;
        highp vec4 param = color_under;
        highp vec4 param_1 = color_over;
        out_color = HSM_PreMultAlphaBlend(param, param_1);
    }
    else
    {
        highp vec4 blend_color = color_under;
        if (blend_mode == BLEND_MODE_ADD)
        {
            highp vec3 _2957 = color_under.xyz + color_over.xyz;
            blend_color.x = _2957.x;
            blend_color.y = _2957.y;
            blend_color.z = _2957.z;
        }
        if (blend_mode == BLEND_MODE_MULTIPLY)
        {
            highp vec3 _2973 = color_under.xyz * color_over.xyz;
            blend_color.x = _2973.x;
            blend_color.y = _2973.y;
            blend_color.z = _2973.z;
        }
        out_color = vec4(clamp(mix(color_under.xyz, blend_color.xyz, vec3(color_over.w)), vec3(0.0), vec3(1.0)), color_under.w);
    }
    return out_color;
}

highp vec3 ApplyAmbientImages(highp vec3 base_image, inout highp vec3 ambient_image, inout highp vec3 ambient2_image, highp float blend_ambient, highp float blend_ambient2, highp float apply_in_add_mode, highp float layer_blend_mode, highp float swap_images)
{
    highp vec3 outImage = base_image;
    if (swap_images == 1.0)
    {
        ambient2_image = ambient_image;
    }
    if (swap_images == 2.0)
    {
        ambient_image = ambient2_image;
    }
    if (swap_images == 3.0)
    {
        highp vec3 temp_image = ambient_image;
        ambient_image = ambient2_image;
        ambient2_image = temp_image;
    }
    bool _6431 = (HSM_AMBIENT1_OPACITY > 0.0) || (HSM_AMBIENT2_OPACITY > 0.0);
    bool _6439;
    if (_6431)
    {
        _6439 = (blend_ambient > 0.0) || (blend_ambient2 > 0.0);
    }
    else
    {
        _6439 = _6431;
    }
    if (_6439)
    {
        if ((apply_in_add_mode == 1.0) || (layer_blend_mode != BLEND_MODE_ADD))
        {
            if (blend_ambient > 0.0)
            {
                outImage = (outImage * (1.0 - blend_ambient)) + ((outImage * blend_ambient) * ambient_image);
            }
            if (blend_ambient2 > 0.0)
            {
                outImage = (outImage * (1.0 - blend_ambient2)) + ((outImage * blend_ambient2) * ambient2_image);
            }
        }
    }
    return outImage;
}

highp float GetMask(highp float mask_mode)
{
    highp float _6694;
    if (mask_mode == 0.0)
    {
        _6694 = 1.0;
    }
    else
    {
        highp float _6700;
        if (mask_mode == 1.0)
        {
            _6700 = TUBE_DIFFUSE_MASK;
        }
        else
        {
            highp float _6707;
            if (mask_mode == 2.0)
            {
                _6707 = TUBE_MASK;
            }
            else
            {
                highp float _6714;
                if (mask_mode == 3.0)
                {
                    _6714 = INSIDE_BEZEL_MASK;
                }
                else
                {
                    highp float _6721;
                    if (mask_mode == 4.0)
                    {
                        _6721 = BEZEL_MASK;
                    }
                    else
                    {
                        highp float _6728;
                        if (mask_mode == 5.0)
                        {
                            _6728 = OUTSIDE_TUBE_MASK_FOR_IMAGE;
                        }
                        else
                        {
                            highp float _6735;
                            if (mask_mode == 6.0)
                            {
                                _6735 = FRAME_MASK;
                            }
                            else
                            {
                                highp float _6743;
                                if (mask_mode == 7.0)
                                {
                                    _6743 = OUTSIDE_BEZEL_MASK;
                                }
                                else
                                {
                                    _6743 = (mask_mode == 8.0) ? OUTSIDE_FRAME_MASK : 0.5;
                                }
                                _6735 = _6743;
                            }
                            _6728 = _6735;
                        }
                        _6721 = _6728;
                    }
                    _6714 = _6721;
                }
                _6707 = _6714;
            }
            _6700 = _6707;
        }
        _6694 = _6700;
    }
    highp float mask = _6694;
    return mask;
}

highp vec4 BlendModeMaskLayerMix(highp vec4 color_under, inout highp vec4 color_over, highp float blend_mode, highp float mask_mode, highp float cutout_mode, highp float dualscreen_mode, highp float layer_opacity)
{
    bool _6764 = blend_mode == 0.0;
    bool _6774;
    if (!_6764)
    {
        _6774 = (dualscreen_mode != 0.0) && (dualscreen_mode != SCREEN_INDEX);
    }
    else
    {
        _6774 = _6764;
    }
    if (_6774)
    {
        return color_under;
    }
    highp float cutout_mask = 1.0;
    if (cutout_mode == 1.0)
    {
        cutout_mask = CUTOUT_MASK;
    }
    if (cutout_mode == 2.0)
    {
        cutout_mask = 1.0 - CUTOUT_MASK;
    }
    if (blend_mode == BLEND_MODE_OFF)
    {
        return color_under;
    }
    highp float param = mask_mode;
    color_over.w *= ((layer_opacity * GetMask(param)) * cutout_mask);
    highp vec4 out_color = vec4(0.0);
    if (blend_mode == BLEND_MODE_NORMAL)
    {
        highp float _6816 = color_over.w;
        highp vec4 _6817 = color_over;
        highp vec3 _6819 = _6817.xyz * _6816;
        color_over.x = _6819.x;
        color_over.y = _6819.y;
        color_over.z = _6819.z;
        highp vec4 param_1 = color_under;
        highp vec4 param_2 = color_over;
        out_color = HSM_PreMultAlphaBlend(param_1, param_2);
    }
    else
    {
        highp vec4 blend_color = color_under;
        if (blend_mode == BLEND_MODE_ADD)
        {
            highp vec3 _6843 = color_under.xyz + color_over.xyz;
            blend_color.x = _6843.x;
            blend_color.y = _6843.y;
            blend_color.z = _6843.z;
        }
        if (blend_mode == BLEND_MODE_MULTIPLY)
        {
            highp vec3 _6859 = color_under.xyz * color_over.xyz;
            blend_color.x = _6859.x;
            blend_color.y = _6859.y;
            blend_color.z = _6859.z;
        }
        out_color = vec4(clamp(mix(color_under.xyz, blend_color.xyz, vec3(color_over.w)), vec3(0.0), vec3(1.0)), color_under.w);
    }
    return out_color;
}

highp float HSM_GetAspectRatioFromMode(highp float in_aspect_ratio_mode, highp float in_explicit_aspect)
{
    highp float out_explicit_aspect = in_explicit_aspect;
    if (in_aspect_ratio_mode == 0.0)
    {
        out_explicit_aspect = global.OutputSize.x / global.OutputSize.y;
    }
    if (in_aspect_ratio_mode == 2.0)
    {
        out_explicit_aspect = 1.33333003520965576171875;
    }
    if (in_aspect_ratio_mode == 3.0)
    {
        out_explicit_aspect = 0.75;
    }
    if (in_aspect_ratio_mode == 4.0)
    {
        out_explicit_aspect = 1.777699947357177734375;
    }
    if (in_aspect_ratio_mode == 5.0)
    {
        out_explicit_aspect = 0.5625;
    }
    return out_explicit_aspect;
}

highp vec2 HSM_GetScaledCoord(highp vec2 in_viewport_coord, highp vec2 in_viewport_coord_unscaled, highp float texture_aspect_mode, inout highp float explicit_texture_aspect, highp vec2 offset_pos, inout highp vec2 offset_scale, highp float layer_to_follow, highp float follow_mode, highp float scale_full_with_zoom, highp float image_fill_mode, highp float split_preserve_center, highp float split_repeat_width, bool apply_default_scale_offset, inout highp vec2 out_placement_coord, inout highp vec2 out_placement_scale)
{
    highp float param = texture_aspect_mode;
    highp float param_1 = explicit_texture_aspect;
    explicit_texture_aspect = HSM_GetAspectRatioFromMode(param, param_1);
    highp vec2 inherited_coord = in_viewport_coord / vec2(0.5);
    highp vec2 inherited_placement_coord = in_viewport_coord / vec2(0.5);
    highp vec2 inherited_final_coord = in_viewport_coord / vec2(0.5);
    highp vec2 inherited_scale = vec2(0.5);
    highp vec2 default_offset_scale = vec2(0.5);
    if (layer_to_follow == 0.0)
    {
        if (scale_full_with_zoom > 0.5)
        {
            inherited_coord = in_viewport_coord;
            inherited_placement_coord = in_viewport_coord;
        }
        else
        {
            inherited_coord = in_viewport_coord_unscaled;
            inherited_placement_coord = in_viewport_coord_unscaled;
        }
        inherited_final_coord = inherited_coord;
        inherited_scale = vec2(1.0);
        default_offset_scale = vec2(1.0);
    }
    else
    {
        if (layer_to_follow == 1.0)
        {
            inherited_coord = TUBE_DIFFUSE_COORD;
            inherited_placement_coord = TUBE_DIFFUSE_COORD;
            inherited_final_coord = TUBE_DIFFUSE_CURVED_COORD;
            inherited_scale = TUBE_DIFFUSE_SCALE;
            default_offset_scale = vec2(1.2054002285003662109375);
            default_offset_scale.x *= (explicit_texture_aspect / DEFAULT_SCREEN_ASPECT);
        }
        else
        {
            if (layer_to_follow == 2.0)
            {
                inherited_coord = BEZEL_OUTSIDE_COORD;
                inherited_placement_coord = BEZEL_OUTSIDE_COORD;
                inherited_scale = BEZEL_OUTSIDE_SCALE;
                inherited_final_coord = BEZEL_OUTSIDE_CURVED_COORD;
                default_offset_scale = vec2(1.097694873809814453125);
                default_offset_scale.x *= (explicit_texture_aspect / DEFAULT_BEZEL_ASPECT);
            }
            else
            {
                if (layer_to_follow == 3.0)
                {
                    inherited_coord = BACKGROUND_COORD;
                    inherited_placement_coord = BACKGROUND_COORD;
                    inherited_final_coord = BACKGROUND_CURVED_COORD;
                    inherited_scale = BACKGROUND_SCALE;
                    default_offset_scale = vec2(1.0);
                }
                else
                {
                    if (layer_to_follow == 4.0)
                    {
                        inherited_coord = DEVICE_COORD;
                        inherited_placement_coord = DEVICE_COORD;
                        inherited_final_coord = DEVICE_CURVED_COORD;
                        inherited_scale = DEVICE_SCALE;
                        default_offset_scale = vec2(1.0);
                    }
                    else
                    {
                        if (layer_to_follow == 5.0)
                        {
                            inherited_coord = DECAL_COORD;
                            inherited_placement_coord = DECAL_COORD;
                            inherited_final_coord = DECAL_CURVED_COORD;
                            inherited_scale = DECAL_SCALE;
                            default_offset_scale = vec2(1.0);
                        }
                    }
                }
            }
        }
    }
    if (follow_mode == FOLLOW_MODE_EXACT)
    {
        highp vec2 param_2 = inherited_placement_coord;
        highp vec2 param_3 = offset_pos;
        highp vec2 param_4 = offset_scale;
        out_placement_coord = HSM_AddPosScaleToCoord(param_2, param_3, param_4);
        out_placement_scale = inherited_scale * offset_scale;
        highp vec2 param_5 = inherited_final_coord;
        highp vec2 param_6 = offset_pos;
        highp vec2 param_7 = offset_scale;
        return HSM_AddPosScaleToCoord(param_5, param_6, param_7);
    }
    if (apply_default_scale_offset)
    {
        offset_scale *= default_offset_scale;
    }
    highp float output_aspect = global.OutputSize.x / global.OutputSize.y;
    highp float inherited_aspect = ((inherited_scale.x / inherited_scale.y) * (default_offset_scale.x / default_offset_scale.y)) * output_aspect;
    highp float inherited_aspect_difference = explicit_texture_aspect / inherited_aspect;
    out_placement_scale = inherited_scale;
    if (image_fill_mode == FILL_MODE_KEEP_TEXTURE_ASPECT)
    {
        out_placement_scale.x *= inherited_aspect_difference;
    }
    out_placement_scale *= offset_scale;
    highp vec2 param_8 = inherited_placement_coord;
    highp vec2 param_9 = offset_pos;
    highp vec2 param_10 = out_placement_scale / inherited_scale;
    out_placement_coord = HSM_AddPosScaleToCoord(param_8, param_9, param_10);
    highp vec2 out_coord = vec2(0.5);
    highp vec2 drawing_scale = out_placement_scale;
    highp float slide_x = 0.0;
    if (image_fill_mode == FILL_MODE_SPLIT)
    {
        highp float abs_ctr_coord_x = abs(out_placement_coord.x - 0.5);
        highp float placement_aspect = (out_placement_scale.x / out_placement_scale.y) * output_aspect;
        highp float placement_aspect_difference = explicit_texture_aspect / placement_aspect;
        drawing_scale.x *= placement_aspect_difference;
        highp float center_width = split_preserve_center * placement_aspect_difference;
        if (abs_ctr_coord_x > center_width)
        {
            slide_x = ((placement_aspect - explicit_texture_aspect) / placement_aspect) / 2.0;
        }
        highp float repeat_width = split_repeat_width * placement_aspect_difference;
        bool _7177 = abs_ctr_coord_x > center_width;
        bool _7185;
        if (_7177)
        {
            _7185 = abs_ctr_coord_x < (center_width + slide_x);
        }
        else
        {
            _7185 = _7177;
        }
        if (_7185 && (repeat_width > 0.0))
        {
            if (clamp(split_repeat_width - 0.001000000047497451305389404296875, 0.0, 1.0) == 0.0)
            {
                slide_x = abs_ctr_coord_x - center_width;
            }
            else
            {
                slide_x = ((abs_ctr_coord_x - 0.001000000047497451305389404296875) - center_width) - mod(clamp((abs_ctr_coord_x - 0.00999999977648258209228515625) - center_width, 0.0, 1.0), repeat_width);
            }
        }
        if (out_placement_coord.x < 0.5)
        {
            slide_x *= (-1.0);
        }
        inherited_coord.x -= slide_x;
    }
    highp vec2 param_11 = inherited_coord;
    highp vec2 param_12 = offset_pos;
    highp vec2 param_13 = drawing_scale / inherited_scale;
    out_coord = HSM_AddPosScaleToCoord(param_11, param_12, param_13);
    return out_coord;
}

highp vec2 HSM_GetMirrorWrapCoord(highp vec2 in_coord)
{
    highp vec2 ctr_coord = in_coord - vec2(0.5);
    highp vec2 ctr_mirror_coord = vec2(0.0);
    highp float x_is_outside = clamp((clamp(abs(ctr_coord.x), 0.5, 1.0) - 0.5) * 100000.0, 0.0, 1.0);
    ctr_mirror_coord.x = ((1.0 - x_is_outside) * ctr_coord.x) + (x_is_outside * (ctr_coord.x - ((2.0 * sign(ctr_coord.x)) * (abs(ctr_coord.x) - 0.5))));
    highp float y_is_outside = clamp((clamp(abs(ctr_coord.y), 0.5, 1.0) - 0.5) * 100000.0, 0.0, 1.0);
    ctr_mirror_coord.y = ((1.0 - y_is_outside) * ctr_coord.y) + (y_is_outside * (ctr_coord.y - ((2.0 * sign(ctr_coord.y)) * (abs(ctr_coord.y) - 0.5))));
    return ctr_mirror_coord + vec2(0.5);
}

highp vec4 HSM_GetPreMultipliedColorLinear(highp vec4 in_color, highp float matte_type, highp float encoded_gamma)
{
    highp vec4 out_color = in_color;
    if (matte_type == SOURCE_MATTE_WHITE)
    {
        highp vec4 _2841 = out_color;
        highp float _2844 = out_color.w;
        highp vec3 _2850 = clamp(_2841.xyz - vec3(1.0 - _2844), vec3(0.0), vec3(1.0));
        out_color.x = _2850.x;
        out_color.y = _2850.y;
        out_color.z = _2850.z;
    }
    highp vec4 param = out_color;
    highp float param_1 = encoded_gamma;
    out_color = HSM_Linearize(param, param_1);
    if (matte_type == SOURCE_MATTE_NONE)
    {
        highp float _2868 = out_color.w;
        highp vec4 _2869 = out_color;
        highp vec3 _2871 = _2869.xyz * _2868;
        out_color.x = _2871.x;
        out_color.y = _2871.y;
        out_color.z = _2871.z;
    }
    return out_color;
}

highp vec3 HSM_ApplyHSVAdjustment(highp vec3 in_color_rgb, highp float in_hue, highp float in_saturation, highp float in_brightness, highp float in_colorize_on, highp float in_gamma_adjust)
{
    if (!(((((in_colorize_on == 1.0) || (in_hue != 0.0)) || (in_saturation != 1.0)) || (in_brightness != 1.0)) || (in_gamma_adjust != 1.0)))
    {
        return in_color_rgb;
    }
    highp vec3 param = in_color_rgb;
    highp vec3 color_hsv = HSM_RGBtoHSV(param);
    if (in_colorize_on > 0.5)
    {
        color_hsv.x = in_hue;
        color_hsv.y = mix(mix(0.0, color_hsv.y, clamp(in_saturation, 0.0, 1.0)), 1.0, clamp(in_saturation - 1.0, 0.0, 1.0));
    }
    else
    {
        color_hsv.x += in_hue;
        color_hsv.y *= in_saturation;
    }
    color_hsv.z *= in_brightness;
    highp vec3 param_1 = color_hsv;
    highp vec3 color_rgb = HSM_HSVtoRGB(param_1);
    if (in_gamma_adjust != 1.0)
    {
        highp vec4 param_2 = vec4(color_rgb.x, color_rgb.y, color_rgb.z, 1.0);
        highp float param_3 = in_gamma_adjust;
        color_rgb = HSM_ApplyGamma(param_2, param_3).xyz;
    }
    return color_rgb;
}

highp float HSM_GetVignetteFactor(highp vec2 coord, highp float amount, highp float size)
{
    highp float orig_mamehlsl_amount = amount;
    highp vec2 ctr_coord = coord - vec2(0.5);
    highp float vignette_length = length(ctr_coord * vec2((((0.5 / size) * global.OutputSize.x) / global.OutputSize.y) + 0.5, 1.0));
    highp float vignette_blur = (orig_mamehlsl_amount * 0.75) + 0.25;
    highp float vignette_radius = 1.0 - (orig_mamehlsl_amount * 0.25);
    highp float vignette = smoothstep(vignette_radius, vignette_radius - vignette_blur, vignette_length);
    highp float vignette_multiplier = smoothstep(0.0, 0.0500000007450580596923828125, amount);
    return (1.0 - vignette_multiplier) + (vignette * vignette_multiplier);
}

highp vec2 HSM_GetLayerCoord(highp vec2 in_viewport_coord, highp float layer_to_follow, highp float follow_mode, highp vec2 out_placement_scale)
{
    highp vec2 flat_coord = vec2(0.5);
    highp vec2 curved_coord = vec2(0.5);
    highp vec2 out_coord = vec2(0.5);
    if (layer_to_follow == 0.0)
    {
        flat_coord = in_viewport_coord;
        curved_coord = in_viewport_coord;
    }
    else
    {
        if (layer_to_follow == 1.0)
        {
            flat_coord = TUBE_DIFFUSE_COORD;
            curved_coord = TUBE_DIFFUSE_CURVED_COORD;
        }
        else
        {
            if (layer_to_follow == 2.0)
            {
                flat_coord = BEZEL_OUTSIDE_COORD;
                curved_coord = BEZEL_OUTSIDE_CURVED_COORD;
            }
            else
            {
                if (layer_to_follow == 3.0)
                {
                    flat_coord = BACKGROUND_COORD;
                    curved_coord = BACKGROUND_CURVED_COORD;
                }
                else
                {
                    if (layer_to_follow == 4.0)
                    {
                        flat_coord = DEVICE_COORD;
                        curved_coord = DEVICE_CURVED_COORD;
                    }
                    else
                    {
                        if (layer_to_follow == 5.0)
                        {
                            flat_coord = DECAL_COORD;
                            curved_coord = DECAL_CURVED_COORD;
                        }
                        else
                        {
                            if (layer_to_follow == 6.0)
                            {
                                flat_coord = CAB_GLASS_COORD;
                                curved_coord = CAB_GLASS_CURVED_COORD;
                            }
                            else
                            {
                                if (layer_to_follow == 7.0)
                                {
                                    flat_coord = TOP_IMAGE_COORD;
                                    curved_coord = TOP_IMAGE_CURVED_COORD;
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    out_coord = (follow_mode == FOLLOW_MODE_EXACT) ? curved_coord : flat_coord;
    return out_coord;
}

void main()
{
    FOLLOW_MODE_SCALE_AND_POS = 0.0;
    FOLLOW_MODE_EXACT = 1.0;
    NEGATIVE_CROP_EXPAND_MULTIPLIER = 0.5;
    MAX_NEGATIVE_CROP = 0.5;
    DEFAULT_SCREEN_ASPECT = 1.3329918384552001953125;
    DEFAULT_BEZEL_ASPECT = 1.32272231578826904296875;
    DEFAULT_SCREEN_SCALE = vec2(0.0);
    DEFAULT_BEZEL_SCALE = vec2(0.0);
    INFOCACHE_MAX_INDEX = 4;
    CACHE_INFO_CHANGED = false;
    CURRENT_FRAME_FROM_CACHE_INFO = 0.0;
    TUBE_DIFFUSE_MASK = 0.0;
    TUBE_MASK = 0.0;
    BEZEL_MASK = 0.0;
    INSIDE_BEZEL_MASK = 0.0;
    OUTSIDE_TUBE_MASK_FOR_IMAGE = 0.0;
    FRAME_MASK = 0.0;
    FRAME_MASK_FOR_IMAGE = 0.0;
    OUTSIDE_BEZEL_MASK = 0.0;
    OUTSIDE_FRAME_MASK_FOR_IMAGE = 0.0;
    OUTSIDE_FRAME_MASK = 0.0;
    CUTOUT_MASK = 0.0;
    SCREEN_INDEX = 1.0;
    SCREEN_ASPECT = 1.0;
    SCREEN_SCALE = vec2(1.0);
    SCREEN_SCALE_WITH_ZOOM = vec2(1.0);
    SCREEN_POS_OFFSET = vec2(0.1500000059604644775390625);
    SCREEN_SCALE_2ND_SCREEN = vec2(1.0);
    SCREEN_POS_OFFSET_1ST_SCREEN = vec2(0.1500000059604644775390625);
    SCREEN_POS_OFFSET_2ND_SCREEN = vec2(0.1500000059604644775390625);
    VIEWPORT_SCALE = vec2(1.0);
    VIEWPORT_POS = vec2(1.0);
    TUBE_SCALE = vec2(1.0);
    TUBE_DIFFUSE_SCALE = vec2(1.0);
    TUBE_DIFFUSE_ASPECT = 1.0;
    TUBE_DIFFUSE_SCALE_1ST_SCREEN = vec2(1.0);
    TUBE_DIFFUSE_SCALE_2ND_SCREEN = vec2(1.0);
    FRAME_SCALE = vec2(1.0);
    BEZEL_OUTSIDE_SCALE = vec2(0.5);
    BACKGROUND_SCALE = vec2(0.5);
    LED_SCALE = vec2(0.5);
    DEVICE_SCALE = vec2(0.5);
    DEVICELED_SCALE = vec2(0.5);
    DECAL_SCALE = vec2(0.5);
    CAB_GLASS_SCALE = vec2(0.5);
    TOP_IMAGE_SCALE = vec2(0.5);
    AVERAGE_LUMA = 0.0;
    USE_VERTICAL_SCANLINES = 0.0;
    SAMPLING_SCANLINE_DIR_MULT = 0.0;
    SAMPLING_OPPOSITE_DIR_MULT = 0.0;
    CORE_SIZE = vec2(1.0);
    ROTATED_CORE_ORIGINAL_SIZE = vec2(1.0);
    ROTATED_CORE_PREPPED_SIZE = vec2(1.0);
    ROTATED_DEREZED_SIZE = vec2(1.0);
    CROPPED_ROTATED_SIZE_WITH_RES_MULT = vec2(1.0);
    CROPPED_ROTATED_SIZE_WITH_RES_MULT_FEEDBACK = vec2(1.0);
    CROPPED_ROTATED_SIZE = vec2(1.0);
    SAMPLE_AREA_START_PIXEL_COORD = vec2(1.0);
    SCREEN_SIZE = vec2(1.0);
    VIEWPORT_UNSCALED_COORD = vec2(0.5);
    SCREEN_COORD = vec2(0.5);
    TUBE_COORD = vec2(0.5);
    TUBE_DIFFUSE_COORD = vec2(0.5);
    TUBE_DIFFUSE_COORD_MIXED_POS = vec2(0.5);
    BEZEL_OUTSIDE_COORD = vec2(0.5);
    BACKGROUND_COORD = vec2(0.5);
    DEVICE_COORD = vec2(0.5);
    DEVICELED_COORD = vec2(0.5);
    LED_COORD = vec2(0.5);
    DECAL_COORD = vec2(0.5);
    CAB_GLASS_COORD = vec2(0.5);
    TOP_IMAGE_COORD = vec2(0.5);
    SCREEN_CURVED_COORD = vec2(0.5);
    TUBE_CURVED_COORD = vec2(0.5);
    TUBE_DIFFUSE_CURVED_COORD = vec2(0.5);
    BEZEL_OUTSIDE_CURVED_COORD = vec2(0.5);
    FRAME_OUTSIDE_CURVED_COORD = vec2(0.5);
    BACKGROUND_CURVED_COORD = vec2(0.5);
    LED_CURVED_COORD = vec2(0.5);
    DEVICE_CURVED_COORD = vec2(0.5);
    DEVICELED_CURVED_COORD = vec2(0.5);
    DECAL_CURVED_COORD = vec2(0.5);
    CAB_GLASS_CURVED_COORD = vec2(0.5);
    TOP_IMAGE_CURVED_COORD = vec2(0.5);
    HSM_RESOLUTION_DEBUG_ON = global.HSM_RESOLUTION_DEBUG_ON;
    HSM_GLOBAL_GRAPHICS_BRIGHTNESS = global.HSM_GLOBAL_GRAPHICS_BRIGHTNESS / 100.0;
    HSM_STATIC_LAYERS_GAMMA = global.HSM_STATIC_LAYERS_GAMMA;
    HSM_AMBIENT_LIGHTING_OPACITY = global.HSM_AMBIENT_LIGHTING_OPACITY / 100.0;
    HSM_AMBIENT1_OPACITY = ((global.HSM_AMBIENT1_OPACITY / 100.0) * global.HSM_AMBIENT_LIGHTING_OPACITY) / 100.0;
    HSM_AMBIENT2_OPACITY = ((global.HSM_AMBIENT2_OPACITY / 100.0) * global.HSM_AMBIENT_LIGHTING_OPACITY) / 100.0;
    HSM_AMBIENT_LIGHTING_SWAP_IMAGE_MODE = global.HSM_AMBIENT_LIGHTING_SWAP_IMAGE_MODE;
    HSM_SINDEN_BORDER_ON = global.HSM_SINDEN_BORDER_ON;
    HSM_SINDEN_BORDER_BRIGHTNESS = global.HSM_SINDEN_BORDER_BRIGHTNESS / 100.0;
    HSM_SINDEN_BORDER_THICKNESS = global.HSM_SINDEN_BORDER_THICKNESS / 100.0;
    HSM_SINDEN_BORDER_EMPTY_TUBE_COMPENSATION = global.HSM_SINDEN_BORDER_EMPTY_TUBE_COMPENSATION;
    HSM_VIEWPORT_ZOOM = global.HSM_VIEWPORT_ZOOM / 100.0;
    HSM_VIEWPORT_ZOOM_MASK = global.HSM_VIEWPORT_ZOOM_MASK;
    HSM_VIEWPORT_POSITION_X = ((-1.0) * global.HSM_VIEWPORT_POSITION_X) / 1000.0;
    HSM_VIEWPORT_POSITION_Y = ((-1.0) * global.HSM_VIEWPORT_POSITION_Y) / 1000.0;
    HSM_FLIP_VIEWPORT_VERTICAL = -((global.HSM_FLIP_VIEWPORT_VERTICAL * 2.0) - 1.0);
    HSM_FLIP_VIEWPORT_HORIZONTAL = -((global.HSM_FLIP_VIEWPORT_HORIZONTAL * 2.0) - 1.0);
    HSM_FLIP_CORE_VERTICAL = -((global.HSM_FLIP_CORE_VERTICAL * 2.0) - 1.0);
    HSM_FLIP_CORE_HORIZONTAL = -((global.HSM_FLIP_CORE_HORIZONTAL * 2.0) - 1.0);
    HSM_ROTATE_CORE_IMAGE = global.HSM_ROTATE_CORE_IMAGE;
    HSM_ASPECT_RATIO_ORIENTATION = global.HSM_ASPECT_RATIO_ORIENTATION;
    HSM_ASPECT_RATIO_MODE = global.HSM_ASPECT_RATIO_MODE;
    HSM_ASPECT_RATIO_EXPLICIT = global.HSM_ASPECT_RATIO_EXPLICIT;
    HSM_VERTICAL_PRESET = global.HSM_VERTICAL_PRESET;
    HSM_INT_SCALE_MAX_HEIGHT = global.HSM_INT_SCALE_MAX_HEIGHT / 100.0;
    HSM_NON_INTEGER_SCALE = global.HSM_NON_INTEGER_SCALE / 100.0;
    HSM_USE_PHYSICAL_SIZE_FOR_NON_INTEGER = global.HSM_USE_PHYSICAL_SIZE_FOR_NON_INTEGER;
    HSM_PHYSICAL_MONITOR_ASPECT_RATIO = global.HSM_PHYSICAL_MONITOR_ASPECT_RATIO;
    HSM_PHYSICAL_MONITOR_DIAGONAL_SIZE = global.HSM_PHYSICAL_MONITOR_DIAGONAL_SIZE;
    HSM_PHYSICAL_SIM_TUBE_DIAGONAL_SIZE = global.HSM_PHYSICAL_SIM_TUBE_DIAGONAL_SIZE;
    HSM_USE_IMAGE_FOR_PLACEMENT = global.HSM_USE_IMAGE_FOR_PLACEMENT;
    HSM_PLACEMENT_IMAGE_USE_HORIZONTAL = global.HSM_PLACEMENT_IMAGE_USE_HORIZONTAL;
    HSM_PLACEMENT_IMAGE_MODE = global.HSM_PLACEMENT_IMAGE_MODE;
    HSM_NON_INTEGER_SCALE_OFFSET = global.HSM_NON_INTEGER_SCALE_OFFSET / 100.0;
    HSM_USE_SNAP_TO_CLOSEST_INT_SCALE = global.HSM_USE_SNAP_TO_CLOSEST_INT_SCALE;
    highp float _788;
    if (HSM_USE_SNAP_TO_CLOSEST_INT_SCALE > 0.5)
    {
        _788 = global.HSM_SNAP_TO_CLOSEST_INT_SCALE_TOLERANCE / 100.0;
    }
    else
    {
        _788 = 0.0;
    }
    HSM_SNAP_TO_CLOSEST_INT_SCALE_TOLERANCE = _788;
    HSM_SCREEN_POSITION_X = global.HSM_SCREEN_POSITION_X / 1000.0;
    HSM_SCREEN_POSITION_Y = ((-1.0) * global.HSM_SCREEN_POSITION_Y) / 1000.0;
    HSM_CROP_MODE = global.HSM_CROP_MODE;
    HSM_CROP_PERCENT_ZOOM = global.HSM_CROP_PERCENT_ZOOM / 100.0;
    HSM_CROP_PERCENT_TOP = global.HSM_CROP_PERCENT_TOP / 100.0;
    HSM_CROP_PERCENT_BOTTOM = global.HSM_CROP_PERCENT_BOTTOM / 100.0;
    HSM_CROP_PERCENT_LEFT = global.HSM_CROP_PERCENT_LEFT / 100.0;
    HSM_CROP_PERCENT_RIGHT = global.HSM_CROP_PERCENT_RIGHT / 100.0;
    HSM_CROP_BLACK_THRESHOLD = global.HSM_CROP_BLACK_THRESHOLD / 100.0;
    HSM_SCANLINE_DIRECTION = global.HSM_SCANLINE_DIRECTION;
    HSM_CORE_RES_SAMPLING_MULT_SCANLINE_DIR = global.HSM_CORE_RES_SAMPLING_MULT_SCANLINE_DIR / 100.0;
    HSM_DOWNSAMPLE_BLUR_SCANLINE_DIR = global.HSM_DOWNSAMPLE_BLUR_SCANLINE_DIR / 100.0;
    HSM_CORE_RES_SAMPLING_MULT_OPPOSITE_DIR = global.HSM_CORE_RES_SAMPLING_MULT_OPPOSITE_DIR / 100.0;
    HSM_DOWNSAMPLE_BLUR_OPPOSITE_DIR = global.HSM_DOWNSAMPLE_BLUR_OPPOSITE_DIR / 100.0;
    HSM_USE_GEOM = 0.0;
    HSM_CURVATURE_MODE = global.HSM_CURVATURE_MODE;
    HSM_CURVATURE_3D_RADIUS = global.HSM_CURVATURE_3D_RADIUS / 100.0;
    HSM_CURVATURE_3D_VIEW_DIST = global.HSM_CURVATURE_3D_VIEW_DIST / 100.0;
    HSM_CURVATURE_3D_TILT_ANGLE_X = global.HSM_CURVATURE_3D_TILT_ANGLE_X / 100.0;
    HSM_CURVATURE_3D_TILT_ANGLE_Y = global.HSM_CURVATURE_3D_TILT_ANGLE_Y / 100.0;
    HSM_CRT_CURVATURE_SCALE = global.HSM_CRT_CURVATURE_SCALE / 100.0;
    HSM_CACHE_GRAPHICS_ON = global.HSM_CACHE_GRAPHICS_ON;
    HSM_CACHE_UPDATE_INDICATOR_MODE = global.HSM_CACHE_UPDATE_INDICATOR_MODE;
    HSM_AB_COMPARE_SHOW_MODE = global.HSM_AB_COMPARE_SHOW_MODE;
    HSM_AB_COMPARE_AREA = global.HSM_AB_COMPARE_AREA;
    HSM_AB_COMPARE_SPLIT_POSITION = global.HSM_AB_COMPARE_SPLIT_POSITION / 100.0;
    HSM_AB_COMPARE_FREEZE_CRT_TUBE = global.HSM_AB_COMPARE_FREEZE_CRT_TUBE;
    HSM_AB_COMPARE_FREEZE_GRAPHICS = global.HSM_AB_COMPARE_FREEZE_GRAPHICS;
    HSM_SHOW_PASS_INDEX = global.HSM_SHOW_PASS_INDEX;
    HSM_SHOW_PASS_APPLY_SCREEN_COORD = global.HSM_SHOW_PASS_APPLY_SCREEN_COORD;
    HSM_SHOW_PASS_ALPHA = global.HSM_SHOW_PASS_ALPHA;
    HSM_SCREEN_VIGNETTE_DUALSCREEN_VIS_MODE = global.HSM_SCREEN_VIGNETTE_DUALSCREEN_VIS_MODE;
    HSM_MONOCHROME_DUALSCREEN_VIS_MODE = global.HSM_MONOCHROME_DUALSCREEN_VIS_MODE;
    HSM_TUBE_DIFFUSE_MODE = global.HSM_TUBE_DIFFUSE_MODE;
    HSM_TUBE_DIFFUSE_IMAGE_AMOUNT = global.HSM_TUBE_DIFFUSE_IMAGE_AMOUNT / 100.0;
    HSM_TUBE_DIFFUSE_IMAGE_DUALSCREEN_VIS_MODE = global.HSM_TUBE_DIFFUSE_IMAGE_DUALSCREEN_VIS_MODE;
    HSM_TUBE_DIFFUSE_IMAGE_COLORIZE_ON = global.HSM_TUBE_DIFFUSE_IMAGE_COLORIZE_ON;
    HSM_TUBE_DIFFUSE_IMAGE_HUE = global.HSM_TUBE_DIFFUSE_IMAGE_HUE / 360.0;
    HSM_TUBE_DIFFUSE_IMAGE_SATURATION = global.HSM_TUBE_DIFFUSE_IMAGE_SATURATION / 100.0;
    HSM_TUBE_DIFFUSE_IMAGE_BRIGHTNESS = global.HSM_TUBE_DIFFUSE_IMAGE_BRIGHTNESS / 100.0;
    HSM_TUBE_DIFFUSE_IMAGE_GAMMA = global.HSM_TUBE_DIFFUSE_IMAGE_GAMMA;
    HSM_TUBE_DIFFUSE_IMAGE_AMBIENT_LIGHTING = global.HSM_TUBE_DIFFUSE_IMAGE_AMBIENT_LIGHTING / 100.0;
    HSM_TUBE_DIFFUSE_IMAGE_AMBIENT2_LIGHTING = global.HSM_TUBE_DIFFUSE_IMAGE_AMBIENT2_LIGHTING / 100.0;
    HSM_TUBE_DIFFUSE_IMAGE_SCALE = global.HSM_TUBE_DIFFUSE_IMAGE_SCALE / 100.0;
    HSM_TUBE_DIFFUSE_IMAGE_SCALE_X = global.HSM_TUBE_DIFFUSE_IMAGE_SCALE_X / 100.0;
    HSM_TUBE_DIFFUSE_IMAGE_ROTATION = global.HSM_TUBE_DIFFUSE_IMAGE_ROTATION;
    HSM_TUBE_SHADOW_IMAGE_ON = global.HSM_TUBE_SHADOW_IMAGE_ON;
    HSM_TUBE_SHADOW_IMAGE_OPACITY = global.HSM_TUBE_SHADOW_IMAGE_OPACITY / 100.0;
    HSM_TUBE_SHADOW_IMAGE_POS_X = global.HSM_TUBE_SHADOW_IMAGE_POS_X / 100.0;
    HSM_TUBE_SHADOW_IMAGE_POS_Y = global.HSM_TUBE_SHADOW_IMAGE_POS_Y / 100.0;
    HSM_TUBE_SHADOW_IMAGE_SCALE_X = global.HSM_TUBE_SHADOW_IMAGE_SCALE_X / 100.0;
    HSM_TUBE_SHADOW_IMAGE_SCALE_Y = global.HSM_TUBE_SHADOW_IMAGE_SCALE_Y / 100.0;
    HSM_TUBE_SHADOW_CURVATURE_SCALE = global.HSM_TUBE_SHADOW_CURVATURE_SCALE / 100.0;
    HSM_TUBE_STATIC_REFLECTION_IMAGE_ON = global.HSM_TUBE_STATIC_REFLECTION_IMAGE_ON;
    HSM_TUBE_STATIC_REFLECTION_IMAGE_DUALSCREEN_VIS_MODE = global.HSM_TUBE_STATIC_REFLECTION_IMAGE_DUALSCREEN_VIS_MODE;
    HSM_TUBE_STATIC_REFLECTION_IMAGE_OPACITY = global.HSM_TUBE_STATIC_REFLECTION_IMAGE_OPACITY / 100.0;
    HSM_TUBE_STATIC_OPACITY_DIFFUSE_MULTIPLY = global.HSM_TUBE_STATIC_OPACITY_DIFFUSE_MULTIPLY / 100.0;
    HSM_TUBE_STATIC_BLACK_LEVEL = (global.HSM_TUBE_STATIC_BLACK_LEVEL / 1000.0) + 1.0;
    HSM_TUBE_STATIC_AMBIENT_LIGHTING = global.HSM_TUBE_STATIC_AMBIENT_LIGHTING / 100.0;
    HSM_TUBE_STATIC_AMBIENT2_LIGHTING = global.HSM_TUBE_STATIC_AMBIENT2_LIGHTING / 100.0;
    HSM_TUBE_STATIC_SCALE = global.HSM_TUBE_STATIC_SCALE / 100.0;
    HSM_TUBE_STATIC_SCALE_X = global.HSM_TUBE_STATIC_SCALE_X / 100.0;
    HSM_TUBE_STATIC_POS_X = global.HSM_TUBE_STATIC_POS_X / (-1000.0);
    HSM_TUBE_STATIC_POS_Y = global.HSM_TUBE_STATIC_POS_Y / 1000.0;
    HSM_TUBE_STATIC_SHADOW_OPACITY = global.HSM_TUBE_STATIC_SHADOW_OPACITY / 100.0;
    HSM_TUBE_STATIC_DITHER_SAMPLES = global.HSM_TUBE_STATIC_DITHER_SAMPLES;
    HSM_TUBE_STATIC_DITHER_DISTANCE = global.HSM_TUBE_STATIC_DITHER_DISTANCE;
    HSM_TUBE_STATIC_DITHER_AMOUNT = global.HSM_TUBE_STATIC_DITHER_AMOUNT;
    HSM_TUBE_OPACITY = global.HSM_TUBE_OPACITY / 100.0;
    HSM_TUBE_COLORED_GEL_IMAGE_ON = global.HSM_TUBE_COLORED_GEL_IMAGE_ON;
    HSM_TUBE_COLORED_GEL_IMAGE_SCALE = global.HSM_TUBE_COLORED_GEL_IMAGE_SCALE / 100.0;
    HSM_TUBE_COLORED_GEL_IMAGE_FLIP_HORIZONTAL = -((global.HSM_TUBE_COLORED_GEL_IMAGE_FLIP_HORIZONTAL * 2.0) - 1.0);
    HSM_TUBE_COLORED_GEL_IMAGE_FLIP_VERTICAL = -((global.HSM_TUBE_COLORED_GEL_IMAGE_FLIP_VERTICAL * 2.0) - 1.0);
    HSM_TUBE_COLORED_GEL_IMAGE_DUALSCREEN_VIS_MODE = global.HSM_TUBE_COLORED_GEL_IMAGE_DUALSCREEN_VIS_MODE;
    HSM_TUBE_COLORED_GEL_IMAGE_MULTIPLY_AMOUNT = global.HSM_TUBE_COLORED_GEL_IMAGE_MULTIPLY_AMOUNT / 100.0;
    HSM_TUBE_COLORED_GEL_IMAGE_ADDITIVE_AMOUNT = global.HSM_TUBE_COLORED_GEL_IMAGE_ADDITIVE_AMOUNT / 100.0;
    HSM_TUBE_COLORED_GEL_IMAGE_NORMAL_AMOUNT = global.HSM_TUBE_COLORED_GEL_IMAGE_NORMAL_AMOUNT / 100.0;
    HSM_TUBE_COLORED_GEL_IMAGE_TRANSPARENCY_THRESHOLD = global.HSM_TUBE_COLORED_GEL_IMAGE_TRANSPARENCY_THRESHOLD / 100.0;
    HSM_TUBE_COLORED_GEL_IMAGE_NORMAL_BRIGHTNESS = global.HSM_TUBE_COLORED_GEL_IMAGE_NORMAL_BRIGHTNESS / 100.0;
    HSM_TUBE_COLORED_GEL_IMAGE_NORMAL_VIGNETTE = global.HSM_TUBE_COLORED_GEL_IMAGE_NORMAL_VIGNETTE / 100.0;
    HSM_TUBE_COLORED_GEL_IMAGE_FAKE_SCANLINE_AMOUNT = global.HSM_TUBE_COLORED_GEL_IMAGE_FAKE_SCANLINE_AMOUNT / 100.0;
    HSM_TUBE_COLORED_GEL_IMAGE_AMBIENT_LIGHTING = global.HSM_TUBE_COLORED_GEL_IMAGE_AMBIENT_LIGHTING / 100.0;
    HSM_TUBE_COLORED_GEL_IMAGE_AMBIENT2_LIGHTING = global.HSM_TUBE_COLORED_GEL_IMAGE_AMBIENT2_LIGHTING / 100.0;
    HSM_SHOW_CRT_ON_TOP_OF_COLORED_GEL = 0.0;
    HSM_DUALSCREEN_MODE = global.HSM_DUALSCREEN_MODE;
    HSM_DUALSCREEN_CORE_IMAGE_SPLIT_MODE = global.HSM_DUALSCREEN_CORE_IMAGE_SPLIT_MODE;
    HSM_DUALSCREEN_CORE_IMAGE_SWAP_SCREENS = global.HSM_DUALSCREEN_CORE_IMAGE_SWAP_SCREENS;
    HSM_DUALSCREEN_CORE_IMAGE_SPLIT_OFFSET = global.HSM_DUALSCREEN_CORE_IMAGE_SPLIT_OFFSET / 1000.0;
    HSM_DUALSCREEN_VIEWPORT_SPLIT_LOCATION = global.HSM_DUALSCREEN_VIEWPORT_SPLIT_LOCATION / 1000.0;
    HSM_DUALSCREEN_SHIFT_POSITION_WITH_SCALE = global.HSM_DUALSCREEN_SHIFT_POSITION_WITH_SCALE;
    HSM_DUALSCREEN_POSITION_OFFSET_BETWEEN_SCREENS = global.HSM_DUALSCREEN_POSITION_OFFSET_BETWEEN_SCREENS / 1000.0;
    HSM_2ND_SCREEN_ASPECT_RATIO_MODE = global.HSM_2ND_SCREEN_ASPECT_RATIO_MODE;
    HSM_2ND_SCREEN_INDEPENDENT_SCALE = global.HSM_2ND_SCREEN_INDEPENDENT_SCALE;
    HSM_2ND_SCREEN_SCALE_OFFSET = global.HSM_2ND_SCREEN_SCALE_OFFSET / 100.0;
    HSM_2ND_SCREEN_POS_X = global.HSM_2ND_SCREEN_POS_X / 1000.0;
    HSM_2ND_SCREEN_POS_Y = global.HSM_2ND_SCREEN_POS_Y / 1000.0;
    HSM_2ND_SCREEN_CROP_PERCENT_ZOOM = global.HSM_2ND_SCREEN_CROP_PERCENT_ZOOM / 100.0;
    HSM_2ND_SCREEN_CROP_PERCENT_TOP = global.HSM_2ND_SCREEN_CROP_PERCENT_TOP / 100.0;
    HSM_2ND_SCREEN_CROP_PERCENT_BOTTOM = global.HSM_2ND_SCREEN_CROP_PERCENT_BOTTOM / 100.0;
    HSM_2ND_SCREEN_CROP_PERCENT_LEFT = global.HSM_2ND_SCREEN_CROP_PERCENT_LEFT / 100.0;
    HSM_2ND_SCREEN_CROP_PERCENT_RIGHT = global.HSM_2ND_SCREEN_CROP_PERCENT_RIGHT / 100.0;
    HSM_SCREEN_REFLECTION_SCALE = global.HSM_SCREEN_REFLECTION_SCALE / 100.0;
    HSM_SCREEN_REFLECTION_POS_X = global.HSM_SCREEN_REFLECTION_POS_X / 600.0;
    HSM_SCREEN_REFLECTION_POS_Y = global.HSM_SCREEN_REFLECTION_POS_Y / 600.0;
    HSM_AMBIENT1_HUE = global.HSM_AMBIENT1_HUE / 360.0;
    HSM_AMBIENT1_SATURATION = global.HSM_AMBIENT1_SATURATION / 100.0;
    HSM_AMBIENT1_VALUE = global.HSM_AMBIENT1_VALUE / 100.0;
    HSM_AMBIENT1_CONTRAST = global.HSM_AMBIENT1_CONTRAST / 100.0;
    HSM_AMBIENT1_SCALE_KEEP_ASPECT = global.HSM_AMBIENT1_SCALE_KEEP_ASPECT;
    HSM_AMBIENT1_SCALE_INHERIT_MODE = global.HSM_AMBIENT1_SCALE_INHERIT_MODE;
    HSM_AMBIENT1_SCALE = global.HSM_AMBIENT1_SCALE / 100.0;
    HSM_AMBIENT1_SCALE_X = global.HSM_AMBIENT1_SCALE_X / 100.0;
    HSM_AMBIENT1_ROTATE = global.HSM_AMBIENT1_ROTATE;
    HSM_AMBIENT1_MIRROR_HORZ = global.HSM_AMBIENT1_MIRROR_HORZ;
    HSM_AMBIENT1_POS_INHERIT_MODE = global.HSM_AMBIENT1_POS_INHERIT_MODE;
    HSM_AMBIENT1_POSITION_X = global.HSM_AMBIENT1_POSITION_X / (-1000.0);
    HSM_AMBIENT1_POSITION_Y = ((-1.0) * global.HSM_AMBIENT1_POSITION_Y) / (-1000.0);
    HSM_AMBIENT1_DITHERING_SAMPLES = 0.0;
    HSM_AMBIENT2_HUE = global.HSM_AMBIENT2_HUE / 360.0;
    HSM_AMBIENT2_SATURATION = global.HSM_AMBIENT2_SATURATION / 100.0;
    HSM_AMBIENT2_VALUE = global.HSM_AMBIENT2_VALUE / 100.0;
    HSM_AMBIENT2_CONTRAST = global.HSM_AMBIENT2_CONTRAST / 100.0;
    HSM_AMBIENT2_SCALE_KEEP_ASPECT = global.HSM_AMBIENT2_SCALE_KEEP_ASPECT;
    HSM_AMBIENT2_SCALE_INHERIT_MODE = global.HSM_AMBIENT2_SCALE_INHERIT_MODE;
    HSM_AMBIENT2_SCALE = global.HSM_AMBIENT2_SCALE / 100.0;
    HSM_AMBIENT2_SCALE_X = global.HSM_AMBIENT2_SCALE_X / 100.0;
    HSM_AMBIENT2_ROTATE = global.HSM_AMBIENT2_ROTATE;
    HSM_AMBIENT2_MIRROR_HORZ = global.HSM_AMBIENT2_MIRROR_HORZ;
    HSM_AMBIENT2_POS_INHERIT_MODE = global.HSM_AMBIENT2_POS_INHERIT_MODE;
    HSM_AMBIENT2_POSITION_X = global.HSM_AMBIENT2_POSITION_X / (-1000.0);
    HSM_AMBIENT2_POSITION_Y = ((-1.0) * global.HSM_AMBIENT2_POSITION_Y) / (-1000.0);
    HSM_BZL_OPACITY = global.HSM_BZL_OPACITY / 100.0;
    HSM_BZL_BLEND_MODE = global.HSM_BZL_BLEND_MODE;
    HSM_BZL_WIDTH = global.HSM_BZL_WIDTH * 0.0008623999892733991146087646484375;
    HSM_BZL_HEIGHT = global.HSM_BZL_HEIGHT * 0.000873200013302266597747802734375;
    HSM_BZL_INNER_CORNER_RADIUS_SCALE = global.HSM_BZL_INNER_CORNER_RADIUS_SCALE / 100.0;
    HSM_BZL_INNER_EDGE_THICKNESS = global.HSM_BZL_INNER_EDGE_THICKNESS * 7.0000001869630068540573120117188e-05;
    HSM_BZL_INNER_EDGE_SHARPNESS = global.HSM_BZL_INNER_EDGE_SHARPNESS / 100.0;
    HSM_BZL_OUTER_POSITION_Y = global.HSM_BZL_OUTER_POSITION_Y / 2000.0;
    HSM_BZL_OUTER_CURVATURE_SCALE = global.HSM_BZL_OUTER_CURVATURE_SCALE / 100.0;
    HSM_BZL_OUTER_CORNER_RADIUS_SCALE = (0.89999997615814208984375 * global.HSM_BZL_OUTER_CORNER_RADIUS_SCALE) / 100.0;
    HSM_BZL_NOISE = global.HSM_BZL_NOISE / 100.0;
    HSM_BZL_INNER_EDGE_SHADOW = global.HSM_BZL_INNER_EDGE_SHADOW / 100.0;
    HSM_BZL_BRIGHTNESS = global.HSM_BZL_BRIGHTNESS / 100.0;
    HSM_BZL_BRIGHTNESS_MULT_TOP = global.HSM_BZL_BRIGHTNESS_MULT_TOP / 100.0;
    HSM_BZL_BRIGHTNESS_MULT_BOTTOM = global.HSM_BZL_BRIGHTNESS_MULT_BOTTOM / 100.0;
    HSM_BZL_BRIGHTNESS_MULT_SIDES = global.HSM_BZL_BRIGHTNESS_MULT_SIDES / 100.0;
    HSM_BZL_BRIGHTNESS_MULT_SIDE_LEFT = global.HSM_BZL_BRIGHTNESS_MULT_SIDE_LEFT / 100.0;
    HSM_BZL_BRIGHTNESS_MULT_SIDE_RIGHT = global.HSM_BZL_BRIGHTNESS_MULT_SIDE_RIGHT / 100.0;
    HSM_BZL_HIGHLIGHT = global.HSM_BZL_HIGHLIGHT / 100.0;
    HSM_BZL_COLOR_HUE = global.HSM_BZL_COLOR_HUE / 360.0;
    HSM_BZL_COLOR_SATURATION = global.HSM_BZL_COLOR_SATURATION / 100.0;
    HSM_BZL_COLOR_VALUE = global.HSM_BZL_COLOR_VALUE / 100.0;
    HSM_BZL_AMBIENT_LIGHTING_MULTIPLIER = global.HSM_BZL_AMBIENT_LIGHTING_MULTIPLIER / 100.0;
    HSM_BZL_AMBIENT2_LIGHTING_MULTIPLIER = global.HSM_BZL_AMBIENT2_LIGHTING_MULTIPLIER / 100.0;
    HSM_FRM_USE_INDEPENDENT_COLOR = global.HSM_FRM_USE_INDEPENDENT_COLOR;
    HSM_FRM_COLOR_HUE = global.HSM_FRM_COLOR_HUE / 360.0;
    HSM_FRM_COLOR_SATURATION = global.HSM_FRM_COLOR_SATURATION / 100.0;
    HSM_FRM_COLOR_VALUE = global.HSM_FRM_COLOR_VALUE / 100.0;
    HSM_FRM_OPACITY = global.HSM_FRM_OPACITY / 100.0;
    HSM_FRM_BLEND_MODE = 1.0;
    HSM_FRM_TEXTURE_OPACITY = global.HSM_FRM_TEXTURE_OPACITY / 100.0;
    HSM_FRM_TEXTURE_BLEND_MODE = global.HSM_FRM_TEXTURE_BLEND_MODE;
    HSM_FRM_NOISE = global.HSM_FRM_NOISE / 100.0;
    HSM_FRM_INNER_EDGE_THICKNESS = global.HSM_FRM_INNER_EDGE_THICKNESS * 2.9999999242136254906654357910156e-05;
    HSM_FRM_THICKNESS = global.HSM_FRM_THICKNESS * 0.00069999997504055500030517578125;
    HSM_FRM_THICKNESS_SCALE_X = global.HSM_FRM_THICKNESS_SCALE_X / 100.0;
    HSM_FRM_OUTER_POS_Y = global.HSM_FRM_OUTER_POS_Y / 100.0;
    HSM_FRM_OUTER_CURVATURE_SCALE = global.HSM_FRM_OUTER_CURVATURE_SCALE / 100.0;
    HSM_FRM_OUTER_CORNER_RADIUS = global.HSM_FRM_OUTER_CORNER_RADIUS;
    HSM_FRM_OUTER_EDGE_THICKNESS = global.HSM_FRM_OUTER_EDGE_THICKNESS * 5.9999998484272509813308715820312e-05;
    HSM_FRM_OUTER_EDGE_SHADING = global.HSM_FRM_OUTER_EDGE_SHADING / 100.0;
    HSM_FRM_SHADOW_OPACITY = global.HSM_FRM_SHADOW_OPACITY / 100.0;
    HSM_FRM_SHADOW_WIDTH = global.HSM_FRM_SHADOW_WIDTH / 1000.0;
    HSM_REFLECT_CORNER_FADE = global.HSM_REFLECT_CORNER_FADE / 100.0;
    HSM_REFLECT_CORNER_FADE_DISTANCE = global.HSM_REFLECT_CORNER_FADE_DISTANCE / 100.0;
    HSM_REFLECT_CORNER_INNER_SPREAD = global.HSM_REFLECT_CORNER_INNER_SPREAD / 100.0;
    HSM_REFLECT_CORNER_OUTER_SPREAD = global.HSM_REFLECT_CORNER_OUTER_SPREAD / 100.0;
    HSM_REFLECT_CORNER_ROTATION_OFFSET_TOP = global.HSM_REFLECT_CORNER_ROTATION_OFFSET_TOP;
    HSM_REFLECT_CORNER_ROTATION_OFFSET_BOTTOM = global.HSM_REFLECT_CORNER_ROTATION_OFFSET_BOTTOM;
    HSM_REFLECT_CORNER_SPREAD_FALLOFF = global.HSM_REFLECT_CORNER_SPREAD_FALLOFF;
    HSM_BG_LAYER_ORDER = global.HSM_BG_LAYER_ORDER;
    HSM_VIEWPORT_VIGNETTE_LAYER_ORDER = global.HSM_VIEWPORT_VIGNETTE_LAYER_ORDER;
    HSM_LED_LAYER_ORDER = global.HSM_LED_LAYER_ORDER;
    HSM_DEVICE_LAYER_ORDER = global.HSM_DEVICE_LAYER_ORDER;
    HSM_DEVICELED_LAYER_ORDER = global.HSM_DEVICELED_LAYER_ORDER;
    HSM_CRT_LAYER_ORDER = global.HSM_CRT_LAYER_ORDER;
    HSM_DECAL_LAYER_ORDER = global.HSM_DECAL_LAYER_ORDER;
    HSM_CAB_GLASS_LAYER_ORDER = global.HSM_CAB_GLASS_LAYER_ORDER;
    HSM_TOP_LAYER_ORDER = global.HSM_TOP_LAYER_ORDER;
    HSM_CUTOUT_ASPECT_MODE = global.HSM_CUTOUT_ASPECT_MODE;
    HSM_CUTOUT_EXPLICIT_ASPECT = global.HSM_CUTOUT_EXPLICIT_ASPECT;
    HSM_CUTOUT_FOLLOW_LAYER = global.HSM_CUTOUT_FOLLOW_LAYER;
    HSM_CUTOUT_FOLLOW_FULL_USES_ZOOM = global.HSM_CUTOUT_FOLLOW_FULL_USES_ZOOM;
    HSM_CUTOUT_SCALE = global.HSM_CUTOUT_SCALE / 100.0;
    HSM_CUTOUT_SCALE_X = global.HSM_CUTOUT_SCALE_X / 100.0;
    HSM_CUTOUT_POS_X = global.HSM_CUTOUT_POS_X / (-100.0);
    HSM_CUTOUT_POS_Y = global.HSM_CUTOUT_POS_Y / 100.0;
    HSM_CUTOUT_CORNER_RADIUS = global.HSM_CUTOUT_CORNER_RADIUS;
    HSM_LAYERING_DEBUG_MASK_MODE = global.HSM_LAYERING_DEBUG_MASK_MODE;
    HSM_BG_OPACITY = global.HSM_BG_OPACITY / 100.0;
    HSM_BG_COLORIZE_ON = global.HSM_BG_COLORIZE_ON;
    HSM_BG_HUE = global.HSM_BG_HUE / 360.0;
    HSM_BG_SATURATION = global.HSM_BG_SATURATION / 100.0;
    HSM_BG_BRIGHTNESS = global.HSM_BG_BRIGHTNESS / 100.0;
    HSM_BG_GAMMA = global.HSM_BG_GAMMA;
    HSM_BG_AMBIENT_LIGHTING_MULTIPLIER = global.HSM_BG_AMBIENT_LIGHTING_MULTIPLIER / 100.0;
    HSM_BG_AMBIENT2_LIGHTING_MULTIPLIER = global.HSM_BG_AMBIENT2_LIGHTING_MULTIPLIER / 100.0;
    HSM_BG_APPLY_AMBIENT_IN_ADD_MODE = global.HSM_BG_APPLY_AMBIENT_IN_ADD_MODE;
    HSM_BG_BLEND_MODE = global.HSM_BG_BLEND_MODE;
    HSM_BG_SOURCE_MATTE_TYPE = global.HSM_BG_SOURCE_MATTE_TYPE;
    HSM_BG_MIPMAPPING_BLEND_BIAS = global.HSM_BG_MIPMAPPING_BLEND_BIAS;
    HSM_BG_MASK_MODE = global.HSM_BG_MASK_MODE;
    HSM_BG_CUTOUT_MODE = global.HSM_BG_CUTOUT_MODE;
    HSM_BG_DUALSCREEN_VIS_MODE = global.HSM_BG_DUALSCREEN_VIS_MODE;
    HSM_BG_FOLLOW_LAYER = global.HSM_BG_FOLLOW_LAYER;
    HSM_BG_FOLLOW_MODE = global.HSM_BG_FOLLOW_MODE;
    HSM_BG_FOLLOW_FULL_USES_ZOOM = global.HSM_BG_FOLLOW_FULL_USES_ZOOM;
    HSM_BG_FILL_MODE = global.HSM_BG_FILL_MODE;
    HSM_BG_SPLIT_PRESERVE_CENTER = global.HSM_BG_SPLIT_PRESERVE_CENTER / 1000.0;
    HSM_BG_SPLIT_REPEAT_WIDTH = global.HSM_BG_SPLIT_REPEAT_WIDTH / 1000.0;
    HSM_BG_SCALE = global.HSM_BG_SCALE / 100.0;
    HSM_BG_SCALE_X = global.HSM_BG_SCALE_X / 100.0;
    HSM_BG_POS_X = global.HSM_BG_POS_X / (-100.0);
    HSM_BG_POS_Y = global.HSM_BG_POS_Y / 100.0;
    HSM_BG_WRAP_MODE = global.HSM_BG_WRAP_MODE;
    HSM_VIEWPORT_VIGNETTE_OPACITY = global.HSM_VIEWPORT_VIGNETTE_OPACITY / 100.0;
    HSM_VIEWPORT_VIGNETTE_MASK_MODE = global.HSM_VIEWPORT_VIGNETTE_MASK_MODE;
    HSM_VIEWPORT_VIGNETTE_CUTOUT_MODE = global.HSM_VIEWPORT_VIGNETTE_CUTOUT_MODE;
    HSM_VIEWPORT_VIGNETTE_FOLLOW_LAYER = global.HSM_VIEWPORT_VIGNETTE_FOLLOW_LAYER;
    HSM_VIEWPORT_VIGNETTE_SCALE = global.HSM_VIEWPORT_VIGNETTE_SCALE / 100.0;
    HSM_VIEWPORT_VIGNETTE_SCALE_X = global.HSM_VIEWPORT_VIGNETTE_SCALE_X / 100.0;
    HSM_VIEWPORT_VIGNETTE_POS_X = global.HSM_VIEWPORT_VIGNETTE_POS_X / (-100.0);
    HSM_VIEWPORT_VIGNETTE_POS_Y = global.HSM_VIEWPORT_VIGNETTE_POS_Y / 100.0;
    HSM_LED_OPACITY = global.HSM_LED_OPACITY / 100.0;
    HSM_LED_COLORIZE_ON = global.HSM_LED_COLORIZE_ON;
    HSM_LED_HUE = global.HSM_LED_HUE / 360.0;
    HSM_LED_SATURATION = global.HSM_LED_SATURATION / 100.0;
    HSM_LED_BRIGHTNESS = global.HSM_LED_BRIGHTNESS / 100.0;
    HSM_LED_GAMMA = global.HSM_LED_GAMMA;
    HSM_LED_AMBIENT_LIGHTING_MULTIPLIER = global.HSM_LED_AMBIENT_LIGHTING_MULTIPLIER / 100.0;
    HSM_LED_AMBIENT2_LIGHTING_MULTIPLIER = global.HSM_LED_AMBIENT2_LIGHTING_MULTIPLIER / 100.0;
    HSM_LED_APPLY_AMBIENT_IN_ADD_MODE = global.HSM_LED_APPLY_AMBIENT_IN_ADD_MODE;
    HSM_LED_BLEND_MODE = global.HSM_LED_BLEND_MODE;
    HSM_LED_SOURCE_MATTE_TYPE = global.HSM_LED_SOURCE_MATTE_TYPE;
    HSM_LED_MASK_MODE = global.HSM_LED_MASK_MODE;
    HSM_LED_MIPMAPPING_BLEND_BIAS = global.HSM_LED_MIPMAPPING_BLEND_BIAS;
    HSM_LED_CUTOUT_MODE = global.HSM_LED_CUTOUT_MODE;
    HSM_LED_DUALSCREEN_VIS_MODE = global.HSM_LED_DUALSCREEN_VIS_MODE;
    HSM_LED_FOLLOW_LAYER = global.HSM_LED_FOLLOW_LAYER;
    HSM_LED_FOLLOW_MODE = global.HSM_LED_FOLLOW_MODE;
    HSM_LED_FOLLOW_FULL_USES_ZOOM = global.HSM_LED_FOLLOW_FULL_USES_ZOOM;
    HSM_LED_FILL_MODE = global.HSM_LED_FILL_MODE;
    HSM_LED_SPLIT_PRESERVE_CENTER = global.HSM_LED_SPLIT_PRESERVE_CENTER / 1000.0;
    HSM_LED_SPLIT_REPEAT_WIDTH = global.HSM_LED_SPLIT_REPEAT_WIDTH / 1000.0;
    HSM_LED_SCALE = global.HSM_LED_SCALE / 100.0;
    HSM_LED_SCALE_X = global.HSM_LED_SCALE_X / 100.0;
    HSM_LED_POS_X = global.HSM_LED_POS_X / (-100.0);
    HSM_LED_POS_Y = global.HSM_LED_POS_Y / 100.0;
    HSM_DEVICE_OPACITY = global.HSM_DEVICE_OPACITY / 100.0;
    HSM_DEVICE_COLORIZE_ON = global.HSM_DEVICE_COLORIZE_ON;
    HSM_DEVICE_HUE = global.HSM_DEVICE_HUE / 360.0;
    HSM_DEVICE_SATURATION = global.HSM_DEVICE_SATURATION / 100.0;
    HSM_DEVICE_BRIGHTNESS = global.HSM_DEVICE_BRIGHTNESS / 100.0;
    HSM_DEVICE_GAMMA = global.HSM_DEVICE_GAMMA;
    HSM_DEVICE_AMBIENT_LIGHTING_MULTIPLIER = global.HSM_DEVICE_AMBIENT_LIGHTING_MULTIPLIER / 100.0;
    HSM_DEVICE_AMBIENT2_LIGHTING_MULTIPLIER = global.HSM_DEVICE_AMBIENT2_LIGHTING_MULTIPLIER / 100.0;
    HSM_DEVICE_APPLY_AMBIENT_IN_ADD_MODE = global.HSM_DEVICE_APPLY_AMBIENT_IN_ADD_MODE;
    HSM_DEVICE_BLEND_MODE = global.HSM_DEVICE_BLEND_MODE;
    HSM_DEVICE_SOURCE_MATTE_TYPE = global.HSM_DEVICE_SOURCE_MATTE_TYPE;
    HSM_DEVICE_MASK_MODE = global.HSM_DEVICE_MASK_MODE;
    HSM_DEVICE_MIPMAPPING_BLEND_BIAS = global.HSM_DEVICE_MIPMAPPING_BLEND_BIAS;
    HSM_DEVICE_CUTOUT_MODE = global.HSM_DEVICE_CUTOUT_MODE;
    HSM_DEVICE_DUALSCREEN_VIS_MODE = global.HSM_DEVICE_DUALSCREEN_VIS_MODE;
    HSM_DEVICE_FOLLOW_LAYER = global.HSM_DEVICE_FOLLOW_LAYER;
    HSM_DEVICE_FOLLOW_MODE = global.HSM_DEVICE_FOLLOW_MODE;
    HSM_DEVICE_FOLLOW_FULL_USES_ZOOM = global.HSM_DEVICE_FOLLOW_FULL_USES_ZOOM;
    HSM_DEVICE_FILL_MODE = global.HSM_DEVICE_FILL_MODE;
    HSM_DEVICE_SPLIT_PRESERVE_CENTER = global.HSM_DEVICE_SPLIT_PRESERVE_CENTER / 1000.0;
    HSM_DEVICE_SPLIT_REPEAT_WIDTH = global.HSM_DEVICE_SPLIT_REPEAT_WIDTH / 1000.0;
    HSM_DEVICE_SCALE = global.HSM_DEVICE_SCALE / 100.0;
    HSM_DEVICE_SCALE_X = global.HSM_DEVICE_SCALE_X / 100.0;
    HSM_DEVICE_POS_X = global.HSM_DEVICE_POS_X / (-100.0);
    HSM_DEVICE_POS_Y = global.HSM_DEVICE_POS_Y / 100.0;
    HSM_DEVICELED_OPACITY = global.HSM_DEVICELED_OPACITY / 100.0;
    HSM_DEVICELED_COLORIZE_ON = global.HSM_DEVICELED_COLORIZE_ON;
    HSM_DEVICELED_HUE = global.HSM_DEVICELED_HUE / 360.0;
    HSM_DEVICELED_SATURATION = global.HSM_DEVICELED_SATURATION / 100.0;
    HSM_DEVICELED_BRIGHTNESS = global.HSM_DEVICELED_BRIGHTNESS / 100.0;
    HSM_DEVICELED_GAMMA = global.HSM_DEVICELED_GAMMA;
    HSM_DEVICELED_AMBIENT_LIGHTING_MULTIPLIER = global.HSM_DEVICELED_AMBIENT_LIGHTING_MULTIPLIER / 100.0;
    HSM_DEVICELED_AMBIENT2_LIGHTING_MULTIPLIER = global.HSM_DEVICELED_AMBIENT2_LIGHTING_MULTIPLIER / 100.0;
    HSM_DEVICELED_APPLY_AMBIENT_IN_ADD_MODE = global.HSM_DEVICELED_APPLY_AMBIENT_IN_ADD_MODE;
    HSM_DEVICELED_BLEND_MODE = global.HSM_DEVICELED_BLEND_MODE;
    HSM_DEVICELED_SOURCE_MATTE_TYPE = global.HSM_DEVICELED_SOURCE_MATTE_TYPE;
    HSM_DEVICELED_MASK_MODE = global.HSM_DEVICELED_MASK_MODE;
    HSM_DEVICELED_MIPMAPPING_BLEND_BIAS = global.HSM_DEVICELED_MIPMAPPING_BLEND_BIAS;
    HSM_DEVICELED_CUTOUT_MODE = global.HSM_DEVICELED_CUTOUT_MODE;
    HSM_DEVICELED_DUALSCREEN_VIS_MODE = global.HSM_DEVICELED_DUALSCREEN_VIS_MODE;
    HSM_DEVICELED_FOLLOW_LAYER = global.HSM_DEVICELED_FOLLOW_LAYER;
    HSM_DEVICELED_FOLLOW_MODE = global.HSM_DEVICELED_FOLLOW_MODE;
    HSM_DEVICELED_FOLLOW_FULL_USES_ZOOM = global.HSM_DEVICELED_FOLLOW_FULL_USES_ZOOM;
    HSM_DEVICELED_FILL_MODE = global.HSM_DEVICELED_FILL_MODE;
    HSM_DEVICELED_SPLIT_PRESERVE_CENTER = global.HSM_DEVICELED_SPLIT_PRESERVE_CENTER / 1000.0;
    HSM_DEVICELED_SPLIT_REPEAT_WIDTH = global.HSM_DEVICELED_SPLIT_REPEAT_WIDTH / 1000.0;
    HSM_DEVICELED_SCALE = global.HSM_DEVICELED_SCALE / 100.0;
    HSM_DEVICELED_SCALE_X = global.HSM_DEVICELED_SCALE_X / 100.0;
    HSM_DEVICELED_POS_X = global.HSM_DEVICELED_POS_X / (-100.0);
    HSM_DEVICELED_POS_Y = global.HSM_DEVICELED_POS_Y / 100.0;
    HSM_DECAL_OPACITY = global.HSM_DECAL_OPACITY / 100.0;
    HSM_DECAL_COLORIZE_ON = global.HSM_DECAL_COLORIZE_ON;
    HSM_DECAL_HUE = global.HSM_DECAL_HUE / 360.0;
    HSM_DECAL_SATURATION = global.HSM_DECAL_SATURATION / 100.0;
    HSM_DECAL_BRIGHTNESS = global.HSM_DECAL_BRIGHTNESS / 100.0;
    HSM_DECAL_GAMMA = global.HSM_DECAL_GAMMA;
    HSM_DECAL_AMBIENT_LIGHTING_MULTIPLIER = global.HSM_DECAL_AMBIENT_LIGHTING_MULTIPLIER / 100.0;
    HSM_DECAL_AMBIENT2_LIGHTING_MULTIPLIER = global.HSM_DECAL_AMBIENT2_LIGHTING_MULTIPLIER / 100.0;
    HSM_DECAL_APPLY_AMBIENT_IN_ADD_MODE = global.HSM_DECAL_APPLY_AMBIENT_IN_ADD_MODE;
    HSM_DECAL_BLEND_MODE = global.HSM_DECAL_BLEND_MODE;
    HSM_DECAL_SOURCE_MATTE_TYPE = global.HSM_DECAL_SOURCE_MATTE_TYPE;
    HSM_DECAL_MIPMAPPING_BLEND_BIAS = global.HSM_DECAL_MIPMAPPING_BLEND_BIAS;
    HSM_DECAL_MASK_MODE = global.HSM_DECAL_MASK_MODE;
    HSM_DECAL_CUTOUT_MODE = global.HSM_DECAL_CUTOUT_MODE;
    HSM_DECAL_DUALSCREEN_VIS_MODE = global.HSM_DECAL_DUALSCREEN_VIS_MODE;
    HSM_DECAL_FOLLOW_LAYER = global.HSM_DECAL_FOLLOW_LAYER;
    HSM_DECAL_FOLLOW_MODE = global.HSM_DECAL_FOLLOW_MODE;
    HSM_DECAL_FOLLOW_FULL_USES_ZOOM = global.HSM_DECAL_FOLLOW_FULL_USES_ZOOM;
    HSM_DECAL_FILL_MODE = global.HSM_DECAL_FILL_MODE;
    HSM_DECAL_SPLIT_PRESERVE_CENTER = global.HSM_DECAL_SPLIT_PRESERVE_CENTER / 1000.0;
    HSM_DECAL_SPLIT_REPEAT_WIDTH = global.HSM_DECAL_SPLIT_REPEAT_WIDTH / 1000.0;
    HSM_DECAL_SCALE = global.HSM_DECAL_SCALE / 100.0;
    HSM_DECAL_SCALE_X = global.HSM_DECAL_SCALE_X / 100.0;
    HSM_DECAL_POS_X = global.HSM_DECAL_POS_X / (-100.0);
    HSM_DECAL_POS_Y = global.HSM_DECAL_POS_Y / 100.0;
    HSM_CAB_GLASS_OPACITY = global.HSM_CAB_GLASS_OPACITY / 100.0;
    HSM_CAB_GLASS_COLORIZE_ON = global.HSM_CAB_GLASS_COLORIZE_ON;
    HSM_CAB_GLASS_HUE = global.HSM_CAB_GLASS_HUE / 360.0;
    HSM_CAB_GLASS_SATURATION = global.HSM_CAB_GLASS_SATURATION / 100.0;
    HSM_CAB_GLASS_BRIGHTNESS = global.HSM_CAB_GLASS_BRIGHTNESS / 100.0;
    HSM_CAB_GLASS_GAMMA = global.HSM_CAB_GLASS_GAMMA;
    HSM_CAB_GLASS_AMBIENT_LIGHTING_MULTIPLIER = global.HSM_CAB_GLASS_AMBIENT_LIGHTING_MULTIPLIER / 100.0;
    HSM_CAB_GLASS_AMBIENT2_LIGHTING_MULTIPLIER = global.HSM_CAB_GLASS_AMBIENT2_LIGHTING_MULTIPLIER / 100.0;
    HSM_CAB_GLASS_APPLY_AMBIENT_IN_ADD_MODE = global.HSM_CAB_GLASS_APPLY_AMBIENT_IN_ADD_MODE;
    HSM_CAB_GLASS_BLEND_MODE = global.HSM_CAB_GLASS_BLEND_MODE;
    HSM_CAB_GLASS_SOURCE_MATTE_TYPE = global.HSM_CAB_GLASS_SOURCE_MATTE_TYPE;
    HSM_CAB_GLASS_MIPMAPPING_BLEND_BIAS = global.HSM_CAB_GLASS_MIPMAPPING_BLEND_BIAS;
    HSM_CAB_GLASS_MASK_MODE = global.HSM_CAB_GLASS_MASK_MODE;
    HSM_CAB_GLASS_CUTOUT_MODE = global.HSM_CAB_GLASS_CUTOUT_MODE;
    HSM_CAB_GLASS_DUALSCREEN_VIS_MODE = global.HSM_CAB_GLASS_DUALSCREEN_VIS_MODE;
    HSM_CAB_GLASS_FOLLOW_LAYER = global.HSM_CAB_GLASS_FOLLOW_LAYER;
    HSM_CAB_GLASS_FOLLOW_MODE = global.HSM_CAB_GLASS_FOLLOW_MODE;
    HSM_CAB_GLASS_FOLLOW_FULL_USES_ZOOM = global.HSM_CAB_GLASS_FOLLOW_FULL_USES_ZOOM;
    HSM_CAB_GLASS_FILL_MODE = global.HSM_CAB_GLASS_FILL_MODE;
    HSM_CAB_GLASS_SPLIT_PRESERVE_CENTER = global.HSM_CAB_GLASS_SPLIT_PRESERVE_CENTER / 1000.0;
    HSM_CAB_GLASS_SPLIT_REPEAT_WIDTH = global.HSM_CAB_GLASS_SPLIT_REPEAT_WIDTH / 1000.0;
    HSM_CAB_GLASS_SCALE = global.HSM_CAB_GLASS_SCALE / 100.0;
    HSM_CAB_GLASS_SCALE_X = global.HSM_CAB_GLASS_SCALE_X / 100.0;
    HSM_CAB_GLASS_POS_X = global.HSM_CAB_GLASS_POS_X / (-100.0);
    HSM_CAB_GLASS_POS_Y = global.HSM_CAB_GLASS_POS_Y / 100.0;
    HSM_TOP_OPACITY = global.HSM_TOP_OPACITY / 100.0;
    HSM_TOP_COLORIZE_ON = global.HSM_TOP_COLORIZE_ON;
    HSM_TOP_HUE = global.HSM_TOP_HUE / 360.0;
    HSM_TOP_SATURATION = global.HSM_TOP_SATURATION / 100.0;
    HSM_TOP_BRIGHTNESS = global.HSM_TOP_BRIGHTNESS / 100.0;
    HSM_TOP_GAMMA = global.HSM_TOP_GAMMA;
    HSM_TOP_AMBIENT_LIGHTING_MULTIPLIER = global.HSM_TOP_AMBIENT_LIGHTING_MULTIPLIER / 100.0;
    HSM_TOP_AMBIENT2_LIGHTING_MULTIPLIER = global.HSM_TOP_AMBIENT2_LIGHTING_MULTIPLIER / 100.0;
    HSM_TOP_APPLY_AMBIENT_IN_ADD_MODE = global.HSM_TOP_APPLY_AMBIENT_IN_ADD_MODE;
    HSM_TOP_BLEND_MODE = global.HSM_TOP_BLEND_MODE;
    HSM_TOP_SOURCE_MATTE_TYPE = global.HSM_TOP_SOURCE_MATTE_TYPE;
    HSM_TOP_MIPMAPPING_BLEND_BIAS = global.HSM_TOP_MIPMAPPING_BLEND_BIAS;
    HSM_TOP_MASK_MODE = global.HSM_TOP_MASK_MODE;
    HSM_TOP_CUTOUT_MODE = global.HSM_TOP_CUTOUT_MODE;
    HSM_TOP_DUALSCREEN_VIS_MODE = global.HSM_TOP_DUALSCREEN_VIS_MODE;
    HSM_TOP_FOLLOW_LAYER = global.HSM_TOP_FOLLOW_LAYER;
    HSM_TOP_FOLLOW_MODE = global.HSM_TOP_FOLLOW_MODE;
    HSM_TOP_FOLLOW_FULL_USES_ZOOM = global.HSM_TOP_FOLLOW_FULL_USES_ZOOM;
    HSM_TOP_FILL_MODE = global.HSM_TOP_FILL_MODE;
    HSM_TOP_SPLIT_PRESERVE_CENTER = global.HSM_TOP_SPLIT_PRESERVE_CENTER / 1000.0;
    HSM_TOP_SPLIT_REPEAT_WIDTH = global.HSM_TOP_SPLIT_REPEAT_WIDTH / 1000.0;
    HSM_TOP_SCALE = global.HSM_TOP_SCALE / 100.0;
    HSM_TOP_SCALE_X = global.HSM_TOP_SCALE_X / 100.0;
    HSM_TOP_POS_X = global.HSM_TOP_POS_X / (-100.0);
    HSM_TOP_POS_Y = global.HSM_TOP_POS_Y / 100.0;
    HSM_TOP_MIRROR_WRAP = global.HSM_TOP_MIRROR_WRAP;
    HSM_RENDER_SIMPLE_MODE = global.HSM_RENDER_SIMPLE_MODE;
    HSM_RENDER_SIMPLE_MASK_TYPE = global.HSM_RENDER_SIMPLE_MASK_TYPE;
    SOURCE_MATTE_PREMULTIPLIED = 0.0;
    SOURCE_MATTE_WHITE = 1.0;
    SOURCE_MATTE_NONE = 2.0;
    BLEND_MODE_OFF = 0.0;
    BLEND_MODE_NORMAL = 1.0;
    BLEND_MODE_ADD = 2.0;
    BLEND_MODE_MULTIPLY = 3.0;
    CURVATURE_MODE_OFF = 0.0;
    CURVATURE_MODE_2D = 1.0;
    CURVATURE_MODE_2D_CYLINDER = 2.0;
    CURVATURE_MODE_3D_1 = 3.0;
    CURVATURE_MODE_3D_2 = 4.0;
    CURVATURE_MODE_3D_CYLINDER = 5.0;
    MAX_LAYER_ORDER = 12.0;
    FILL_MODE_KEEP_TEXTURE_ASPECT = 0.0;
    FILL_MODE_SPLIT = 1.0;
    FILL_MODE_STRETCH = 2.0;
    USE_INHERITED_COORD_OFF = 0.0;
    USE_INHERITED_COORD_ON = 1.0;
    VIEWPORT_COORD = vec2(0.5);
    bool _7239 = HSM_AB_COMPARE_FREEZE_GRAPHICS == 1.0;
    bool _7247;
    if (_7239)
    {
        highp vec2 param = vTexCoord;
        _7247 = HSM_GetIsInABCompareArea(param);
    }
    else
    {
        _7247 = _7239;
    }
    if (_7247)
    {
        FragColor = texture(BR_LayersUnderCRTPassFeedback, vTexCoord);
        return;
    }
    highp vec2 param_1 = vTexCoord;
    VIEWPORT_UNSCALED_COORD = HSM_GetViewportCoordWithFlip(param_1);
    highp vec2 param_2 = vTexCoord;
    VIEWPORT_COORD = HSM_GetViewportCoordWithZoomAndPan(param_2);
    highp vec2 param_3 = vTexCoord;
    highp vec4 _7266 = HSM_UpdateGlobalScreenValuesFromCache(InfoCachePass, param_3);
    highp vec4 feedback_color_test = texture(BR_LayersUnderCRTPassFeedback, vec2(0.0));
    bool _7271 = HSM_CACHE_GRAPHICS_ON > 0.5;
    bool _7277;
    if (_7271)
    {
        _7277 = feedback_color_test.w < 0.0;
    }
    else
    {
        _7277 = _7271;
    }
    if (_7277 && (!CACHE_INFO_CHANGED))
    {
        FragColor = texture(BR_LayersUnderCRTPassFeedback, UNFLIPPED_VIEWPORT_COORD);
        return;
    }
    highp vec4 ambient_image = vec4(1.0);
    highp vec4 ambient2_image = vec4(1.0);
    highp vec2 param_4 = VIEWPORT_COORD;
    highp vec2 param_5 = VIEWPORT_UNSCALED_COORD;
    highp vec2 param_6 = TUBE_DIFFUSE_COORD;
    highp vec2 param_7 = TUBE_DIFFUSE_SCALE;
    highp float param_8 = HSM_AMBIENT_LIGHTING_SWAP_IMAGE_MODE;
    highp vec4 param_9 = ambient_image;
    highp vec4 param_10 = ambient2_image;
    bool _7306 = HSM_Fill_Ambient_Images(param_4, param_5, param_6, param_7, param_8, NightLightingImage, NightLighting2Image, param_9, param_10);
    ambient_image = param_9;
    ambient2_image = param_10;
    highp vec2 param_11 = SCREEN_COORD;
    highp float param_12 = global.HSM_TUBE_BLACK_EDGE_CURVATURE_SCALE / 100.0;
    highp float param_13 = TUBE_DIFFUSE_ASPECT;
    TUBE_DIFFUSE_CURVED_COORD = HSM_GetCurvedCoord(param_11, param_12, param_13);
    highp vec2 param_14 = TUBE_DIFFUSE_COORD;
    highp float param_15 = 1.0;
    highp vec2 param_16 = TUBE_DIFFUSE_SCALE;
    highp vec2 param_17 = TUBE_SCALE;
    highp float param_18 = TUBE_DIFFUSE_ASPECT;
    highp float param_19 = 1.0;
    highp vec2 tube_curved_coord = HSM_GetTubeCurvedCoord(param_14, param_15, param_16, param_17, param_18, param_19);
    highp vec2 tube_curved_coord_ctr = tube_curved_coord - vec2(0.5);
    highp vec2 edge_mask_coord = (tube_curved_coord_ctr * (vec2(1.0) - (vec2(HSM_BZL_INNER_EDGE_THICKNESS) / vec2(TUBE_DIFFUSE_ASPECT, 1.0)))) + vec2(0.5);
    highp float bezel_corner_radius = HSM_BZL_INNER_CORNER_RADIUS_SCALE * global.HSM_GLOBAL_CORNER_RADIUS;
    if (global.HSM_BZL_USE_INDEPENDENT_CURVATURE > 0.0)
    {
        bezel_corner_radius = HSM_BZL_INNER_CORNER_RADIUS_SCALE * 10.0;
    }
    highp vec2 param_20 = edge_mask_coord;
    highp float param_21 = TUBE_DIFFUSE_ASPECT;
    highp float param_22 = bezel_corner_radius;
    highp float param_23 = HSM_BZL_INNER_EDGE_SHARPNESS;
    highp float edge_mask = HSM_GetCornerMask(param_20, param_21, param_22, param_23);
    highp vec2 param_24 = tube_curved_coord;
    highp float param_25 = TUBE_DIFFUSE_ASPECT;
    highp float param_26 = bezel_corner_radius;
    highp float param_27 = 0.9900000095367431640625;
    TUBE_MASK = HSM_GetCornerMask(param_24, param_25, param_26, param_27);
    highp vec2 param_28 = ((TUBE_DIFFUSE_CURVED_COORD - vec2(0.5)) * 1.00100004673004150390625) + vec2(0.5);
    highp float param_29 = TUBE_DIFFUSE_ASPECT;
    highp float param_30 = (global.HSM_GLOBAL_CORNER_RADIUS * global.HSM_TUBE_BLACK_EDGE_CORNER_RADIUS_SCALE) / 100.0;
    highp float param_31 = global.HSM_TUBE_BLACK_EDGE_SHARPNESS / 100.0;
    TUBE_DIFFUSE_MASK = HSM_GetCornerMask(param_28, param_29, param_30, param_31);
    highp float outermap_scale = 2.2999999523162841796875;
    highp float outermap_range = (0.5 * outermap_scale) * 0.699999988079071044921875;
    highp vec2 outermap_screen_size_from_center = vec2(0.5);
    highp vec2 outermap_warped_outside_screen_vector = (tube_curved_coord_ctr - clamp(tube_curved_coord_ctr, vec2(-0.4900000095367431640625), vec2(0.4900000095367431640625))) * vec2(1.0 / TUBE_DIFFUSE_ASPECT, 1.0);
    highp float output_aspect = global.OutputSize.x / global.OutputSize.y;
    highp float outside_ratio_warped = clamp(length(outermap_warped_outside_screen_vector) / outermap_range, 0.0, 1.0);
    highp vec2 outermap_screen_corner_ctr_coord = vec2(0.5, -0.5);
    highp vec2 outermap_coord_warped_ctr_at_screen_corner = abs(tube_curved_coord_ctr) - vec2(0.5);
    highp vec2 param_32 = TUBE_DIFFUSE_COORD;
    highp vec2 param_33 = TUBE_DIFFUSE_SCALE;
    highp vec2 param_34 = TUBE_SCALE;
    highp float param_35 = TUBE_DIFFUSE_ASPECT;
    bool param_36 = true;
    highp vec2 param_37 = BEZEL_OUTSIDE_SCALE;
    highp vec2 param_38 = BEZEL_OUTSIDE_COORD;
    highp vec2 param_39 = BEZEL_OUTSIDE_CURVED_COORD;
    highp vec2 param_40 = FRAME_OUTSIDE_CURVED_COORD;
    highp float _7458 = HSM_GetBezelCoords(param_32, param_33, param_34, param_35, param_36, param_37, param_38, param_39, param_40);
    BEZEL_OUTSIDE_SCALE = param_37;
    BEZEL_OUTSIDE_COORD = param_38;
    BEZEL_OUTSIDE_CURVED_COORD = param_39;
    FRAME_OUTSIDE_CURVED_COORD = param_40;
    highp vec2 param_41 = BEZEL_OUTSIDE_CURVED_COORD;
    highp float param_42 = TUBE_DIFFUSE_ASPECT;
    highp float param_43 = global.HSM_GLOBAL_CORNER_RADIUS * HSM_BZL_OUTER_CORNER_RADIUS_SCALE;
    highp float param_44 = 0.89999997615814208984375;
    OUTSIDE_BEZEL_MASK = 1.0 - HSM_GetCornerMask(param_41, param_42, param_43, param_44);
    highp vec2 frame_outside_coord_ctr = FRAME_OUTSIDE_CURVED_COORD - vec2(0.5);
    highp vec2 param_45 = (frame_outside_coord_ctr * 1.0099999904632568359375) + vec2(0.5);
    highp float param_46 = TUBE_DIFFUSE_ASPECT;
    highp float param_47 = HSM_FRM_OUTER_CORNER_RADIUS;
    highp float param_48 = 1.0;
    highp float SHADOW_OUTSIDE_FRAME_MASK = 1.0 - HSM_GetCornerMask(param_45, param_46, param_47, param_48);
    highp vec2 param_49 = frame_outside_coord_ctr + vec2(0.5);
    highp float param_50 = TUBE_DIFFUSE_ASPECT;
    highp float param_51 = HSM_FRM_OUTER_CORNER_RADIUS;
    highp float param_52 = 1.0;
    OUTSIDE_FRAME_MASK = 1.0 - HSM_GetCornerMask(param_49, param_50, param_51, param_52);
    highp vec2 param_53 = (frame_outside_coord_ctr * 0.999000012874603271484375) + vec2(0.5);
    highp float param_54 = TUBE_DIFFUSE_ASPECT;
    highp float param_55 = HSM_FRM_OUTER_CORNER_RADIUS;
    highp float param_56 = 1.0;
    OUTSIDE_FRAME_MASK_FOR_IMAGE = 1.0 - HSM_GetCornerMask(param_53, param_54, param_55, param_56);
    INSIDE_BEZEL_MASK = 1.0 - OUTSIDE_BEZEL_MASK;
    BEZEL_MASK = INSIDE_BEZEL_MASK * (1.0 - TUBE_MASK);
    FRAME_MASK = OUTSIDE_BEZEL_MASK * (1.0 - OUTSIDE_FRAME_MASK);
    highp vec2 pos_shift_offset = (vec2(0.0, HSM_BZL_OUTER_POSITION_Y) * TUBE_DIFFUSE_SCALE.y) / vec2(outermap_scale);
    pos_shift_offset *= float((tube_curved_coord.y > 0.5) ? 1 : (-1));
    highp vec2 corner_crease_dir = ((outermap_screen_corner_ctr_coord + pos_shift_offset) / vec2(HSM_BZL_HEIGHT + 1.0, HSM_BZL_WIDTH + 1.0)) - outermap_screen_corner_ctr_coord;
    corner_crease_dir *= vec2(TUBE_DIFFUSE_ASPECT, 1.0);
    highp float aspect_corner_length_scale_offset = (TUBE_DIFFUSE_ASPECT > 1.0) ? 0.89999997615814208984375 : 1.5;
    highp float corner_crease_length = length(corner_crease_dir * aspect_corner_length_scale_offset);
    highp float _7573;
    if (SCREEN_COORD.y < 0.5)
    {
        _7573 = -HSM_REFLECT_CORNER_ROTATION_OFFSET_TOP;
    }
    else
    {
        _7573 = -HSM_REFLECT_CORNER_ROTATION_OFFSET_BOTTOM;
    }
    highp float corner_rotation_offset = _7573;
    if (HSM_CURVATURE_MODE == 0.0)
    {
        corner_rotation_offset += float((TUBE_DIFFUSE_ASPECT > 1.0) ? 2 : 3);
    }
    highp float corner_angle_degrees = (atan(corner_crease_dir.y / corner_crease_dir.x) / 6.28299999237060546875) * 360.0;
    corner_angle_degrees += corner_rotation_offset;
    highp float corner_angle_radians = ((corner_angle_degrees / 360.0) * 2.0) * 3.141499996185302734375;
    corner_crease_dir = vec2(cos(corner_angle_radians), sin(corner_angle_radians));
    highp float param_57 = outermap_coord_warped_ctr_at_screen_corner.x;
    highp float param_58 = outermap_coord_warped_ctr_at_screen_corner.y;
    highp float param_59 = 1.0;
    highp float param_60 = corner_crease_dir.y / corner_crease_dir.x;
    highp float param_61 = 0.0;
    highp float distance_from_crease = HHLP_GetDistanceToLine(param_57, param_58, param_59, param_60, param_61);
    highp float param_62 = clamp(length(outermap_warped_outside_screen_vector) / (corner_crease_length * 2.0), 0.0, 1.0);
    highp vec2 param_63 = vec2(0.5, HSM_REFLECT_CORNER_SPREAD_FALLOFF / 100.0);
    highp float _7644 = HHLP_QuadraticBezier(param_62, param_63);
    highp float fade_out_to_corner = _7644;
    highp float corner_fade_width_inner = ((((HSM_REFLECT_CORNER_INNER_SPREAD * (TUBE_DIFFUSE_SCALE.x + TUBE_DIFFUSE_SCALE.y)) * bezel_corner_radius) / 10.0) / 250.0) * 1.2000000476837158203125;
    highp float corner_fade_width_outer = (((((HSM_REFLECT_CORNER_OUTER_SPREAD * (TUBE_DIFFUSE_SCALE.x + TUBE_DIFFUSE_SCALE.y)) * global.HSM_GLOBAL_CORNER_RADIUS) * HSM_BZL_OUTER_CORNER_RADIUS_SCALE) / 10.0) / 250.0) * 1.60000002384185791015625;
    highp float corner_fade_width = corner_fade_width_inner + (fade_out_to_corner * (corner_fade_width_outer - corner_fade_width_inner));
    highp vec2 corner_crease_perp_dir = normalize(vec2(corner_crease_dir.y, corner_crease_dir.x));
    highp vec2 corner_coord_shifted = outermap_coord_warped_ctr_at_screen_corner - ((corner_crease_perp_dir * corner_fade_width) / vec2(2.0));
    highp vec2 corner_crease_dir_shifted = corner_crease_dir - ((corner_crease_perp_dir * corner_fade_width) / vec2(2.0));
    highp float param_64 = corner_coord_shifted.x;
    highp float param_65 = corner_coord_shifted.y;
    highp float param_66 = 1.0;
    highp float param_67 = corner_crease_dir_shifted.y / corner_crease_dir_shifted.x;
    highp float param_68 = 0.0;
    highp float distance_from_crease_shifted = HHLP_GetDistanceToLine(param_64, param_65, param_66, param_67, param_68);
    highp float top_half_mask = smoothstep(0.550000011920928955078125, 0.5, tube_curved_coord.y);
    highp float left_half_mask = smoothstep(0.550000011920928955078125, 0.5, tube_curved_coord.x);
    highp float _7740;
    if (dot(normalize(corner_coord_shifted), normalize(corner_crease_dir_shifted)) > 0.0)
    {
        _7740 = 1.0 - smoothstep(0.0, corner_fade_width / 2.0, distance_from_crease_shifted);
    }
    else
    {
        _7740 = 1.0;
    }
    highp float top_bottom_vs_sides_mask = _7740;
    highp float sides_mask = 1.0 - top_bottom_vs_sides_mask;
    highp float top_mask = top_half_mask * top_bottom_vs_sides_mask;
    highp float bottom_mask = (1.0 - top_half_mask) * top_bottom_vs_sides_mask;
    highp float corner_mask = smoothstep(corner_fade_width / 2.0, 0.0, distance_from_crease);
    highp float top_corner_mask = corner_mask * top_half_mask;
    highp float bottom_corner_mask = corner_mask * (1.0 - top_half_mask);
    highp float _7779;
    if (HSM_FRM_INNER_EDGE_THICKNESS == 0.0)
    {
        _7779 = 0.0;
    }
    else
    {
        highp vec2 param_69 = ((BEZEL_OUTSIDE_CURVED_COORD - vec2(0.5)) * (vec2(1.0) + (vec2(HSM_FRM_INNER_EDGE_THICKNESS) / vec2(TUBE_DIFFUSE_ASPECT, 1.0)))) + vec2(0.5);
        highp float param_70 = TUBE_DIFFUSE_ASPECT;
        highp float param_71 = HSM_BZL_OUTER_CORNER_RADIUS_SCALE * global.HSM_GLOBAL_CORNER_RADIUS;
        highp float param_72 = 0.89999997615814208984375;
        _7779 = 1.0 - HSM_GetCornerMask(param_69, param_70, param_71, param_72);
    }
    highp float frame_inner_edge_mask = _7779;
    highp vec2 param_73 = (tube_curved_coord_ctr * 0.995999991893768310546875) + vec2(0.5);
    highp float param_74 = TUBE_DIFFUSE_ASPECT;
    highp float param_75 = bezel_corner_radius;
    highp float param_76 = 0.89999997615814208984375;
    highp float outside_tube_mask_wider = 1.0 - HSM_GetCornerMask(param_73, param_74, param_75, param_76);
    highp vec2 param_77 = tube_curved_coord_ctr + vec2(0.5);
    highp float param_78 = TUBE_DIFFUSE_ASPECT;
    highp float param_79 = bezel_corner_radius;
    highp float param_80 = 0.0;
    highp float tube_shadow_mask = HSM_GetCornerMask(param_77, param_78, param_79, param_80);
    highp float tube_edge_shadow_mult = (HSM_BZL_INNER_EDGE_SHADOW * tube_shadow_mask) + (1.0 - HSM_BZL_INNER_EDGE_SHADOW);
    highp float edge_highlight_mask = 0.0;
    highp float hmbz_bezel_highlight_edge = 0.89999997615814208984375;
    highp float hmbz_bezel_highlight_top = 0.20000000298023223876953125;
    highp float hmbz_bezel_highlight_bottom = 0.300000011920928955078125;
    highp float hmbz_bezel_highlight_sides = 0.20000000298023223876953125;
    highp float hmbz_bezel_highlight_falloff_speed = 0.5;
    highp float hmbz_bezel_highlight_width = 0.25;
    highp float hmbz_bezel_edge_highlight_width = 0.800000011920928955078125;
    highp float hmbz_bezel_brightness_frame_inner_edge = 0.01400000043213367462158203125;
    highp float hmbz_bezel_brightness_frame_outer_edge = 0.0;
    highp float hmbz_brightness_shadow = 0.0;
    highp float hmbz_frame_brightness = 100.0;
    highp vec3 param_81 = vec3(HSM_BZL_COLOR_HUE, HSM_BZL_COLOR_SATURATION, HSM_BZL_COLOR_VALUE);
    highp vec4 param_82 = vec4(HSM_HSVtoRGB(param_81), 1.0);
    highp float param_83 = 2.2000000476837158203125;
    highp vec3 base_color = HSM_Linearize(param_82, param_83).xyz;
    highp float noise_mask = clamp(fract(sin(dot((tube_curved_coord_ctr + vec2(0.5)) + vec2(1.0), vec2(12.98980045318603515625, 78.233001708984375))) * 43758.546875), 0.0, 1.0);
    highp vec3 base_color_with_noise = mix(base_color, (base_color * 1.5) * noise_mask, vec3(HSM_BZL_NOISE));
    highp vec3 top_color = base_color_with_noise * (HSM_BZL_BRIGHTNESS_MULT_TOP * HSM_BZL_BRIGHTNESS);
    highp vec3 bottom_color = base_color_with_noise * (HSM_BZL_BRIGHTNESS_MULT_BOTTOM * HSM_BZL_BRIGHTNESS);
    highp vec3 sides_color = mix(base_color_with_noise * ((HSM_BZL_BRIGHTNESS_MULT_SIDES * HSM_BZL_BRIGHTNESS_MULT_SIDE_RIGHT) * HSM_BZL_BRIGHTNESS), base_color_with_noise * ((HSM_BZL_BRIGHTNESS_MULT_SIDES * HSM_BZL_BRIGHTNESS_MULT_SIDE_LEFT) * HSM_BZL_BRIGHTNESS), vec3(left_half_mask));
    highp vec3 frame_base_color = base_color;
    highp vec3 frame_base_color_with_noise = base_color_with_noise;
    if (HSM_FRM_USE_INDEPENDENT_COLOR > 0.0)
    {
        highp vec3 param_84 = vec3(HSM_FRM_COLOR_HUE, HSM_FRM_COLOR_SATURATION, HSM_FRM_COLOR_VALUE);
        highp vec4 param_85 = vec4(HSM_HSVtoRGB(param_84), 1.0);
        highp float param_86 = 2.2000000476837158203125;
        frame_base_color = HSM_Linearize(param_85, param_86).xyz;
        frame_base_color_with_noise = mix(frame_base_color, (frame_base_color * 1.5) * noise_mask, vec3(HSM_FRM_NOISE));
    }
    highp vec3 frame_color = mix(frame_base_color, (frame_base_color * 1.5) * noise_mask, vec3(0.60000002384185791015625 * HSM_FRM_NOISE)) * (hmbz_frame_brightness / 100.0);
    highp vec3 outside_frame_color = base_color_with_noise * hmbz_brightness_shadow;
    highp vec3 bezel_diffuse_color = mix(sides_color, top_color, vec3(top_mask));
    bezel_diffuse_color = mix(bezel_diffuse_color, bottom_color, vec3(bottom_mask));
    highp float param_87 = smoothstep(hmbz_bezel_highlight_width, 0.0, abs(tube_curved_coord_ctr.x));
    highp vec2 param_88 = vec2(0.5, hmbz_bezel_highlight_falloff_speed);
    highp float _7996 = HHLP_QuadraticBezier(param_87, param_88);
    highp float top_center_highlight_mask = (hmbz_bezel_highlight_top * top_mask) * _7996;
    highp float param_89 = smoothstep(hmbz_bezel_highlight_width, 0.0, abs(tube_curved_coord_ctr.x));
    highp vec2 param_90 = vec2(0.5, hmbz_bezel_highlight_falloff_speed);
    highp float _8011 = HHLP_QuadraticBezier(param_89, param_90);
    highp float bottom_center_highlight_mask = (hmbz_bezel_highlight_bottom * bottom_mask) * _8011;
    highp float param_91 = smoothstep(hmbz_bezel_highlight_width, 0.0, abs(tube_curved_coord_ctr.y));
    highp vec2 param_92 = vec2(0.5, hmbz_bezel_highlight_falloff_speed);
    highp float _8026 = HHLP_QuadraticBezier(param_91, param_92);
    highp float sides_highlight_mask = (hmbz_bezel_highlight_sides * sides_mask) * _8026;
    highp float param_93 = smoothstep(hmbz_bezel_edge_highlight_width, 0.0, abs(tube_curved_coord_ctr.x));
    highp vec2 param_94 = vec2(0.800000011920928955078125, 0.0);
    highp float _8040 = HHLP_QuadraticBezier(param_93, param_94);
    highp float edge_top_center_highlight_mask = (hmbz_bezel_highlight_top * top_mask) * _8040;
    highp float param_95 = smoothstep(hmbz_bezel_edge_highlight_width, 0.0, abs(tube_curved_coord_ctr.x));
    highp vec2 param_96 = vec2(0.800000011920928955078125, 0.0);
    highp float _8053 = HHLP_QuadraticBezier(param_95, param_96);
    highp float edge_bottom_center_highlight_mask = (hmbz_bezel_highlight_bottom * bottom_mask) * _8053;
    highp float param_97 = smoothstep(hmbz_bezel_edge_highlight_width, 0.0, abs(tube_curved_coord_ctr.y));
    highp vec2 param_98 = vec2(0.800000011920928955078125, 0.0);
    highp float _8066 = HHLP_QuadraticBezier(param_97, param_98);
    highp float edge_sides_highlight_mask = (hmbz_bezel_highlight_sides * sides_mask) * _8066;
    edge_highlight_mask = (hmbz_bezel_highlight_edge * edge_mask) * ((edge_top_center_highlight_mask + edge_bottom_center_highlight_mask) + edge_sides_highlight_mask);
    highp float combined_highlight_mask = ((1.0 + (2.5 * HSM_BZL_NOISE)) * (1.0 - ((noise_mask * 2.5) * HSM_BZL_NOISE))) * ((top_center_highlight_mask + bottom_center_highlight_mask) + sides_highlight_mask);
    highp float bezel_highlight_multiplier = (HSM_BZL_HIGHLIGHT * combined_highlight_mask) + (HSM_BZL_HIGHLIGHT * edge_highlight_mask);
    highp vec3 bezel_color = (bezel_diffuse_color * (1.0 + (15.0 * bezel_highlight_multiplier))) + vec3(1.0 * bezel_highlight_multiplier);
    highp float inner_edge_highlight_multiplier = hmbz_bezel_brightness_frame_inner_edge + ((HSM_BZL_HIGHLIGHT * 10.0) * hmbz_bezel_brightness_frame_inner_edge);
    highp vec3 frame_inner_edge_color = (frame_base_color * (1.0 + (15.0 * inner_edge_highlight_multiplier))) + vec3(0.5 * inner_edge_highlight_multiplier);
    bezel_color = mix(bezel_color, frame_inner_edge_color, vec3(frame_inner_edge_mask));
    highp float dist_inside_outer_edge = min(0.5 - abs(frame_outside_coord_ctr.x), 0.5 - abs(frame_outside_coord_ctr.y));
    highp float frame_outer_edge_width = HSM_FRM_OUTER_EDGE_THICKNESS;
    highp vec3 frame_diffuse_color = mix(frame_color, frame_color * 0.20000000298023223876953125, vec3(HSM_FRM_OUTER_EDGE_SHADING * smoothstep(frame_outer_edge_width, 0.0, dist_inside_outer_edge)));
    if (HSM_FRM_TEXTURE_OPACITY > 0.0)
    {
        highp vec4 param_99 = texture(FrameTextureImage, FRAME_OUTSIDE_CURVED_COORD);
        highp float param_100 = 2.2000000476837158203125;
        highp vec4 frame_texture_color = HSM_Linearize(param_99, param_100);
        highp vec4 param_101 = vec4(frame_diffuse_color, 1.0);
        highp vec4 param_102 = frame_texture_color;
        highp float param_103 = HSM_FRM_TEXTURE_BLEND_MODE;
        highp float param_104 = HSM_FRM_TEXTURE_OPACITY;
        highp vec4 _8181 = HSM_BlendModeLayerMix(param_101, param_102, param_103, param_104);
        frame_diffuse_color = _8181.xyz;
    }
    highp vec3 bezel_and_frame_rgb = mix(bezel_color, frame_diffuse_color, vec3(OUTSIDE_BEZEL_MASK));
    highp float frame_edge = 0.49500000476837158203125;
    highp float dist_outside_frame = length(clamp(abs(frame_outside_coord_ctr * 1.0099999904632568359375) - vec2(frame_edge), vec2(0.0), vec2(1.0)) * vec2(TUBE_DIFFUSE_ASPECT, 1.0));
    highp vec4 frame_shadow_layer = vec4(0.0);
    if (HSM_FRM_OPACITY > 0.001000000047497451305389404296875)
    {
        highp float param_105 = smoothstep(HSM_FRM_SHADOW_WIDTH, 0.0, dist_outside_frame);
        highp vec2 param_106 = vec2(1.0, 0.0);
        highp float _8217 = HHLP_QuadraticBezier(param_105, param_106);
        frame_shadow_layer.w = SHADOW_OUTSIDE_FRAME_MASK * _8217;
    }
    highp vec4 bezel_layer = vec4(0.0);
    highp vec4 frame_layer = vec4(0.0);
    if ((HSM_BZL_OPACITY > 0.0) || (HSM_FRM_OPACITY > 0.0))
    {
        highp vec4 bezel_and_frame_rgba = vec4(bezel_and_frame_rgb, 1.0);
        if (HSM_STATIC_LAYERS_GAMMA != 1.0)
        {
            highp vec4 param_107 = bezel_and_frame_rgba;
            highp float param_108 = HSM_STATIC_LAYERS_GAMMA;
            bezel_and_frame_rgba = HSM_ApplyGamma(param_107, param_108);
        }
        highp vec3 param_109 = bezel_and_frame_rgba.xyz;
        highp vec3 param_110 = ambient_image.xyz;
        highp vec3 param_111 = ambient2_image.xyz;
        highp float param_112 = HSM_BZL_AMBIENT_LIGHTING_MULTIPLIER;
        highp float param_113 = HSM_BZL_AMBIENT2_LIGHTING_MULTIPLIER;
        highp float param_114 = 1.0;
        highp float param_115 = HSM_BZL_BLEND_MODE;
        highp float param_116 = HSM_AMBIENT_LIGHTING_SWAP_IMAGE_MODE;
        highp vec3 _8262 = ApplyAmbientImages(param_109, param_110, param_111, param_112, param_113, param_114, param_115, param_116);
        bezel_and_frame_rgba.x = _8262.x;
        bezel_and_frame_rgba.y = _8262.y;
        bezel_and_frame_rgba.z = _8262.z;
        highp vec2 param_117 = ((tube_curved_coord - vec2(0.5)) * 1.0039999485015869140625) + vec2(0.5);
        highp float param_118 = TUBE_DIFFUSE_ASPECT;
        highp float param_119 = bezel_corner_radius;
        highp float param_120 = 0.9900000095367431640625;
        highp float tube_mask_contracted = HSM_GetCornerMask(param_117, param_118, param_119, param_120);
        highp float FRAME_AND_BEZEL_MASK = (1.0 - tube_mask_contracted) * (1.0 - OUTSIDE_FRAME_MASK);
        if ((HSM_BZL_OPACITY > 0.0) || (HSM_FRM_OPACITY > 0.0))
        {
            bezel_layer = clamp(bezel_and_frame_rgba * FRAME_AND_BEZEL_MASK, vec4(0.0), vec4(1.0));
        }
        frame_shadow_layer *= HSM_FRM_SHADOW_OPACITY;
        if (HSM_FRM_SHADOW_OPACITY > 0.0)
        {
            highp vec4 param_121 = frame_shadow_layer;
            highp vec4 param_122 = bezel_layer;
            highp float param_123 = BLEND_MODE_NORMAL;
            highp float param_124 = 0.0;
            highp float param_125 = 0.0;
            highp float param_126 = 0.0;
            highp float param_127 = 1.0;
            highp vec4 _8320 = BlendModeMaskLayerMix(param_121, param_122, param_123, param_124, param_125, param_126, param_127);
            bezel_layer = _8320;
        }
        highp float bezel_opacity_mult = HSM_BZL_OPACITY + (OUTSIDE_BEZEL_MASK * (1.0 - HSM_BZL_OPACITY));
        highp float frame_opacity_mult = HSM_FRM_OPACITY + ((1.0 - OUTSIDE_BEZEL_MASK) * (1.0 - HSM_FRM_OPACITY));
        bezel_layer *= (bezel_opacity_mult * frame_opacity_mult);
    }
    highp vec2 param_128 = ((tube_curved_coord - vec2(0.5)) * 0.9969999790191650390625) + vec2(0.5);
    highp float param_129 = TUBE_DIFFUSE_ASPECT;
    highp float param_130 = bezel_corner_radius;
    highp float param_131 = 0.9900000095367431640625;
    highp float TUBE_MASK_EXPAND = HSM_GetCornerMask(param_128, param_129, param_130, param_131);
    highp vec4 tube_bg_layer = vec4(0.0);
    bool _8359 = SCREEN_ASPECT < 1.0;
    bool _8368;
    if (_8359)
    {
        _8368 = textureSize(BackgroundVertImage, 0).y > 16;
    }
    else
    {
        _8368 = _8359;
    }
    bool bg_use_vert_image = _8368 ? true : false;
    ivec2 _8373;
    if (bg_use_vert_image)
    {
        _8373 = textureSize(BackgroundVertImage, 0);
    }
    else
    {
        _8373 = textureSize(BackgroundImage, 0);
    }
    highp vec2 bg_size = vec2(_8373);
    highp vec2 param_132 = VIEWPORT_COORD;
    highp vec2 param_133 = VIEWPORT_UNSCALED_COORD;
    highp float param_134 = 1.0;
    highp float param_135 = bg_size.x / bg_size.y;
    highp vec2 param_136 = vec2(HSM_BG_POS_X, HSM_BG_POS_Y);
    highp vec2 param_137 = vec2(HSM_BG_SCALE * HSM_BG_SCALE_X, HSM_BG_SCALE);
    highp float param_138 = HSM_BG_FOLLOW_LAYER;
    highp float param_139 = HSM_BG_FOLLOW_MODE;
    highp float param_140 = HSM_BG_FOLLOW_FULL_USES_ZOOM;
    highp float param_141 = HSM_BG_FILL_MODE;
    highp float param_142 = HSM_BG_SPLIT_PRESERVE_CENTER;
    highp float param_143 = HSM_BG_SPLIT_REPEAT_WIDTH;
    bool param_144 = true;
    highp vec2 param_145 = BACKGROUND_COORD;
    highp vec2 param_146 = BACKGROUND_SCALE;
    highp vec2 _8424 = HSM_GetScaledCoord(param_132, param_133, param_134, param_135, param_136, param_137, param_138, param_139, param_140, param_141, param_142, param_143, param_144, param_145, param_146);
    BACKGROUND_COORD = param_145;
    BACKGROUND_SCALE = param_146;
    BACKGROUND_CURVED_COORD = _8424;
    if (HSM_BG_WRAP_MODE == 1.0)
    {
        BACKGROUND_CURVED_COORD = mod(BACKGROUND_CURVED_COORD, vec2(1.0));
    }
    if (HSM_BG_WRAP_MODE == 2.0)
    {
        highp vec2 param_147 = BACKGROUND_CURVED_COORD;
        BACKGROUND_CURVED_COORD = HSM_GetMirrorWrapCoord(param_147);
    }
    highp vec4 bg_image = vec4(0.0);
    bool _8443 = HSM_BG_OPACITY > 0.0;
    bool _8450;
    if (_8443)
    {
        _8450 = bg_size.y > 16.0;
    }
    else
    {
        _8450 = _8443;
    }
    if (_8450)
    {
        if (bg_use_vert_image)
        {
            highp vec2 param_148 = BACKGROUND_CURVED_COORD;
            highp vec2 param_149 = BACKGROUND_SCALE;
            highp float param_150 = HSM_BG_MIPMAPPING_BLEND_BIAS;
            bg_image = HSM_GetMipmappedTexSample(BackgroundVertImage, param_148, param_149, param_150);
        }
        else
        {
            highp vec2 param_151 = BACKGROUND_CURVED_COORD;
            highp vec2 param_152 = BACKGROUND_SCALE;
            highp float param_153 = HSM_BG_MIPMAPPING_BLEND_BIAS;
            bg_image = HSM_GetMipmappedTexSample(BackgroundImage, param_151, param_152, param_153);
        }
        highp vec4 param_154 = bg_image;
        highp float param_155 = HSM_BG_SOURCE_MATTE_TYPE;
        highp float param_156 = 2.2000000476837158203125;
        bg_image = HSM_GetPreMultipliedColorLinear(param_154, param_155, param_156);
        highp vec3 param_157 = bg_image.xyz;
        highp float param_158 = HSM_BG_HUE;
        highp float param_159 = HSM_BG_SATURATION;
        highp float param_160 = HSM_BG_BRIGHTNESS;
        highp float param_161 = HSM_BG_COLORIZE_ON;
        highp float param_162 = HSM_BG_GAMMA;
        highp vec3 _8490 = HSM_ApplyHSVAdjustment(param_157, param_158, param_159, param_160, param_161, param_162);
        bg_image.x = _8490.x;
        bg_image.y = _8490.y;
        bg_image.z = _8490.z;
        if (HSM_STATIC_LAYERS_GAMMA != 1.0)
        {
            highp vec4 param_163 = bg_image;
            highp float param_164 = HSM_STATIC_LAYERS_GAMMA;
            bg_image = HSM_ApplyGamma(param_163, param_164);
        }
        highp vec3 param_165 = bg_image.xyz;
        highp vec3 param_166 = ambient_image.xyz;
        highp vec3 param_167 = ambient2_image.xyz;
        highp float param_168 = HSM_BG_AMBIENT_LIGHTING_MULTIPLIER;
        highp float param_169 = HSM_BG_AMBIENT2_LIGHTING_MULTIPLIER;
        highp float param_170 = HSM_BG_APPLY_AMBIENT_IN_ADD_MODE;
        highp float param_171 = HSM_BG_BLEND_MODE;
        highp float param_172 = HSM_AMBIENT_LIGHTING_SWAP_IMAGE_MODE;
        highp vec3 _8525 = ApplyAmbientImages(param_165, param_166, param_167, param_168, param_169, param_170, param_171, param_172);
        bg_image.x = _8525.x;
        bg_image.y = _8525.y;
        bg_image.z = _8525.z;
    }
    bool _8534 = SCREEN_ASPECT < 1.0;
    bool _8543;
    if (_8534)
    {
        _8543 = textureSize(DeviceVertImage, 0).y > 16;
    }
    else
    {
        _8543 = _8534;
    }
    bool device_use_vert_image = _8543 ? true : false;
    ivec2 _8547;
    if (device_use_vert_image)
    {
        _8547 = textureSize(DeviceVertImage, 0);
    }
    else
    {
        _8547 = textureSize(DeviceImage, 0);
    }
    highp vec2 device_size = vec2(_8547);
    highp vec2 param_173 = VIEWPORT_COORD;
    highp vec2 param_174 = VIEWPORT_UNSCALED_COORD;
    highp float param_175 = 1.0;
    highp float param_176 = device_size.x / device_size.y;
    highp vec2 param_177 = vec2(HSM_DEVICE_POS_X, HSM_DEVICE_POS_Y);
    highp vec2 param_178 = vec2(HSM_DEVICE_SCALE * HSM_DEVICE_SCALE_X, HSM_DEVICE_SCALE);
    highp float param_179 = HSM_DEVICE_FOLLOW_LAYER;
    highp float param_180 = HSM_DEVICE_FOLLOW_MODE;
    highp float param_181 = HSM_DEVICE_FOLLOW_FULL_USES_ZOOM;
    highp float param_182 = HSM_DEVICE_FILL_MODE;
    highp float param_183 = HSM_DEVICE_SPLIT_PRESERVE_CENTER;
    highp float param_184 = HSM_DEVICE_SPLIT_REPEAT_WIDTH;
    bool param_185 = true;
    highp vec2 param_186 = DEVICE_COORD;
    highp vec2 param_187 = DEVICE_SCALE;
    highp vec2 _8598 = HSM_GetScaledCoord(param_173, param_174, param_175, param_176, param_177, param_178, param_179, param_180, param_181, param_182, param_183, param_184, param_185, param_186, param_187);
    DEVICE_COORD = param_186;
    DEVICE_SCALE = param_187;
    DEVICE_CURVED_COORD = _8598;
    highp vec4 device_image = vec4(0.0);
    bool _8603 = HSM_DEVICE_OPACITY > 0.0;
    bool _8609;
    if (_8603)
    {
        _8609 = device_size.y > 16.0;
    }
    else
    {
        _8609 = _8603;
    }
    if (_8609)
    {
        highp vec4 _8613;
        if (device_use_vert_image)
        {
            highp vec2 param_188 = DEVICE_CURVED_COORD;
            highp vec2 param_189 = DEVICE_SCALE;
            highp float param_190 = HSM_DEVICE_MIPMAPPING_BLEND_BIAS;
            _8613 = HSM_GetMipmappedTexSample(DeviceVertImage, param_188, param_189, param_190);
        }
        else
        {
            highp vec2 param_191 = DEVICE_CURVED_COORD;
            highp vec2 param_192 = DEVICE_SCALE;
            highp float param_193 = HSM_DEVICE_MIPMAPPING_BLEND_BIAS;
            _8613 = HSM_GetMipmappedTexSample(DeviceImage, param_191, param_192, param_193);
        }
        device_image = _8613;
        highp vec4 param_194 = device_image;
        highp float param_195 = HSM_DEVICE_SOURCE_MATTE_TYPE;
        highp float param_196 = 2.2000000476837158203125;
        device_image = HSM_GetPreMultipliedColorLinear(param_194, param_195, param_196);
        highp vec3 param_197 = device_image.xyz;
        highp float param_198 = HSM_DEVICE_HUE;
        highp float param_199 = HSM_DEVICE_SATURATION;
        highp float param_200 = HSM_DEVICE_BRIGHTNESS;
        highp float param_201 = HSM_DEVICE_COLORIZE_ON;
        highp float param_202 = HSM_DEVICE_GAMMA;
        highp vec3 _8651 = HSM_ApplyHSVAdjustment(param_197, param_198, param_199, param_200, param_201, param_202);
        device_image.x = _8651.x;
        device_image.y = _8651.y;
        device_image.z = _8651.z;
        if (HSM_STATIC_LAYERS_GAMMA != 1.0)
        {
            highp vec4 param_203 = device_image;
            highp float param_204 = HSM_STATIC_LAYERS_GAMMA;
            device_image = HSM_ApplyGamma(param_203, param_204);
        }
        highp vec3 param_205 = device_image.xyz;
        highp vec3 param_206 = ambient_image.xyz;
        highp vec3 param_207 = ambient2_image.xyz;
        highp float param_208 = HSM_DEVICE_AMBIENT_LIGHTING_MULTIPLIER;
        highp float param_209 = HSM_DEVICE_AMBIENT2_LIGHTING_MULTIPLIER;
        highp float param_210 = HSM_DEVICE_APPLY_AMBIENT_IN_ADD_MODE;
        highp float param_211 = HSM_DEVICE_BLEND_MODE;
        highp float param_212 = HSM_AMBIENT_LIGHTING_SWAP_IMAGE_MODE;
        highp vec3 _8686 = ApplyAmbientImages(param_205, param_206, param_207, param_208, param_209, param_210, param_211, param_212);
        device_image.x = _8686.x;
        device_image.y = _8686.y;
        device_image.z = _8686.z;
    }
    highp vec2 deviceled_size = vec2(textureSize(DeviceLEDImage, 0));
    highp vec2 param_213 = VIEWPORT_COORD;
    highp vec2 param_214 = VIEWPORT_UNSCALED_COORD;
    highp float param_215 = 1.0;
    highp float param_216 = deviceled_size.x / deviceled_size.y;
    highp vec2 param_217 = vec2(HSM_DEVICELED_POS_X, HSM_DEVICELED_POS_Y);
    highp vec2 param_218 = vec2(HSM_DEVICELED_SCALE * HSM_DEVICELED_SCALE_X, HSM_DEVICELED_SCALE);
    highp float param_219 = HSM_DEVICELED_FOLLOW_LAYER;
    highp float param_220 = HSM_DEVICELED_FOLLOW_MODE;
    highp float param_221 = HSM_DEVICELED_FOLLOW_FULL_USES_ZOOM;
    highp float param_222 = HSM_DEVICELED_FILL_MODE;
    highp float param_223 = HSM_DEVICELED_SPLIT_PRESERVE_CENTER;
    highp float param_224 = HSM_DEVICELED_SPLIT_REPEAT_WIDTH;
    bool param_225 = true;
    highp vec2 param_226 = DEVICELED_COORD;
    highp vec2 param_227 = DEVICELED_SCALE;
    highp vec2 _8737 = HSM_GetScaledCoord(param_213, param_214, param_215, param_216, param_217, param_218, param_219, param_220, param_221, param_222, param_223, param_224, param_225, param_226, param_227);
    DEVICELED_COORD = param_226;
    DEVICELED_SCALE = param_227;
    DEVICELED_CURVED_COORD = _8737;
    highp vec4 deviceled_image = vec4(0.0);
    bool _8742 = HSM_DEVICELED_OPACITY > 0.0;
    bool _8748;
    if (_8742)
    {
        _8748 = deviceled_size.y > 16.0;
    }
    else
    {
        _8748 = _8742;
    }
    if (_8748)
    {
        highp vec2 param_228 = DEVICELED_CURVED_COORD;
        highp vec2 param_229 = DEVICELED_SCALE;
        highp float param_230 = HSM_DEVICELED_MIPMAPPING_BLEND_BIAS;
        deviceled_image = HSM_GetMipmappedTexSample(DeviceLEDImage, param_228, param_229, param_230);
        highp vec4 param_231 = deviceled_image;
        highp float param_232 = HSM_DEVICELED_SOURCE_MATTE_TYPE;
        highp float param_233 = 2.2000000476837158203125;
        deviceled_image = HSM_GetPreMultipliedColorLinear(param_231, param_232, param_233);
        highp vec3 param_234 = deviceled_image.xyz;
        highp float param_235 = HSM_DEVICELED_HUE;
        highp float param_236 = HSM_DEVICELED_SATURATION;
        highp float param_237 = HSM_DEVICELED_BRIGHTNESS;
        highp float param_238 = HSM_DEVICELED_COLORIZE_ON;
        highp float param_239 = HSM_DEVICELED_GAMMA;
        highp vec3 _8777 = HSM_ApplyHSVAdjustment(param_234, param_235, param_236, param_237, param_238, param_239);
        deviceled_image.x = _8777.x;
        deviceled_image.y = _8777.y;
        deviceled_image.z = _8777.z;
        if (HSM_STATIC_LAYERS_GAMMA != 1.0)
        {
            highp vec4 param_240 = deviceled_image;
            highp float param_241 = HSM_STATIC_LAYERS_GAMMA;
            deviceled_image = HSM_ApplyGamma(param_240, param_241);
        }
        highp vec3 param_242 = deviceled_image.xyz;
        highp vec3 param_243 = ambient_image.xyz;
        highp vec3 param_244 = ambient2_image.xyz;
        highp float param_245 = HSM_DEVICELED_AMBIENT_LIGHTING_MULTIPLIER;
        highp float param_246 = HSM_DEVICELED_AMBIENT2_LIGHTING_MULTIPLIER;
        highp float param_247 = HSM_DEVICELED_APPLY_AMBIENT_IN_ADD_MODE;
        highp float param_248 = HSM_DEVICELED_BLEND_MODE;
        highp float param_249 = HSM_AMBIENT_LIGHTING_SWAP_IMAGE_MODE;
        highp vec3 _8812 = ApplyAmbientImages(param_242, param_243, param_244, param_245, param_246, param_247, param_248, param_249);
        deviceled_image.x = _8812.x;
        deviceled_image.y = _8812.y;
        deviceled_image.z = _8812.z;
    }
    highp vec4 led_image = vec4(0.0);
    if (HSM_LED_OPACITY > 0.0)
    {
        highp vec2 led_size = vec2(textureSize(LEDImage, 0));
        highp vec2 param_250 = VIEWPORT_COORD;
        highp vec2 param_251 = VIEWPORT_UNSCALED_COORD;
        highp float param_252 = 1.0;
        highp float param_253 = led_size.x / led_size.y;
        highp vec2 param_254 = vec2(HSM_LED_POS_X, HSM_LED_POS_Y);
        highp vec2 param_255 = vec2(HSM_LED_SCALE * HSM_LED_SCALE_X, HSM_LED_SCALE);
        highp float param_256 = HSM_LED_FOLLOW_LAYER;
        highp float param_257 = HSM_LED_FOLLOW_MODE;
        highp float param_258 = HSM_LED_FOLLOW_FULL_USES_ZOOM;
        highp float param_259 = HSM_LED_FILL_MODE;
        highp float param_260 = HSM_LED_SPLIT_PRESERVE_CENTER;
        highp float param_261 = HSM_LED_SPLIT_REPEAT_WIDTH;
        bool param_262 = true;
        highp vec2 param_263 = LED_COORD;
        highp vec2 param_264 = LED_SCALE;
        highp vec2 _8868 = HSM_GetScaledCoord(param_250, param_251, param_252, param_253, param_254, param_255, param_256, param_257, param_258, param_259, param_260, param_261, param_262, param_263, param_264);
        LED_COORD = param_263;
        LED_SCALE = param_264;
        LED_CURVED_COORD = _8868;
        bool _8872 = HSM_LED_OPACITY > 0.0;
        bool _8878;
        if (_8872)
        {
            _8878 = led_size.y > 16.0;
        }
        else
        {
            _8878 = _8872;
        }
        if (_8878)
        {
            highp vec2 param_265 = LED_CURVED_COORD;
            highp vec2 param_266 = LED_SCALE;
            highp float param_267 = HSM_LED_MIPMAPPING_BLEND_BIAS;
            led_image = HSM_GetMipmappedTexSample(LEDImage, param_265, param_266, param_267);
            highp vec4 param_268 = led_image;
            highp float param_269 = HSM_LED_SOURCE_MATTE_TYPE;
            highp float param_270 = 2.2000000476837158203125;
            led_image = HSM_GetPreMultipliedColorLinear(param_268, param_269, param_270);
            highp vec3 param_271 = led_image.xyz;
            highp float param_272 = HSM_LED_HUE;
            highp float param_273 = HSM_LED_SATURATION;
            highp float param_274 = HSM_LED_BRIGHTNESS;
            highp float param_275 = HSM_LED_COLORIZE_ON;
            highp float param_276 = HSM_LED_GAMMA;
            highp vec3 _8907 = HSM_ApplyHSVAdjustment(param_271, param_272, param_273, param_274, param_275, param_276);
            led_image.x = _8907.x;
            led_image.y = _8907.y;
            led_image.z = _8907.z;
            if (HSM_STATIC_LAYERS_GAMMA != 1.0)
            {
                highp vec4 param_277 = led_image;
                highp float param_278 = HSM_STATIC_LAYERS_GAMMA;
                led_image = HSM_ApplyGamma(param_277, param_278);
            }
            highp vec3 param_279 = led_image.xyz;
            highp vec3 param_280 = ambient_image.xyz;
            highp vec3 param_281 = ambient2_image.xyz;
            highp float param_282 = HSM_LED_AMBIENT_LIGHTING_MULTIPLIER;
            highp float param_283 = HSM_LED_AMBIENT2_LIGHTING_MULTIPLIER;
            highp float param_284 = HSM_LED_APPLY_AMBIENT_IN_ADD_MODE;
            highp float param_285 = HSM_LED_BLEND_MODE;
            highp float param_286 = HSM_AMBIENT_LIGHTING_SWAP_IMAGE_MODE;
            highp vec3 _8942 = ApplyAmbientImages(param_279, param_280, param_281, param_282, param_283, param_284, param_285, param_286);
            led_image.x = _8942.x;
            led_image.y = _8942.y;
            led_image.z = _8942.z;
        }
    }
    highp vec2 decal_size = vec2(textureSize(DecalImage, 0));
    highp vec2 param_287 = VIEWPORT_COORD;
    highp vec2 param_288 = VIEWPORT_UNSCALED_COORD;
    highp float param_289 = 1.0;
    highp float param_290 = decal_size.x / decal_size.y;
    highp vec2 param_291 = vec2(HSM_DECAL_POS_X, HSM_DECAL_POS_Y);
    highp vec2 param_292 = vec2(HSM_DECAL_SCALE * HSM_DECAL_SCALE_X, HSM_DECAL_SCALE);
    highp float param_293 = HSM_DECAL_FOLLOW_LAYER;
    highp float param_294 = HSM_DECAL_FOLLOW_MODE;
    highp float param_295 = HSM_DECAL_FOLLOW_FULL_USES_ZOOM;
    highp float param_296 = HSM_DECAL_FILL_MODE;
    highp float param_297 = HSM_DECAL_SPLIT_PRESERVE_CENTER;
    highp float param_298 = HSM_DECAL_SPLIT_REPEAT_WIDTH;
    bool param_299 = true;
    highp vec2 param_300 = DECAL_COORD;
    highp vec2 param_301 = DECAL_SCALE;
    highp vec2 _8993 = HSM_GetScaledCoord(param_287, param_288, param_289, param_290, param_291, param_292, param_293, param_294, param_295, param_296, param_297, param_298, param_299, param_300, param_301);
    DECAL_COORD = param_300;
    DECAL_SCALE = param_301;
    DECAL_CURVED_COORD = _8993;
    highp vec4 decal_image = vec4(0.0);
    bool _8998 = HSM_DECAL_OPACITY > 0.0;
    bool _9004;
    if (_8998)
    {
        _9004 = decal_size.y > 16.0;
    }
    else
    {
        _9004 = _8998;
    }
    if (_9004)
    {
        highp vec2 param_302 = DECAL_CURVED_COORD;
        highp vec2 param_303 = DECAL_SCALE;
        highp float param_304 = HSM_DECAL_MIPMAPPING_BLEND_BIAS;
        decal_image = HSM_GetMipmappedTexSample(DecalImage, param_302, param_303, param_304);
        highp vec4 param_305 = decal_image;
        highp float param_306 = HSM_DECAL_SOURCE_MATTE_TYPE;
        highp float param_307 = 2.2000000476837158203125;
        decal_image = HSM_GetPreMultipliedColorLinear(param_305, param_306, param_307);
        highp vec3 param_308 = decal_image.xyz;
        highp float param_309 = HSM_DECAL_HUE;
        highp float param_310 = HSM_DECAL_SATURATION;
        highp float param_311 = HSM_DECAL_BRIGHTNESS;
        highp float param_312 = HSM_DECAL_COLORIZE_ON;
        highp float param_313 = HSM_DECAL_GAMMA;
        highp vec3 _9033 = HSM_ApplyHSVAdjustment(param_308, param_309, param_310, param_311, param_312, param_313);
        decal_image.x = _9033.x;
        decal_image.y = _9033.y;
        decal_image.z = _9033.z;
        if (HSM_STATIC_LAYERS_GAMMA != 1.0)
        {
            highp vec4 param_314 = decal_image;
            highp float param_315 = HSM_STATIC_LAYERS_GAMMA;
            decal_image = HSM_ApplyGamma(param_314, param_315);
        }
        highp vec3 param_316 = decal_image.xyz;
        highp vec3 param_317 = ambient_image.xyz;
        highp vec3 param_318 = ambient2_image.xyz;
        highp float param_319 = HSM_DECAL_AMBIENT_LIGHTING_MULTIPLIER;
        highp float param_320 = HSM_DECAL_AMBIENT2_LIGHTING_MULTIPLIER;
        highp float param_321 = HSM_DECAL_APPLY_AMBIENT_IN_ADD_MODE;
        highp float param_322 = HSM_DECAL_BLEND_MODE;
        highp float param_323 = HSM_AMBIENT_LIGHTING_SWAP_IMAGE_MODE;
        highp vec3 _9068 = ApplyAmbientImages(param_316, param_317, param_318, param_319, param_320, param_321, param_322, param_323);
        decal_image.x = _9068.x;
        decal_image.y = _9068.y;
        decal_image.z = _9068.z;
    }
    highp vec2 top_size = vec2(textureSize(TopLayerImage, 0));
    highp vec2 param_324 = VIEWPORT_COORD;
    highp vec2 param_325 = VIEWPORT_UNSCALED_COORD;
    highp float param_326 = 1.0;
    highp float param_327 = top_size.x / top_size.y;
    highp vec2 param_328 = vec2(HSM_TOP_POS_X, HSM_TOP_POS_Y);
    highp vec2 param_329 = vec2(HSM_TOP_SCALE * HSM_TOP_SCALE_X, HSM_TOP_SCALE);
    highp float param_330 = HSM_TOP_FOLLOW_LAYER;
    highp float param_331 = HSM_TOP_FOLLOW_MODE;
    highp float param_332 = HSM_TOP_FOLLOW_FULL_USES_ZOOM;
    highp float param_333 = HSM_TOP_FILL_MODE;
    highp float param_334 = HSM_TOP_SPLIT_PRESERVE_CENTER;
    highp float param_335 = HSM_TOP_SPLIT_REPEAT_WIDTH;
    bool param_336 = true;
    highp vec2 param_337 = TOP_IMAGE_COORD;
    highp vec2 param_338 = TOP_IMAGE_SCALE;
    highp vec2 _9119 = HSM_GetScaledCoord(param_324, param_325, param_326, param_327, param_328, param_329, param_330, param_331, param_332, param_333, param_334, param_335, param_336, param_337, param_338);
    TOP_IMAGE_COORD = param_337;
    TOP_IMAGE_SCALE = param_338;
    TOP_IMAGE_CURVED_COORD = _9119;
    if (HSM_TOP_MIRROR_WRAP == 1.0)
    {
        highp vec2 param_339 = TOP_IMAGE_CURVED_COORD;
        TOP_IMAGE_CURVED_COORD = HSM_GetMirrorWrapCoord(param_339);
    }
    highp vec4 top_image = vec4(0.0);
    bool _9131 = HSM_TOP_OPACITY > 0.0;
    bool _9137;
    if (_9131)
    {
        _9137 = top_size.y > 16.0;
    }
    else
    {
        _9137 = _9131;
    }
    if (_9137)
    {
        highp vec2 param_340 = TOP_IMAGE_CURVED_COORD;
        highp vec2 param_341 = TOP_IMAGE_SCALE;
        highp float param_342 = HSM_TOP_MIPMAPPING_BLEND_BIAS;
        top_image = HSM_GetMipmappedTexSample(TopLayerImage, param_340, param_341, param_342);
        highp vec4 param_343 = top_image;
        highp float param_344 = HSM_TOP_SOURCE_MATTE_TYPE;
        highp float param_345 = 2.2000000476837158203125;
        top_image = HSM_GetPreMultipliedColorLinear(param_343, param_344, param_345);
        highp vec3 param_346 = top_image.xyz;
        highp float param_347 = HSM_TOP_HUE;
        highp float param_348 = HSM_TOP_SATURATION;
        highp float param_349 = HSM_TOP_BRIGHTNESS;
        highp float param_350 = HSM_TOP_COLORIZE_ON;
        highp float param_351 = HSM_TOP_GAMMA;
        highp vec3 _9166 = HSM_ApplyHSVAdjustment(param_346, param_347, param_348, param_349, param_350, param_351);
        top_image.x = _9166.x;
        top_image.y = _9166.y;
        top_image.z = _9166.z;
        if (HSM_STATIC_LAYERS_GAMMA != 1.0)
        {
            highp vec4 param_352 = top_image;
            highp float param_353 = HSM_STATIC_LAYERS_GAMMA;
            top_image = HSM_ApplyGamma(param_352, param_353);
        }
        highp vec3 param_354 = top_image.xyz;
        highp vec3 param_355 = ambient_image.xyz;
        highp vec3 param_356 = ambient2_image.xyz;
        highp float param_357 = HSM_TOP_AMBIENT_LIGHTING_MULTIPLIER;
        highp float param_358 = HSM_TOP_AMBIENT2_LIGHTING_MULTIPLIER;
        highp float param_359 = HSM_TOP_APPLY_AMBIENT_IN_ADD_MODE;
        highp float param_360 = HSM_TOP_BLEND_MODE;
        highp float param_361 = HSM_AMBIENT_LIGHTING_SWAP_IMAGE_MODE;
        highp vec3 _9201 = ApplyAmbientImages(param_354, param_355, param_356, param_357, param_358, param_359, param_360, param_361);
        top_image.x = _9201.x;
        top_image.y = _9201.y;
        top_image.z = _9201.z;
    }
    highp vec4 cab_glass_image = vec4(0.0);
    if (HSM_CAB_GLASS_OPACITY > 0.0)
    {
        highp vec2 cab_glass_size = vec2(textureSize(CabinetGlassImage, 0));
        highp vec2 param_362 = VIEWPORT_COORD;
        highp vec2 param_363 = VIEWPORT_UNSCALED_COORD;
        highp float param_364 = 1.0;
        highp float param_365 = cab_glass_size.x / cab_glass_size.y;
        highp vec2 param_366 = vec2(HSM_CAB_GLASS_POS_X, HSM_CAB_GLASS_POS_Y);
        highp vec2 param_367 = vec2(HSM_CAB_GLASS_SCALE * HSM_CAB_GLASS_SCALE_X, HSM_CAB_GLASS_SCALE);
        highp float param_368 = HSM_CAB_GLASS_FOLLOW_LAYER;
        highp float param_369 = HSM_CAB_GLASS_FOLLOW_MODE;
        highp float param_370 = HSM_CAB_GLASS_FOLLOW_FULL_USES_ZOOM;
        highp float param_371 = HSM_CAB_GLASS_FILL_MODE;
        highp float param_372 = HSM_CAB_GLASS_SPLIT_PRESERVE_CENTER;
        highp float param_373 = HSM_CAB_GLASS_SPLIT_REPEAT_WIDTH;
        bool param_374 = true;
        highp vec2 param_375 = CAB_GLASS_COORD;
        highp vec2 param_376 = CAB_GLASS_SCALE;
        highp vec2 _9257 = HSM_GetScaledCoord(param_362, param_363, param_364, param_365, param_366, param_367, param_368, param_369, param_370, param_371, param_372, param_373, param_374, param_375, param_376);
        CAB_GLASS_COORD = param_375;
        CAB_GLASS_SCALE = param_376;
        CAB_GLASS_CURVED_COORD = _9257;
        bool _9261 = HSM_CAB_GLASS_OPACITY > 0.0;
        bool _9267;
        if (_9261)
        {
            _9267 = cab_glass_size.y > 16.0;
        }
        else
        {
            _9267 = _9261;
        }
        if (_9267)
        {
            highp vec2 param_377 = CAB_GLASS_CURVED_COORD;
            highp vec2 param_378 = CAB_GLASS_SCALE;
            highp float param_379 = HSM_CAB_GLASS_MIPMAPPING_BLEND_BIAS;
            cab_glass_image = HSM_GetMipmappedTexSample(CabinetGlassImage, param_377, param_378, param_379);
            highp vec4 param_380 = cab_glass_image;
            highp float param_381 = HSM_CAB_GLASS_SOURCE_MATTE_TYPE;
            highp float param_382 = 2.2000000476837158203125;
            cab_glass_image = HSM_GetPreMultipliedColorLinear(param_380, param_381, param_382);
            highp vec3 param_383 = cab_glass_image.xyz;
            highp float param_384 = HSM_CAB_GLASS_HUE;
            highp float param_385 = HSM_CAB_GLASS_SATURATION;
            highp float param_386 = HSM_CAB_GLASS_BRIGHTNESS;
            highp float param_387 = HSM_CAB_GLASS_COLORIZE_ON;
            highp float param_388 = HSM_CAB_GLASS_GAMMA;
            highp vec3 _9296 = HSM_ApplyHSVAdjustment(param_383, param_384, param_385, param_386, param_387, param_388);
            cab_glass_image.x = _9296.x;
            cab_glass_image.y = _9296.y;
            cab_glass_image.z = _9296.z;
            if (HSM_STATIC_LAYERS_GAMMA != 1.0)
            {
                highp vec4 param_389 = cab_glass_image;
                highp float param_390 = HSM_STATIC_LAYERS_GAMMA;
                cab_glass_image = HSM_ApplyGamma(param_389, param_390);
            }
            highp vec3 param_391 = cab_glass_image.xyz;
            highp vec3 param_392 = ambient_image.xyz;
            highp vec3 param_393 = ambient2_image.xyz;
            highp float param_394 = HSM_CAB_GLASS_AMBIENT_LIGHTING_MULTIPLIER;
            highp float param_395 = HSM_CAB_GLASS_AMBIENT2_LIGHTING_MULTIPLIER;
            highp float param_396 = HSM_CAB_GLASS_APPLY_AMBIENT_IN_ADD_MODE;
            highp float param_397 = HSM_CAB_GLASS_BLEND_MODE;
            highp float param_398 = HSM_AMBIENT_LIGHTING_SWAP_IMAGE_MODE;
            highp vec3 _9331 = ApplyAmbientImages(param_391, param_392, param_393, param_394, param_395, param_396, param_397, param_398);
            cab_glass_image.x = _9331.x;
            cab_glass_image.y = _9331.y;
            cab_glass_image.z = _9331.z;
        }
    }
    CUTOUT_MASK = 1.0;
    highp vec2 temp_scale = vec2(0.5);
    highp vec2 temp_coord = vec2(0.5);
    highp vec2 cutout_base_scale_offset = vec2(0.5);
    if (HSM_CUTOUT_FOLLOW_LAYER == 0.0)
    {
        cutout_base_scale_offset *= vec2((0.9110000133514404296875 * TUBE_DIFFUSE_ASPECT) / output_aspect, DEFAULT_BEZEL_SCALE.y);
    }
    highp vec2 param_399 = VIEWPORT_COORD;
    highp vec2 param_400 = VIEWPORT_UNSCALED_COORD;
    highp float param_401 = HSM_CUTOUT_ASPECT_MODE;
    highp float param_402 = HSM_CUTOUT_EXPLICIT_ASPECT;
    highp vec2 param_403 = vec2(HSM_CUTOUT_POS_X, HSM_CUTOUT_POS_Y);
    highp vec2 param_404 = vec2(vec2(HSM_CUTOUT_SCALE * HSM_CUTOUT_SCALE_X, HSM_CUTOUT_SCALE) * cutout_base_scale_offset);
    highp float param_405 = HSM_CUTOUT_FOLLOW_LAYER;
    highp float param_406 = FOLLOW_MODE_SCALE_AND_POS;
    highp float param_407 = HSM_CUTOUT_FOLLOW_FULL_USES_ZOOM;
    highp float param_408 = FILL_MODE_STRETCH;
    highp float param_409 = 0.0;
    highp float param_410 = 0.0;
    bool param_411 = false;
    highp vec2 param_412 = temp_coord;
    highp vec2 param_413 = temp_scale;
    highp vec2 _9393 = HSM_GetScaledCoord(param_399, param_400, param_401, param_402, param_403, param_404, param_405, param_406, param_407, param_408, param_409, param_410, param_411, param_412, param_413);
    temp_coord = param_412;
    temp_scale = param_413;
    highp vec2 cutout_coord = _9393;
    highp vec2 param_414 = cutout_coord;
    highp float param_415 = TUBE_DIFFUSE_ASPECT;
    highp float param_416 = HSM_CUTOUT_CORNER_RADIUS;
    highp float param_417 = 0.800000011920928955078125;
    CUTOUT_MASK = 1.0 - HSM_GetCornerMask(param_414, param_415, param_416, param_417);
    highp vec4 vignette_layer = vec4(0.0);
    if (HSM_VIEWPORT_VIGNETTE_OPACITY > 0.0)
    {
        highp vec2 param_418 = VIEWPORT_COORD;
        highp vec2 param_419 = VIEWPORT_UNSCALED_COORD;
        highp float param_420 = 0.0;
        highp float param_421 = 1.0;
        highp vec2 param_422 = vec2(HSM_VIEWPORT_VIGNETTE_POS_X, HSM_VIEWPORT_VIGNETTE_POS_Y);
        highp vec2 param_423 = vec2(vec2(HSM_VIEWPORT_VIGNETTE_SCALE * HSM_VIEWPORT_VIGNETTE_SCALE_X, HSM_VIEWPORT_VIGNETTE_SCALE));
        highp float param_424 = HSM_VIEWPORT_VIGNETTE_FOLLOW_LAYER;
        highp float param_425 = FOLLOW_MODE_SCALE_AND_POS;
        highp float param_426 = 0.0;
        highp float param_427 = FILL_MODE_STRETCH;
        highp float param_428 = 0.0;
        highp float param_429 = 0.0;
        bool param_430 = false;
        highp vec2 param_431 = temp_coord;
        highp vec2 param_432 = temp_scale;
        highp vec2 _9444 = HSM_GetScaledCoord(param_418, param_419, param_420, param_421, param_422, param_423, param_424, param_425, param_426, param_427, param_428, param_429, param_430, param_431, param_432);
        temp_coord = param_431;
        temp_scale = param_432;
        highp vec2 vignette_coord = _9444;
        highp vec2 param_433 = vignette_coord;
        highp float param_434 = HSM_VIEWPORT_VIGNETTE_OPACITY;
        highp float param_435 = 1.0;
        highp float param_436 = 1.0 - HSM_GetVignetteFactor(param_433, param_434, param_435);
        highp vec2 param_437 = vec2(1.0, 0.5);
        highp float _9456 = HHLP_QuadraticBezier(param_436, param_437);
        vignette_layer.w += (0.75 * _9456);
    }
    highp vec4 frag_color_linear = vec4(0.0);
    int start_layer = 0;
    int end_layer = int(MAX_LAYER_ORDER);
    start_layer = 0;
    end_layer = int(HSM_CRT_LAYER_ORDER - 1.0);
    highp vec2 param_438 = (tube_curved_coord_ctr * 1.0030000209808349609375) + vec2(0.5);
    highp float param_439 = TUBE_DIFFUSE_ASPECT;
    highp float param_440 = HSM_FRM_OUTER_CORNER_RADIUS;
    highp float param_441 = 1.0;
    OUTSIDE_TUBE_MASK_FOR_IMAGE = 1.0 - HSM_GetCornerMask(param_438, param_439, param_440, param_441);
    for (int i = start_layer; i <= end_layer; i++)
    {
        if (HSM_BG_LAYER_ORDER == float(i))
        {
            highp vec4 param_442 = frag_color_linear;
            highp vec4 param_443 = bg_image;
            highp float param_444 = HSM_BG_BLEND_MODE;
            highp float param_445 = HSM_BG_MASK_MODE;
            highp float param_446 = HSM_BG_CUTOUT_MODE;
            highp float param_447 = HSM_BG_DUALSCREEN_VIS_MODE;
            highp float param_448 = HSM_BG_OPACITY;
            highp vec4 _9513 = BlendModeMaskLayerMix(param_442, param_443, param_444, param_445, param_446, param_447, param_448);
            frag_color_linear = _9513;
        }
        if (HSM_VIEWPORT_VIGNETTE_LAYER_ORDER == float(i))
        {
            highp vec4 param_449 = frag_color_linear;
            highp vec4 param_450 = vignette_layer;
            highp float param_451 = BLEND_MODE_NORMAL;
            highp float param_452 = HSM_VIEWPORT_VIGNETTE_MASK_MODE;
            highp float param_453 = HSM_VIEWPORT_VIGNETTE_CUTOUT_MODE;
            highp float param_454 = 0.0;
            highp float param_455 = HSM_VIEWPORT_VIGNETTE_OPACITY;
            highp vec4 _9533 = BlendModeMaskLayerMix(param_449, param_450, param_451, param_452, param_453, param_454, param_455);
            frag_color_linear = _9533;
        }
        if ((HSM_LED_LAYER_ORDER == float(i)) && (HSM_LED_OPACITY > 0.0))
        {
            highp vec4 param_456 = frag_color_linear;
            highp vec4 param_457 = led_image;
            highp float param_458 = HSM_LED_BLEND_MODE;
            highp float param_459 = HSM_LED_MASK_MODE;
            highp float param_460 = HSM_LED_CUTOUT_MODE;
            highp float param_461 = HSM_LED_DUALSCREEN_VIS_MODE;
            highp float param_462 = HSM_LED_OPACITY;
            highp vec4 _9557 = BlendModeMaskLayerMix(param_456, param_457, param_458, param_459, param_460, param_461, param_462);
            frag_color_linear = _9557;
        }
        if ((HSM_DEVICE_LAYER_ORDER == float(i)) && (HSM_DEVICE_OPACITY > 0.0))
        {
            highp vec4 param_463 = frag_color_linear;
            highp vec4 param_464 = device_image;
            highp float param_465 = HSM_DEVICE_BLEND_MODE;
            highp float param_466 = HSM_DEVICE_MASK_MODE;
            highp float param_467 = HSM_DEVICE_CUTOUT_MODE;
            highp float param_468 = HSM_DEVICE_DUALSCREEN_VIS_MODE;
            highp float param_469 = HSM_DEVICE_OPACITY;
            highp vec4 _9581 = BlendModeMaskLayerMix(param_463, param_464, param_465, param_466, param_467, param_468, param_469);
            frag_color_linear = _9581;
        }
        if ((HSM_DEVICELED_LAYER_ORDER == float(i)) && (HSM_DEVICELED_OPACITY > 0.0))
        {
            highp vec4 param_470 = frag_color_linear;
            highp vec4 param_471 = deviceled_image;
            highp float param_472 = HSM_DEVICELED_BLEND_MODE;
            highp float param_473 = HSM_DEVICELED_MASK_MODE;
            highp float param_474 = HSM_DEVICELED_CUTOUT_MODE;
            highp float param_475 = HSM_DEVICELED_DUALSCREEN_VIS_MODE;
            highp float param_476 = HSM_DEVICELED_OPACITY;
            highp vec4 _9605 = BlendModeMaskLayerMix(param_470, param_471, param_472, param_473, param_474, param_475, param_476);
            frag_color_linear = _9605;
        }
        if ((HSM_DECAL_LAYER_ORDER == float(i)) && (HSM_DECAL_OPACITY > 0.0))
        {
            highp vec4 param_477 = frag_color_linear;
            highp vec4 param_478 = decal_image;
            highp float param_479 = HSM_DECAL_BLEND_MODE;
            highp float param_480 = HSM_DECAL_MASK_MODE;
            highp float param_481 = HSM_DECAL_CUTOUT_MODE;
            highp float param_482 = HSM_DECAL_DUALSCREEN_VIS_MODE;
            highp float param_483 = HSM_DECAL_OPACITY;
            highp vec4 _9629 = BlendModeMaskLayerMix(param_477, param_478, param_479, param_480, param_481, param_482, param_483);
            frag_color_linear = _9629;
        }
        if ((HSM_CAB_GLASS_LAYER_ORDER == float(i)) && (HSM_CAB_GLASS_OPACITY > 0.0))
        {
            highp vec4 param_484 = frag_color_linear;
            highp vec4 param_485 = cab_glass_image;
            highp float param_486 = HSM_CAB_GLASS_BLEND_MODE;
            highp float param_487 = HSM_CAB_GLASS_MASK_MODE;
            highp float param_488 = HSM_CAB_GLASS_CUTOUT_MODE;
            highp float param_489 = HSM_CAB_GLASS_DUALSCREEN_VIS_MODE;
            highp float param_490 = HSM_CAB_GLASS_OPACITY;
            highp vec4 _9653 = BlendModeMaskLayerMix(param_484, param_485, param_486, param_487, param_488, param_489, param_490);
            frag_color_linear = _9653;
        }
        if ((HSM_TOP_LAYER_ORDER == float(i)) && (HSM_TOP_OPACITY > 0.0))
        {
            highp vec4 param_491 = frag_color_linear;
            highp vec4 param_492 = top_image;
            highp float param_493 = HSM_TOP_BLEND_MODE;
            highp float param_494 = HSM_TOP_MASK_MODE;
            highp float param_495 = HSM_TOP_CUTOUT_MODE;
            highp float param_496 = HSM_TOP_DUALSCREEN_VIS_MODE;
            highp float param_497 = HSM_TOP_OPACITY;
            highp vec4 _9677 = BlendModeMaskLayerMix(param_491, param_492, param_493, param_494, param_495, param_496, param_497);
            frag_color_linear = _9677;
        }
    }
    highp vec4 param_498 = frag_color_linear;
    highp vec4 param_499 = tube_bg_layer;
    frag_color_linear = HSM_PreMultAlphaBlend(param_498, param_499);
    if ((HSM_BZL_OPACITY > 0.0) || (HSM_FRM_OPACITY > 0.0))
    {
        highp vec4 param_500 = frag_color_linear;
        highp vec4 param_501 = bezel_layer;
        highp float param_502 = HSM_BZL_BLEND_MODE;
        highp float param_503 = 0.0;
        highp float param_504 = 0.0;
        highp float param_505 = 0.0;
        highp float param_506 = 1.0;
        highp vec4 _9702 = BlendModeMaskLayerMix(param_500, param_501, param_502, param_503, param_504, param_505, param_506);
        frag_color_linear = _9702;
    }
    if (HSM_LAYERING_DEBUG_MASK_MODE != (-1.0))
    {
        highp float debug_mask = 1.0;
        if (HSM_LAYERING_DEBUG_MASK_MODE == (-2.0))
        {
            debug_mask = CUTOUT_MASK;
        }
        else
        {
            highp float param_507 = HSM_LAYERING_DEBUG_MASK_MODE;
            debug_mask = GetMask(param_507);
        }
        highp vec4 param_508 = frag_color_linear;
        highp vec4 param_509 = vec4(0.1500000059604644775390625, 0.0, 0.0, 0.1500000059604644775390625) * debug_mask;
        frag_color_linear = HSM_PreMultAlphaBlend(param_508, param_509);
        highp vec4 param_510 = frag_color_linear;
        highp vec4 param_511 = vec4(0.0074999998323619365692138671875, 0.0074999998323619365692138671875, 0.0074999998323619365692138671875, 0.1500000059604644775390625) * (1.0 - debug_mask);
        frag_color_linear = HSM_PreMultAlphaBlend(param_510, param_511);
        frag_color_linear = clamp(frag_color_linear, vec4(0.0), vec4(1.0));
    }
    if ((global.HSM_REFLECT_MASK_IMAGE_AMOUNT / 100.0) > 0.0)
    {
        highp vec2 reflect_mask_scale = vec2(0.5);
        highp vec2 param_512 = VIEWPORT_COORD;
        highp float param_513 = global.HSM_REFLECT_MASK_FOLLOW_LAYER;
        highp float param_514 = global.HSM_REFLECT_MASK_FOLLOW_MODE;
        highp vec2 param_515 = reflect_mask_scale;
        reflect_mask_scale = param_515;
        highp vec2 reflect_mask_coord = HSM_GetLayerCoord(param_512, param_513, param_514, param_515);
        highp vec2 param_516 = reflect_mask_coord;
        highp vec2 param_517 = reflect_mask_scale;
        highp float param_518 = global.HSM_REFLECT_MASK_MIPMAPPING_BLEND_BIAS;
        highp float reflect_mask = HSM_GetMipmappedTexSample(ReflectionMaskImage, param_516, param_517, param_518).x;
        reflect_mask = clamp((((global.HSM_REFLECT_MASK_BLACK_LEVEL / 1000.0) + 1.0) * (reflect_mask - 1.0)) + 1.0, 0.0, 1.0);
        reflect_mask *= (global.HSM_REFLECT_MASK_BRIGHTNESS / 100.0);
        frag_color_linear.w = ((global.HSM_REFLECT_MASK_IMAGE_AMOUNT / 100.0) * reflect_mask) + (1.0 - (global.HSM_REFLECT_MASK_IMAGE_AMOUNT / 100.0));
    }
    else
    {
        frag_color_linear.w = 1.0;
    }
    FragColor = frag_color_linear;
    bool _9808 = UNFLIPPED_VIEWPORT_COORD.x < (2.0 / global.OutputSize.x);
    bool _9817;
    if (_9808)
    {
        _9817 = UNFLIPPED_VIEWPORT_COORD.y < (2.0 / global.OutputSize.y);
    }
    else
    {
        _9817 = _9808;
    }
    if (_9817)
    {
        FragColor.w = -1.0;
    }
}

